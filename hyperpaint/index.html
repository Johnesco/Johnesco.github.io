<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperPaint - Natural Media Painting</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
            height: 100vh;
            display: flex;
        }

        /* Sidebar */
        .sidebar {
            width: 240px;
            background: #16213e;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            border-right: 1px solid #0f3460;
        }

        .sidebar h1 {
            font-size: 1.4em;
            color: #e94560;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #0f3460;
        }

        .section {
            background: #0f3460;
            border-radius: 8px;
            padding: 12px;
        }

        .section-title {
            font-size: 0.85em;
            color: #aaa;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        /* Brush Type Buttons */
        .brush-types {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .brush-btn {
            aspect-ratio: 1;
            border: 2px solid #1a1a2e;
            border-radius: 8px;
            background: #16213e;
            color: #eee;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            transition: all 0.2s;
        }

        .brush-btn:hover {
            background: #1a1a2e;
            border-color: #e94560;
        }

        .brush-btn.active {
            background: #e94560;
            border-color: #e94560;
        }

        .brush-btn svg {
            width: 24px;
            height: 24px;
            margin-bottom: 4px;
        }

        /* Sliders */
        .slider-group {
            margin-bottom: 12px;
        }

        .slider-group:last-child {
            margin-bottom: 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .slider-value {
            color: #e94560;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #1a1a2e;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
        }

        /* Color Picker */
        .color-picker-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .color-preview {
            width: 100%;
            height: 40px;
            border-radius: 6px;
            border: 2px solid #1a1a2e;
        }

        .color-sliders input[type="range"] {
            margin-bottom: 8px;
        }

        #hue-slider {
            background: linear-gradient(to right,
                hsl(0, 100%, 50%), hsl(60, 100%, 50%), hsl(120, 100%, 50%),
                hsl(180, 100%, 50%), hsl(240, 100%, 50%), hsl(300, 100%, 50%), hsl(360, 100%, 50%));
        }

        #sat-slider {
            background: linear-gradient(to right, #888, #e94560);
        }

        #val-slider {
            background: linear-gradient(to right, #000, #fff);
        }

        .recent-colors {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .recent-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #1a1a2e;
            cursor: pointer;
        }

        .recent-color:hover {
            border-color: #e94560;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .action-btn {
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #1a1a2e;
            color: #eee;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: #e94560;
        }

        .action-btn.danger:hover {
            background: #d63031;
        }

        /* Canvas Container */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .canvas-container canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #bg-canvas {
            z-index: 1;
        }

        #paint-canvas {
            z-index: 2;
        }

        #preview-canvas {
            z-index: 3;
        }

        /* Cursor */
        .canvas-container {
            cursor: crosshair;
        }

        /* Keyboard shortcuts hint */
        .shortcuts {
            font-size: 0.75em;
            color: #666;
            text-align: center;
            padding-top: 10px;
            border-top: 1px solid #0f3460;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <h1>HyperPaint</h1>

        <div class="section">
            <div class="section-title">Brush Type</div>
            <div class="brush-types">
                <button class="brush-btn active" data-brush="watercolor" title="Watercolor">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                    </svg>
                    Water
                </button>
                <button class="brush-btn" data-brush="oil" title="Oil Paint">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M7 14c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm0 4c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm11-11l-6-6-6 6h12zm-6-3.17L15.17 7H8.83L12 3.83zM20 9v12H4V9h16z"/>
                    </svg>
                    Oil
                </button>
                <button class="brush-btn" data-brush="ink" title="Ink/Brush Pen">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                    </svg>
                    Ink
                </button>
                <button class="brush-btn" data-brush="pastel" title="Pastel">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19.35 10.04A7.49 7.49 0 0012 4C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 000 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z"/>
                    </svg>
                    Pastel
                </button>
                <button class="brush-btn" data-brush="chalk" title="Chalk">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <rect x="4" y="4" width="16" height="16" rx="2"/>
                    </svg>
                    Chalk
                </button>
                <button class="brush-btn" data-brush="eraser" title="Eraser">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15.14 3c-.51 0-1.02.2-1.41.59L2.59 14.73c-.78.77-.78 2.04 0 2.83l3.54 3.54c.39.39.9.59 1.41.59h8.68c.51 0 1.02-.2 1.41-.59l3.78-3.78c.78-.78.78-2.05 0-2.83L10.27 3.59c-.39-.39-.9-.59-1.41-.59H8.8h6.34z"/>
                    </svg>
                    Eraser
                </button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Brush Settings</div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Size</span>
                    <span class="slider-value" id="size-value">20</span>
                </div>
                <input type="range" id="size-slider" min="1" max="100" value="20">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Opacity</span>
                    <span class="slider-value" id="opacity-value">100%</span>
                </div>
                <input type="range" id="opacity-slider" min="1" max="100" value="100">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Flow/Wetness</span>
                    <span class="slider-value" id="flow-value">50%</span>
                </div>
                <input type="range" id="flow-slider" min="1" max="100" value="50">
            </div>
        </div>

        <div class="section">
            <div class="section-title">Color</div>
            <div class="color-picker-container">
                <div class="color-preview" id="color-preview"></div>
                <div class="color-sliders">
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Hue</span>
                            <span class="slider-value" id="hue-value">0</span>
                        </div>
                        <input type="range" id="hue-slider" min="0" max="360" value="0">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Saturation</span>
                            <span class="slider-value" id="sat-value">80%</span>
                        </div>
                        <input type="range" id="sat-slider" min="0" max="100" value="80">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Brightness</span>
                            <span class="slider-value" id="val-value">60%</span>
                        </div>
                        <input type="range" id="val-slider" min="0" max="100" value="60">
                    </div>
                </div>
                <div class="recent-colors" id="recent-colors"></div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Canvas</div>
            <div class="action-buttons">
                <button class="action-btn" id="undo-btn">Undo (Ctrl+Z)</button>
                <button class="action-btn" id="save-btn">Save as PNG</button>
                <button class="action-btn danger" id="clear-btn">Clear Canvas</button>
            </div>
        </div>

        <div class="shortcuts">
            [ and ] - Brush size<br>
            1-6 - Select brush<br>
            Ctrl+Z - Undo
        </div>
    </div>

    <div class="canvas-container" id="canvas-container">
        <canvas id="bg-canvas"></canvas>
        <canvas id="paint-canvas"></canvas>
        <canvas id="preview-canvas"></canvas>
    </div>

    <script>
    // ============================================
    // HyperPaint - Particle-Based Natural Media Painting
    // ============================================

    (function() {
        'use strict';

        // ============================================
        // Utility Functions
        // ============================================

        function hsvToRgb(h, s, v) {
            h = h / 360;
            s = s / 100;
            v = v / 100;
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        function dist(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // Perlin noise for paper texture
        class PerlinNoise {
            constructor() {
                this.p = [];
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
                }
                this.p = this.p.concat(this.p);
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }

            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.p[X] + Y;
                const B = this.p[X + 1] + Y;
                return lerp(
                    lerp(this.grad(this.p[A], x, y), this.grad(this.p[B], x - 1, y), u),
                    lerp(this.grad(this.p[A + 1], x, y - 1), this.grad(this.p[B + 1], x - 1, y - 1), u),
                    v
                );
            }

            fbm(x, y, octaves = 4) {
                let value = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    value += amplitude * this.noise(x * frequency, y * frequency);
                    maxValue += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                return value / maxValue;
            }
        }

        // Kubelka-Munk color mixing (simplified)
        function mixColors(c1, c2, ratio) {
            // Convert to reflectance (simplified)
            const r1 = { r: c1.r / 255, g: c1.g / 255, b: c1.b / 255 };
            const r2 = { r: c2.r / 255, g: c2.g / 255, b: c2.b / 255 };

            // K/S ratio approximation
            const ks1 = { r: (1 - r1.r) ** 2 / (2 * r1.r + 0.01), g: (1 - r1.g) ** 2 / (2 * r1.g + 0.01), b: (1 - r1.b) ** 2 / (2 * r1.b + 0.01) };
            const ks2 = { r: (1 - r2.r) ** 2 / (2 * r2.r + 0.01), g: (1 - r2.g) ** 2 / (2 * r2.g + 0.01), b: (1 - r2.b) ** 2 / (2 * r2.b + 0.01) };

            // Mix K/S
            const ksMix = {
                r: ks1.r * (1 - ratio) + ks2.r * ratio,
                g: ks1.g * (1 - ratio) + ks2.g * ratio,
                b: ks1.b * (1 - ratio) + ks2.b * ratio
            };

            // Convert back to reflectance
            const result = {
                r: Math.round((1 + ksMix.r - Math.sqrt(ksMix.r ** 2 + 2 * ksMix.r)) * 255),
                g: Math.round((1 + ksMix.g - Math.sqrt(ksMix.g ** 2 + 2 * ksMix.g)) * 255),
                b: Math.round((1 + ksMix.b - Math.sqrt(ksMix.b ** 2 + 2 * ksMix.b)) * 255)
            };

            return {
                r: clamp(result.r, 0, 255),
                g: clamp(result.g, 0, 255),
                b: clamp(result.b, 0, 255)
            };
        }

        // Catmull-Rom spline interpolation
        function catmullRom(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            return {
                x: 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3),
                y: 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3),
                pressure: lerp(p1.pressure || 0.5, p2.pressure || 0.5, t)
            };
        }

        // ============================================
        // Particle System
        // ============================================

        class Particle {
            constructor(x, y, color, size, options = {}) {
                this.x = x;
                this.y = y;
                this.vx = options.vx || 0;
                this.vy = options.vy || 0;
                this.color = { ...color };
                this.size = size;
                this.life = options.life || 1;
                this.maxLife = this.life;
                this.wetness = options.wetness || 0;
                this.thickness = options.thickness || 0;
                this.opacity = options.opacity || 1;
                this.textureAmount = options.textureAmount || 0;
                this.type = options.type || 'default';
                this.softEdge = options.softEdge || false;
                this.stamped = false;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vx *= 0.85;
                this.vy *= 0.85;
                this.life -= 1;

                if (this.wetness > 0) {
                    this.wetness *= 0.9;
                }

                return this.life > 0;
            }
        }

        class SpatialHash {
            constructor(cellSize = 50) {
                this.cellSize = cellSize;
                this.cells = new Map();
            }

            clear() {
                this.cells.clear();
            }

            getKey(x, y) {
                return `${Math.floor(x / this.cellSize)},${Math.floor(y / this.cellSize)}`;
            }

            insert(particle) {
                const key = this.getKey(particle.x, particle.y);
                if (!this.cells.has(key)) {
                    this.cells.set(key, []);
                }
                this.cells.get(key).push(particle);
            }

            getNearby(x, y, radius) {
                const result = [];
                const minX = Math.floor((x - radius) / this.cellSize);
                const maxX = Math.floor((x + radius) / this.cellSize);
                const minY = Math.floor((y - radius) / this.cellSize);
                const maxY = Math.floor((y + radius) / this.cellSize);

                for (let cx = minX; cx <= maxX; cx++) {
                    for (let cy = minY; cy <= maxY; cy++) {
                        const key = `${cx},${cy}`;
                        if (this.cells.has(key)) {
                            result.push(...this.cells.get(key));
                        }
                    }
                }
                return result;
            }
        }

        class ParticleEngine {
            constructor() {
                this.particles = [];
                this.spatialHash = new SpatialHash(40);
                this.maxParticles = 15000;
            }

            addParticle(particle) {
                if (this.particles.length < this.maxParticles) {
                    this.particles.push(particle);
                }
            }

            update(dt) {
                this.spatialHash.clear();

                this.particles = this.particles.filter(p => {
                    const alive = p.update(dt);
                    if (alive) {
                        this.spatialHash.insert(p);
                    }
                    return alive;
                });
            }

            clear() {
                this.particles = [];
                this.spatialHash.clear();
            }
        }

        // ============================================
        // Brush System
        // ============================================

        const BrushPresets = {
            watercolor: {
                particleCount: 10,
                sizeVariation: 0.5,
                velocitySpread: 0.3,
                wetness: 1.0,
                opacity: 0.04,
                lifeBase: 5,
                lifeVariation: 3,
                bleedRate: 0.1,
                edgeDarkening: true,
                granulation: 0.2,
                softEdge: true
            },
            oil: {
                particleCount: 6,
                sizeVariation: 0.25,
                velocitySpread: 0.1,
                wetness: 0,
                opacity: 0.7,
                lifeBase: 3,
                lifeVariation: 2,
                thickness: 0.8,
                colorMixing: true,
                directional: true,
                softEdge: false
            },
            ink: {
                particleCount: 4,
                sizeVariation: 0.15,
                velocitySpread: 0.05,
                wetness: 0.3,
                opacity: 0.85,
                lifeBase: 2,
                lifeVariation: 1,
                pooling: true,
                dryBrush: true,
                softEdge: false
            },
            pastel: {
                particleCount: 18,
                sizeVariation: 0.5,
                velocitySpread: 0.3,
                wetness: 0,
                opacity: 0.25,
                lifeBase: 3,
                lifeVariation: 2,
                textureAmount: 0.9,
                grainy: true,
                gapProbability: 0.15,
                softEdge: false
            },
            chalk: {
                particleCount: 14,
                sizeVariation: 0.6,
                velocitySpread: 0.4,
                wetness: 0,
                opacity: 0.35,
                lifeBase: 3,
                lifeVariation: 2,
                textureAmount: 1.0,
                grainy: true,
                gapProbability: 0.25,
                softEdge: false
            },
            eraser: {
                particleCount: 1,
                sizeVariation: 0,
                velocitySpread: 0,
                wetness: 0,
                opacity: 1,
                lifeBase: 1,
                lifeVariation: 0,
                isEraser: true,
                softEdge: false
            }
        };

        class BrushEngine {
            constructor(particleEngine, perlin) {
                this.particleEngine = particleEngine;
                this.perlin = perlin;
                this.currentBrush = 'watercolor';
                this.size = 20;
                this.opacity = 1;
                this.flow = 0.5;
                this.color = { r: 233, g: 69, b: 96 };
                this.points = [];
            }

            setColor(r, g, b) {
                this.color = { r, g, b };
            }

            setBrush(brushType) {
                this.currentBrush = brushType;
            }

            addPoint(x, y, pressure = 0.5) {
                this.points.push({ x, y, pressure, time: Date.now() });
                if (this.points.length > 4) {
                    this.points.shift();
                }
            }

            emitParticles(x, y, pressure, prevX, prevY) {
                const preset = BrushPresets[this.currentBrush];
                const effectiveSize = this.size * (0.5 + pressure * 0.5);
                const particleCount = Math.ceil(preset.particleCount * this.flow * pressure);

                // Calculate stroke direction
                const dx = x - prevX;
                const dy = y - prevY;
                const strokeAngle = Math.atan2(dy, dx);
                const speed = dist(x, y, prevX, prevY);

                for (let i = 0; i < particleCount; i++) {
                    // Skip particles for chalk gaps
                    if (preset.gapProbability && Math.random() < preset.gapProbability) {
                        continue;
                    }

                    // Size variation
                    const sizeVar = 1 + (Math.random() - 0.5) * 2 * preset.sizeVariation;
                    const particleSize = effectiveSize * sizeVar * (0.3 + Math.random() * 0.7);

                    // Position offset
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * effectiveSize * 0.5;
                    let px = x + Math.cos(angle) * radius;
                    let py = y + Math.sin(angle) * radius;

                    // Directional particles for oil
                    if (preset.directional) {
                        const perpAngle = strokeAngle + Math.PI / 2;
                        const offset = (Math.random() - 0.5) * effectiveSize;
                        px = x + Math.cos(perpAngle) * offset;
                        py = y + Math.sin(perpAngle) * offset;
                    }

                    // Velocity
                    let vx = (Math.random() - 0.5) * preset.velocitySpread;
                    let vy = (Math.random() - 0.5) * preset.velocitySpread;

                    // Watercolor bleeding velocity
                    if (preset.bleedRate) {
                        vx += (Math.random() - 0.5) * preset.bleedRate * 10;
                        vy += (Math.random() - 0.5) * preset.bleedRate * 10;
                    }

                    // Color variation for watercolor granulation
                    let particleColor = { ...this.color };
                    if (preset.granulation) {
                        const variation = (Math.random() - 0.5) * preset.granulation * 50;
                        particleColor.r = clamp(particleColor.r + variation, 0, 255);
                        particleColor.g = clamp(particleColor.g + variation, 0, 255);
                        particleColor.b = clamp(particleColor.b + variation, 0, 255);
                    }

                    // Edge darkening for watercolor
                    let particleOpacity = preset.opacity * this.opacity;
                    if (preset.edgeDarkening) {
                        const distFromCenter = dist(px, py, x, y) / effectiveSize;
                        particleOpacity *= (0.5 + distFromCenter * 0.8);
                    }

                    // Dry brush effect for ink
                    if (preset.dryBrush && speed > 15) {
                        const dryFactor = Math.min(1, (speed - 15) / 30);
                        if (Math.random() < dryFactor * 0.5) continue;
                    }

                    // Texture amount for pastel/chalk
                    let textureAmount = preset.textureAmount || 0;
                    if (textureAmount > 0) {
                        const noiseVal = this.perlin.fbm(px * 0.05, py * 0.05, 3);
                        if (noiseVal < textureAmount * 0.3 - 0.3) continue;
                    }

                    const particle = new Particle(px, py, particleColor, particleSize, {
                        vx, vy,
                        life: preset.lifeBase + Math.random() * preset.lifeVariation,
                        wetness: preset.wetness * this.flow,
                        thickness: preset.thickness || 0,
                        opacity: particleOpacity,
                        textureAmount: textureAmount,
                        type: this.currentBrush,
                        softEdge: preset.softEdge || false
                    });

                    this.particleEngine.addParticle(particle);
                }
            }

            getInterpolatedPoints() {
                if (this.points.length < 2) return [];

                const result = [];
                const pts = this.points;

                if (pts.length === 2) {
                    const distance = dist(pts[0].x, pts[0].y, pts[1].x, pts[1].y);
                    const steps = Math.max(1, Math.floor(distance / 3));
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        result.push({
                            x: lerp(pts[0].x, pts[1].x, t),
                            y: lerp(pts[0].y, pts[1].y, t),
                            pressure: lerp(pts[0].pressure, pts[1].pressure, t)
                        });
                    }
                } else if (pts.length >= 4) {
                    const p0 = pts[pts.length - 4];
                    const p1 = pts[pts.length - 3];
                    const p2 = pts[pts.length - 2];
                    const p3 = pts[pts.length - 1];

                    const distance = dist(p1.x, p1.y, p2.x, p2.y);
                    const steps = Math.max(1, Math.floor(distance / 3));

                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        result.push(catmullRom(p0, p1, p2, p3, t));
                    }
                }

                return result;
            }

            clearPoints() {
                this.points = [];
            }
        }

        // ============================================
        // Watercolor Wet System
        // ============================================

        class WetCanvas {
            constructor(width, height, perlin) {
                this.width = width;
                this.height = height;
                this.perlin = perlin;
                this.dryTime = 30000; // 30 seconds to dry

                // Wet layer canvas for color data
                this.wetCanvas = document.createElement('canvas');
                this.wetCanvas.width = width;
                this.wetCanvas.height = height;
                this.wetCtx = this.wetCanvas.getContext('2d', { willReadFrequently: true });

                // Wetness map (tracks wetness level and time for each region)
                this.wetRegions = []; // { x, y, radius, color, wetness, createdAt, pigment }
                this.cellSize = 8;
                this.cols = Math.ceil(width / this.cellSize);
                this.rows = Math.ceil(height / this.cellSize);

                // Grid for wetness tracking
                this.wetnessGrid = new Float32Array(this.cols * this.rows);
                this.colorGrid = []; // Store color data per cell
                for (let i = 0; i < this.cols * this.rows; i++) {
                    this.colorGrid.push({ r: 0, g: 0, b: 0, pigment: 0 });
                }
            }

            resize(width, height) {
                this.width = width;
                this.height = height;
                this.wetCanvas.width = width;
                this.wetCanvas.height = height;
                this.cols = Math.ceil(width / this.cellSize);
                this.rows = Math.ceil(height / this.cellSize);
                this.wetnessGrid = new Float32Array(this.cols * this.rows);
                this.colorGrid = [];
                for (let i = 0; i < this.cols * this.rows; i++) {
                    this.colorGrid.push({ r: 0, g: 0, b: 0, pigment: 0 });
                }
                this.wetRegions = [];
            }

            getGridIndex(x, y) {
                const col = Math.floor(x / this.cellSize);
                const row = Math.floor(y / this.cellSize);
                if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) return -1;
                return row * this.cols + col;
            }

            addWetPaint(x, y, radius, color, amount = 1) {
                const now = Date.now();

                // Add to wet regions for edge pooling simulation
                this.wetRegions.push({
                    x, y, radius,
                    color: { ...color },
                    wetness: amount,
                    createdAt: now,
                    pigment: amount
                });

                // Update grid cells in radius
                const minCol = Math.max(0, Math.floor((x - radius) / this.cellSize));
                const maxCol = Math.min(this.cols - 1, Math.floor((x + radius) / this.cellSize));
                const minRow = Math.max(0, Math.floor((y - radius) / this.cellSize));
                const maxRow = Math.min(this.rows - 1, Math.floor((y + radius) / this.cellSize));

                for (let row = minRow; row <= maxRow; row++) {
                    for (let col = minCol; col <= maxCol; col++) {
                        const cx = (col + 0.5) * this.cellSize;
                        const cy = (row + 0.5) * this.cellSize;
                        const dist = Math.sqrt((cx - x) ** 2 + (cy - y) ** 2);

                        if (dist <= radius) {
                            const idx = row * this.cols + col;
                            const falloff = 1 - (dist / radius);
                            const addWet = amount * falloff;

                            // Blend colors if already wet
                            const cell = this.colorGrid[idx];
                            const existingWet = this.wetnessGrid[idx];

                            if (existingWet > 0.01 && cell.pigment > 0.01) {
                                // Mix colors
                                const ratio = addWet / (existingWet + addWet);
                                cell.r = cell.r * (1 - ratio) + color.r * ratio;
                                cell.g = cell.g * (1 - ratio) + color.g * ratio;
                                cell.b = cell.b * (1 - ratio) + color.b * ratio;
                                cell.pigment = Math.min(1, cell.pigment + addWet * 0.5);
                            } else {
                                cell.r = color.r;
                                cell.g = color.g;
                                cell.b = color.b;
                                cell.pigment = addWet;
                            }

                            this.wetnessGrid[idx] = Math.min(1, existingWet + addWet);
                        }
                    }
                }
            }

            isWet(x, y) {
                const idx = this.getGridIndex(x, y);
                if (idx < 0) return false;
                return this.wetnessGrid[idx] > 0.05;
            }

            getWetness(x, y) {
                const idx = this.getGridIndex(x, y);
                if (idx < 0) return 0;
                return this.wetnessGrid[idx];
            }

            getWetColor(x, y) {
                const idx = this.getGridIndex(x, y);
                if (idx < 0) return null;
                const cell = this.colorGrid[idx];
                if (cell.pigment < 0.01) return null;
                return { r: cell.r, g: cell.g, b: cell.b };
            }

            update(dt, paintCtx) {
                const now = Date.now();

                // Simulate water flow - pigment moves to edges
                this.simulateWaterFlow(dt);

                // Remove dried regions and render drying paint
                this.wetRegions = this.wetRegions.filter(region => {
                    const age = now - region.createdAt;
                    const dryRatio = Math.min(1, age / this.dryTime);

                    // Still wet
                    if (dryRatio < 1) {
                        region.wetness = 1 - dryRatio;
                        return true;
                    }

                    return false;
                });

                // Decay wetness grid
                for (let i = 0; i < this.wetnessGrid.length; i++) {
                    if (this.wetnessGrid[i] > 0) {
                        this.wetnessGrid[i] *= 0.9995; // Slow decay
                        if (this.wetnessGrid[i] < 0.01) {
                            this.wetnessGrid[i] = 0;
                        }
                    }
                }
            }

            simulateWaterFlow(dt) {
                // Simple flow simulation - pigment spreads and pools at edges
                const newColorGrid = this.colorGrid.map(c => ({ ...c }));

                for (let row = 1; row < this.rows - 1; row++) {
                    for (let col = 1; col < this.cols - 1; col++) {
                        const idx = row * this.cols + col;
                        const wetness = this.wetnessGrid[idx];

                        if (wetness > 0.1) {
                            const cell = this.colorGrid[idx];
                            if (cell.pigment < 0.01) continue;

                            // Check neighbors for flow
                            const neighbors = [
                                (row - 1) * this.cols + col,
                                (row + 1) * this.cols + col,
                                row * this.cols + (col - 1),
                                row * this.cols + (col + 1)
                            ];

                            for (const nIdx of neighbors) {
                                const nWet = this.wetnessGrid[nIdx];
                                // Flow towards less wet areas (edge pooling)
                                if (nWet < wetness && nWet > 0.05) {
                                    const flowAmount = (wetness - nWet) * 0.02 * cell.pigment;
                                    if (flowAmount > 0.001) {
                                        const nCell = newColorGrid[nIdx];
                                        const ratio = flowAmount / (nCell.pigment + flowAmount + 0.01);
                                        nCell.r = nCell.r * (1 - ratio) + cell.r * ratio;
                                        nCell.g = nCell.g * (1 - ratio) + cell.g * ratio;
                                        nCell.b = nCell.b * (1 - ratio) + cell.b * ratio;
                                        nCell.pigment = Math.min(1, nCell.pigment + flowAmount);
                                        newColorGrid[idx].pigment = Math.max(0, newColorGrid[idx].pigment - flowAmount * 0.5);
                                    }
                                }
                            }
                        }
                    }
                }

                this.colorGrid = newColorGrid;
            }

            renderWetLayer(ctx) {
                // Render wet paint on top
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const idx = row * this.cols + col;
                        const cell = this.colorGrid[idx];
                        const wetness = this.wetnessGrid[idx];

                        if (cell.pigment > 0.01 && wetness > 0.01) {
                            const x = col * this.cellSize;
                            const y = row * this.cellSize;
                            const alpha = cell.pigment * 0.15 * wetness;

                            ctx.fillStyle = `rgba(${Math.round(cell.r)}, ${Math.round(cell.g)}, ${Math.round(cell.b)}, ${alpha})`;
                            ctx.fillRect(x, y, this.cellSize, this.cellSize);
                        }
                    }
                }
            }

            // Bake wet paint to permanent layer when drying
            bakeToPermanent(paintCtx) {
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const idx = row * this.cols + col;
                        const cell = this.colorGrid[idx];
                        const wetness = this.wetnessGrid[idx];

                        // Bake cells that are drying (low wetness but have pigment)
                        if (cell.pigment > 0.02 && wetness < 0.1 && wetness > 0.01) {
                            const x = col * this.cellSize;
                            const y = row * this.cellSize;
                            const alpha = cell.pigment * 0.08;

                            paintCtx.fillStyle = `rgba(${Math.round(cell.r)}, ${Math.round(cell.g)}, ${Math.round(cell.b)}, ${alpha})`;
                            paintCtx.fillRect(x, y, this.cellSize, this.cellSize);

                            // Clear the cell after baking
                            cell.pigment *= 0.8;
                        }
                    }
                }
            }

            clear() {
                this.wetRegions = [];
                this.wetnessGrid.fill(0);
                for (let i = 0; i < this.colorGrid.length; i++) {
                    this.colorGrid[i] = { r: 0, g: 0, b: 0, pigment: 0 };
                }
                this.wetCtx.clearRect(0, 0, this.width, this.height);
            }
        }

        // ============================================
        // Renderer
        // ============================================

        class Renderer {
            constructor(bgCanvas, paintCanvas, previewCanvas, perlin) {
                this.bgCanvas = bgCanvas;
                this.paintCanvas = paintCanvas;
                this.previewCanvas = previewCanvas;
                this.bgCtx = bgCanvas.getContext('2d');
                this.paintCtx = paintCanvas.getContext('2d');
                this.previewCtx = previewCanvas.getContext('2d');
                this.perlin = perlin;
                this.paperTexture = null;
                this.wetCanvas = null;
            }

            resize(width, height) {
                [this.bgCanvas, this.paintCanvas, this.previewCanvas].forEach(canvas => {
                    canvas.width = width;
                    canvas.height = height;
                });
                this.generatePaperTexture();

                // Initialize or resize wet canvas
                if (!this.wetCanvas) {
                    this.wetCanvas = new WetCanvas(width, height, this.perlin);
                } else {
                    this.wetCanvas.resize(width, height);
                }
            }

            generatePaperTexture() {
                const width = this.bgCanvas.width;
                const height = this.bgCanvas.height;

                this.bgCtx.fillStyle = '#f5f5f0';
                this.bgCtx.fillRect(0, 0, width, height);

                const imageData = this.bgCtx.getImageData(0, 0, width, height);
                const data = imageData.data;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const noise = this.perlin.fbm(x * 0.02, y * 0.02, 4);
                        const variation = noise * 15;
                        const idx = (y * width + x) * 4;
                        data[idx] = clamp(245 + variation, 230, 255);
                        data[idx + 1] = clamp(245 + variation, 230, 255);
                        data[idx + 2] = clamp(240 + variation, 225, 250);
                    }
                }

                this.bgCtx.putImageData(imageData, 0, 0);

                // Store paper texture for chalk/pastel
                this.paperTexture = this.bgCtx.getImageData(0, 0, width, height);
            }

            getPaperValue(x, y) {
                if (!this.paperTexture) return 1;
                const ix = Math.floor(x);
                const iy = Math.floor(y);
                if (ix < 0 || ix >= this.paperTexture.width || iy < 0 || iy >= this.paperTexture.height) {
                    return 1;
                }
                const idx = (iy * this.paperTexture.width + ix) * 4;
                return this.paperTexture.data[idx] / 255;
            }

            renderParticles(particles) {
                const ctx = this.paintCtx;

                particles.forEach(p => {
                    if (p.life <= 0) return;

                    // Watercolor can stamp multiple times as it bleeds
                    const canBleed = p.type === 'watercolor' && p.wetness > 0.1 && (Math.abs(p.vx) > 0.01 || Math.abs(p.vy) > 0.01);

                    if (p.stamped && !canBleed) return;

                    // Mark as stamped (watercolor will keep stamping while bleeding)
                    if (!canBleed) p.stamped = true;

                    let alpha = p.opacity;

                    // Reduce alpha for bleeding watercolor
                    if (canBleed) {
                        alpha *= p.wetness * 0.3;
                    }

                    // Paper texture interaction for pastel/chalk
                    if (p.textureAmount > 0) {
                        const paperVal = this.getPaperValue(p.x, p.y);
                        // Only deposit on raised areas of paper
                        if (paperVal < 0.94) {
                            alpha *= Math.pow(paperVal, 0.5);
                        }
                    }

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);

                    // Different rendering based on brush type
                    if (p.type === 'oil' && p.thickness > 0) {
                        // Impasto effect - thick paint with highlight/shadow
                        const gradient = ctx.createRadialGradient(
                            p.x - p.size * 0.25, p.y - p.size * 0.25, 0,
                            p.x, p.y, p.size
                        );
                        const highlightColor = `rgba(${Math.min(255, p.color.r + 30)}, ${Math.min(255, p.color.g + 30)}, ${Math.min(255, p.color.b + 30)}, ${alpha})`;
                        const mainColor = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha})`;
                        const shadowColor = `rgba(${Math.max(0, p.color.r - 20)}, ${Math.max(0, p.color.g - 20)}, ${Math.max(0, p.color.b - 20)}, ${alpha})`;

                        gradient.addColorStop(0, highlightColor);
                        gradient.addColorStop(0.6, mainColor);
                        gradient.addColorStop(1, shadowColor);
                        ctx.fillStyle = gradient;
                    } else if (p.type === 'watercolor' || p.softEdge) {
                        // Add to wet canvas for blending and pooling
                        if (this.wetCanvas && p.type === 'watercolor') {
                            this.wetCanvas.addWetPaint(p.x, p.y, p.size * 1.5, p.color, p.wetness);
                        }

                        // Soft watercolor with feathered edges
                        const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                        gradient.addColorStop(0, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha})`);
                        gradient.addColorStop(0.4, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.7})`);
                        gradient.addColorStop(0.8, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.3})`);
                        gradient.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, 0)`);
                        ctx.fillStyle = gradient;
                    } else if (p.type === 'ink') {
                        // Sharp ink marks
                        ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha})`;
                    } else if (p.type === 'pastel' || p.type === 'chalk') {
                        // Chalky texture - slightly rough edges
                        const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                        gradient.addColorStop(0, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha})`);
                        gradient.addColorStop(0.7, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.8})`);
                        gradient.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.1})`);
                        ctx.fillStyle = gradient;
                    } else {
                        ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha})`;
                    }

                    ctx.fill();
                });
            }

            renderCursor(x, y, size, color) {
                const ctx = this.previewCtx;

                // Draw cursor on top of wet layer (wet layer is rendered by animate loop)
                ctx.beginPath();
                ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            clearPaint() {
                this.paintCtx.clearRect(0, 0, this.paintCanvas.width, this.paintCanvas.height);
                if (this.wetCanvas) {
                    this.wetCanvas.clear();
                }
            }

            updateWetLayer(dt) {
                if (this.wetCanvas) {
                    this.wetCanvas.update(dt, this.paintCtx);
                    this.wetCanvas.bakeToPermanent(this.paintCtx);
                }
            }

            renderWetLayer() {
                if (this.wetCanvas) {
                    this.wetCanvas.renderWetLayer(this.previewCtx);
                }
            }

            isAreaWet(x, y) {
                return this.wetCanvas && this.wetCanvas.isWet(x, y);
            }

            eraseAt(x, y, size) {
                // Only erase dry paint - wet areas can't be erased
                if (this.isAreaWet(x, y)) {
                    return false; // Area is wet, can't erase
                }

                this.paintCtx.save();
                this.paintCtx.globalCompositeOperation = 'destination-out';
                this.paintCtx.beginPath();
                this.paintCtx.arc(x, y, size, 0, Math.PI * 2);
                this.paintCtx.fill();
                this.paintCtx.restore();
                return true;
            }

            getSnapshot() {
                return this.paintCtx.getImageData(0, 0, this.paintCanvas.width, this.paintCanvas.height);
            }

            restoreSnapshot(imageData) {
                this.paintCtx.putImageData(imageData, 0, 0);
            }

            exportPNG() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.paintCanvas.width;
                tempCanvas.height = this.paintCanvas.height;
                const ctx = tempCanvas.getContext('2d');

                ctx.drawImage(this.bgCanvas, 0, 0);
                ctx.drawImage(this.paintCanvas, 0, 0);

                return tempCanvas.toDataURL('image/png');
            }
        }

        // ============================================
        // Undo System
        // ============================================

        class UndoSystem {
            constructor(maxSnapshots = 10) {
                this.snapshots = [];
                this.maxSnapshots = maxSnapshots;
            }

            save(imageData) {
                this.snapshots.push(imageData);
                if (this.snapshots.length > this.maxSnapshots) {
                    this.snapshots.shift();
                }
            }

            undo() {
                if (this.snapshots.length > 0) {
                    return this.snapshots.pop();
                }
                return null;
            }

            clear() {
                this.snapshots = [];
            }

            get canUndo() {
                return this.snapshots.length > 0;
            }
        }

        // ============================================
        // Main Application
        // ============================================

        class HyperPaint {
            constructor() {
                this.container = document.getElementById('canvas-container');
                this.bgCanvas = document.getElementById('bg-canvas');
                this.paintCanvas = document.getElementById('paint-canvas');
                this.previewCanvas = document.getElementById('preview-canvas');

                this.perlin = new PerlinNoise();
                this.particleEngine = new ParticleEngine();
                this.brushEngine = new BrushEngine(this.particleEngine, this.perlin);
                this.renderer = new Renderer(this.bgCanvas, this.paintCanvas, this.previewCanvas, this.perlin);
                this.undoSystem = new UndoSystem(10);

                this.isDrawing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.recentColors = [];
                this.currentHSV = { h: 0, s: 80, v: 60 };

                this.init();
            }

            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.setupInputHandlers();
                this.setupUI();
                this.updateColor();

                this.animate();
            }

            resize() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;
                this.renderer.resize(width, height);
            }

            setupInputHandlers() {
                const canvas = this.previewCanvas;

                const getPointerData = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    let x, y, pressure;

                    if (e.touches) {
                        x = e.touches[0].clientX - rect.left;
                        y = e.touches[0].clientY - rect.top;
                        pressure = e.touches[0].force || 0.5;
                    } else {
                        x = e.clientX - rect.left;
                        y = e.clientY - rect.top;
                        pressure = e.pressure !== undefined ? e.pressure : 0.5;
                        if (pressure === 0) pressure = 0.5; // Default for mouse
                    }

                    return { x, y, pressure };
                };

                const startStroke = (e) => {
                    e.preventDefault();
                    this.isDrawing = true;
                    const { x, y, pressure } = getPointerData(e);
                    this.lastX = x;
                    this.lastY = y;
                    this.brushEngine.clearPoints();
                    this.brushEngine.addPoint(x, y, pressure);

                    // Save snapshot for undo
                    this.undoSystem.save(this.renderer.getSnapshot());
                };

                const moveStroke = (e) => {
                    const { x, y, pressure } = getPointerData(e);
                    this.renderer.renderCursor(x, y, this.brushEngine.size);

                    if (!this.isDrawing) return;
                    e.preventDefault();

                    this.brushEngine.addPoint(x, y, pressure);

                    const preset = BrushPresets[this.brushEngine.currentBrush];

                    if (preset.isEraser) {
                        // Eraser mode
                        const points = this.brushEngine.getInterpolatedPoints();
                        points.forEach(pt => {
                            this.renderer.eraseAt(pt.x, pt.y, this.brushEngine.size);
                        });
                    } else {
                        // Normal brush
                        const points = this.brushEngine.getInterpolatedPoints();
                        points.forEach(pt => {
                            this.brushEngine.emitParticles(pt.x, pt.y, pt.pressure, this.lastX, this.lastY);
                            this.lastX = pt.x;
                            this.lastY = pt.y;
                        });
                    }

                    this.lastX = x;
                    this.lastY = y;
                };

                const endStroke = () => {
                    if (this.isDrawing) {
                        this.isDrawing = false;
                        this.brushEngine.clearPoints();
                        this.addRecentColor(this.brushEngine.color);
                    }
                };

                // Mouse events
                canvas.addEventListener('mousedown', startStroke);
                canvas.addEventListener('mousemove', moveStroke);
                canvas.addEventListener('mouseup', endStroke);
                canvas.addEventListener('mouseleave', endStroke);

                // Touch events
                canvas.addEventListener('touchstart', startStroke, { passive: false });
                canvas.addEventListener('touchmove', moveStroke, { passive: false });
                canvas.addEventListener('touchend', endStroke);
                canvas.addEventListener('touchcancel', endStroke);

                // Pointer events for pressure
                canvas.addEventListener('pointerdown', startStroke);
                canvas.addEventListener('pointermove', moveStroke);
                canvas.addEventListener('pointerup', endStroke);
                canvas.addEventListener('pointercancel', endStroke);

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                    } else if (e.key === '[') {
                        this.brushEngine.size = Math.max(1, this.brushEngine.size - 5);
                        document.getElementById('size-slider').value = this.brushEngine.size;
                        document.getElementById('size-value').textContent = this.brushEngine.size;
                    } else if (e.key === ']') {
                        this.brushEngine.size = Math.min(100, this.brushEngine.size + 5);
                        document.getElementById('size-slider').value = this.brushEngine.size;
                        document.getElementById('size-value').textContent = this.brushEngine.size;
                    } else if (e.key >= '1' && e.key <= '6') {
                        const brushTypes = ['watercolor', 'oil', 'ink', 'pastel', 'chalk', 'eraser'];
                        const index = parseInt(e.key) - 1;
                        this.selectBrush(brushTypes[index]);
                    }
                });
            }

            setupUI() {
                // Brush type buttons
                document.querySelectorAll('.brush-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.selectBrush(btn.dataset.brush);
                    });
                });

                // Size slider
                const sizeSlider = document.getElementById('size-slider');
                sizeSlider.addEventListener('input', () => {
                    this.brushEngine.size = parseInt(sizeSlider.value);
                    document.getElementById('size-value').textContent = sizeSlider.value;
                });

                // Opacity slider
                const opacitySlider = document.getElementById('opacity-slider');
                opacitySlider.addEventListener('input', () => {
                    this.brushEngine.opacity = parseInt(opacitySlider.value) / 100;
                    document.getElementById('opacity-value').textContent = opacitySlider.value + '%';
                });

                // Flow slider
                const flowSlider = document.getElementById('flow-slider');
                flowSlider.addEventListener('input', () => {
                    this.brushEngine.flow = parseInt(flowSlider.value) / 100;
                    document.getElementById('flow-value').textContent = flowSlider.value + '%';
                });

                // Color sliders
                ['hue', 'sat', 'val'].forEach(type => {
                    const slider = document.getElementById(`${type}-slider`);
                    slider.addEventListener('input', () => {
                        this.currentHSV.h = parseInt(document.getElementById('hue-slider').value);
                        this.currentHSV.s = parseInt(document.getElementById('sat-slider').value);
                        this.currentHSV.v = parseInt(document.getElementById('val-slider').value);
                        this.updateColor();
                    });
                });

                // Action buttons
                document.getElementById('undo-btn').addEventListener('click', () => this.undo());
                document.getElementById('save-btn').addEventListener('click', () => this.save());
                document.getElementById('clear-btn').addEventListener('click', () => this.clear());
            }

            selectBrush(brushType) {
                this.brushEngine.setBrush(brushType);
                document.querySelectorAll('.brush-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.brush === brushType);
                });
            }

            updateColor() {
                const rgb = hsvToRgb(this.currentHSV.h, this.currentHSV.s, this.currentHSV.v);
                this.brushEngine.setColor(rgb.r, rgb.g, rgb.b);

                const preview = document.getElementById('color-preview');
                preview.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;

                document.getElementById('hue-value').textContent = this.currentHSV.h;
                document.getElementById('sat-value').textContent = this.currentHSV.s + '%';
                document.getElementById('val-value').textContent = this.currentHSV.v + '%';

                // Update saturation slider gradient
                const hue = this.currentHSV.h;
                document.getElementById('sat-slider').style.background =
                    `linear-gradient(to right, hsl(${hue}, 0%, 50%), hsl(${hue}, 100%, 50%))`;
            }

            addRecentColor(color) {
                const colorStr = `${color.r},${color.g},${color.b}`;
                if (this.recentColors.length === 0 || this.recentColors[0] !== colorStr) {
                    this.recentColors.unshift(colorStr);
                    if (this.recentColors.length > 8) {
                        this.recentColors.pop();
                    }
                    this.updateRecentColors();
                }
            }

            updateRecentColors() {
                const container = document.getElementById('recent-colors');
                container.innerHTML = '';
                this.recentColors.forEach(colorStr => {
                    const [r, g, b] = colorStr.split(',').map(Number);
                    const swatch = document.createElement('div');
                    swatch.className = 'recent-color';
                    swatch.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                    swatch.addEventListener('click', () => {
                        this.brushEngine.setColor(r, g, b);
                        document.getElementById('color-preview').style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                    });
                    container.appendChild(swatch);
                });
            }

            undo() {
                const snapshot = this.undoSystem.undo();
                if (snapshot) {
                    this.renderer.restoreSnapshot(snapshot);
                    this.particleEngine.clear();
                }
            }

            save() {
                const dataUrl = this.renderer.exportPNG();
                const link = document.createElement('a');
                link.download = 'hyperpaint-artwork.png';
                link.href = dataUrl;
                link.click();
            }

            clear() {
                if (confirm('Clear the canvas? This cannot be undone.')) {
                    this.undoSystem.save(this.renderer.getSnapshot());
                    this.renderer.clearPaint();
                    this.particleEngine.clear();
                }
            }

            animate() {
                const dt = 16; // Assuming 60fps

                this.particleEngine.update(dt);
                this.renderer.renderParticles(this.particleEngine.particles);

                // Update wet watercolor layer (handles drying and flow simulation)
                this.renderer.updateWetLayer(dt);

                // Clear preview and render wet layer (cursor is drawn on mouse move)
                this.renderer.previewCtx.clearRect(0, 0, this.renderer.previewCanvas.width, this.renderer.previewCanvas.height);
                this.renderer.renderWetLayer();

                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize application
        new HyperPaint();
    })();
    </script>
</body>
</html>
