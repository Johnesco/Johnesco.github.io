<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>080 â€” Terrarium</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  background: #1a1610;
  font-family: 'Georgia', serif;
  color: #d4c5a0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#canvas {
  display: block;
  cursor: pointer;
}

#input-container {
  position: absolute;
  top: 15%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(42, 35, 25, 0.95);
  padding: 20px 30px;
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
}

#input-container.visible {
  opacity: 1;
  pointer-events: all;
}

#task-input {
  width: 300px;
  padding: 12px;
  font-size: 16px;
  background: #2a2318;
  border: 1px solid #4a3d28;
  color: #d4c5a0;
  border-radius: 4px;
  font-family: 'Georgia', serif;
}

#task-input:focus {
  outline: none;
  border-color: #6a5d48;
}

#stats {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  text-align: center;
  font-size: 13px;
  opacity: 0.7;
  line-height: 1.6;
}

#selected-info {
  position: absolute;
  background: rgba(42, 35, 25, 0.95);
  padding: 12px 18px;
  border-radius: 6px;
  font-size: 14px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s;
  max-width: 300px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
}

#selected-info.visible {
  opacity: 1;
}

.hint {
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 12px;
  opacity: 0.5;
  text-align: center;
}
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="input-container">
  <input type="text" id="task-input" placeholder="What grows here?" maxlength="60" />
</div>

<div id="selected-info"></div>

<div id="stats">
  <div id="organism-count">No organisms yet</div>
  <div id="ecosystem-age">Ecosystem waiting to begin</div>
</div>

<div class="hint">Click inside the jar to add life</div>

<script>
// Storage
const STORAGE_KEY = 'todooo-080';

// State
let tasks = [];
let selectedTask = null;
let isInputVisible = false;
let ecosystemStartTime = null;
let lastUpdateTime = Date.now();

// Canvas
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width, height;
let jarBounds = {};

// Audio
let audioContext = null;
let audioInitialized = false;

// Animation
let animationFrame = 0;
let waterDroplets = [];

// Init
function init() {
  resize();
  window.addEventListener('resize', resize);
  canvas.addEventListener('click', handleClick);
  canvas.addEventListener('dblclick', handleDoubleClick);
  canvas.addEventListener('contextmenu', handleRightClick);

  const input = document.getElementById('task-input');
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && input.value.trim()) {
      addTask(input.value.trim());
      input.value = '';
      hideInput();
    } else if (e.key === 'Escape') {
      hideInput();
    }
  });

  loadTasks();
  loop();
}

function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
  calculateJarBounds();
}

function calculateJarBounds() {
  const jarHeight = height * 0.6;
  const jarWidth = jarHeight * 0.5;
  const jarX = width / 2;
  const jarY = height / 2 - jarHeight * 0.1;

  jarBounds = {
    x: jarX,
    y: jarY,
    width: jarWidth,
    height: jarHeight,
    topY: jarY - jarHeight / 2,
    bottomY: jarY + jarHeight / 2,
    leftX: jarX - jarWidth / 2,
    rightX: jarX + jarWidth / 2
  };
}

// Task management
function loadTasks() {
  const stored = localStorage.getItem(STORAGE_KEY);
  if (stored) {
    const data = JSON.parse(stored);
    tasks = data.tasks || [];
    ecosystemStartTime = data.ecosystemStartTime || null;

    // Initialize organism data
    tasks.forEach(task => {
      if (!task.organism) {
        assignOrganism(task);
      }
    });
  }
  updateStats();
}

function saveTasks() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify({
    tasks,
    ecosystemStartTime
  }));
  updateStats();
}

function addTask(text) {
  initAudio();

  if (!ecosystemStartTime) {
    ecosystemStartTime = Date.now();
  }

  const task = {
    id: Date.now() + Math.random(),
    text,
    created: Date.now(),
    completed: false,
    completedAt: null
  };

  assignOrganism(task);
  tasks.push(task);
  saveTasks();

  playSound('add');
}

function assignOrganism(task) {
  const types = ['fern', 'mushroom', 'moss', 'snail', 'cricket', 'flower'];
  const hash = hashString(task.text);
  const type = types[hash % types.length];

  const colors = {
    fern: ['#4a7c59', '#5d9e6c', '#3f6b4a'],
    mushroom: ['#8b6f47', '#e8d5c4', '#c44e52'],
    moss: ['#6b8e4e', '#7ea65d', '#567a3c'],
    snail: ['#9d8b7c', '#b5a495', '#7d6b5c'],
    cricket: ['#4a5c3e', '#5a6c4e', '#3a4c2e'],
    flower: ['#d97c8e', '#e8b84e', '#9d7cc4', '#6ea8d9']
  };

  const colorOptions = colors[type];
  const color = colorOptions[hash % colorOptions.length];

  // Random position within jar
  const margin = 0.15;
  const x = jarBounds.leftX + jarBounds.width * (margin + Math.random() * (1 - 2 * margin));
  const soilTop = jarBounds.bottomY - jarBounds.height * 0.3;
  const availableHeight = jarBounds.height * 0.4;
  const y = soilTop - Math.random() * availableHeight;

  task.organism = {
    type,
    color,
    x,
    y,
    phase: Math.random() * Math.PI * 2,
    scale: 1,
    health: 1,
    bloomTime: 0
  };
}

function completeTask(task) {
  if (!task.completed) {
    task.completed = true;
    task.completedAt = Date.now();
    task.organism.bloomTime = Date.now();
    saveTasks();
    playSound('bloom');
  }
}

function deleteTask(task) {
  const index = tasks.indexOf(task);
  if (index !== -1) {
    tasks.splice(index, 1);
    saveTasks();
    playSound('delete');
  }
  if (selectedTask === task) {
    selectedTask = null;
    hideSelectedInfo();
  }
}

function hashString(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}

function updateStats() {
  const count = tasks.length;
  const thriving = tasks.filter(t => !t.completed && getTaskHealth(t) > 0.7).length;

  const countEl = document.getElementById('organism-count');
  if (count === 0) {
    countEl.textContent = 'No organisms yet';
  } else if (count === 1) {
    countEl.textContent = '1 organism ' + (thriving > 0 ? 'thriving' : 'present');
  } else {
    countEl.textContent = `${count} organisms, ${thriving} thriving`;
  }

  const ageEl = document.getElementById('ecosystem-age');
  if (ecosystemStartTime) {
    const days = Math.floor((Date.now() - ecosystemStartTime) / (1000 * 60 * 60 * 24));
    const hours = Math.floor((Date.now() - ecosystemStartTime) / (1000 * 60 * 60)) % 24;

    if (days === 0 && hours === 0) {
      ageEl.textContent = 'Ecosystem just beginning';
    } else if (days === 0) {
      ageEl.textContent = `Ecosystem age: ${hours}h`;
    } else if (days === 1) {
      ageEl.textContent = `Ecosystem age: 1 day`;
    } else {
      ageEl.textContent = `Ecosystem age: ${days} days`;
    }
  } else {
    ageEl.textContent = 'Ecosystem waiting to begin';
  }
}

function getTaskHealth(task) {
  if (task.completed) return 1;

  const age = Date.now() - task.created;
  const day = 1000 * 60 * 60 * 24;

  if (age < day) return 1;
  if (age < day * 3) return 1 - (age - day) / (day * 2) * 0.5;
  return 0.5 - Math.min(0.4, (age - day * 3) / (day * 7) * 0.4);
}

// Input
function showInput() {
  isInputVisible = true;
  const container = document.getElementById('input-container');
  container.classList.add('visible');
  document.getElementById('task-input').focus();
}

function hideInput() {
  isInputVisible = false;
  document.getElementById('input-container').classList.remove('visible');
}

function showSelectedInfo(task, x, y) {
  const info = document.getElementById('selected-info');
  info.textContent = task.text;
  info.style.left = x + 'px';
  info.style.top = y + 'px';
  info.classList.add('visible');
}

function hideSelectedInfo() {
  document.getElementById('selected-info').classList.remove('visible');
}

// Interaction
function handleClick(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Check if clicking an organism
  let clicked = null;
  for (let task of tasks) {
    const org = task.organism;
    const dist = Math.sqrt((x - org.x) ** 2 + (y - org.y) ** 2);
    if (dist < 20) {
      clicked = task;
      break;
    }
  }

  if (clicked) {
    selectedTask = clicked;
    showSelectedInfo(clicked, e.clientX, e.clientY - 40);
    return;
  }

  selectedTask = null;
  hideSelectedInfo();

  // Check if clicking jar edge (glass tap)
  if (isPointInJar(x, y) && !isPointInJarInterior(x, y)) {
    tapGlass();
    return;
  }

  // Check if clicking inside jar
  if (isPointInJarInterior(x, y) && !isInputVisible) {
    showInput();
  }
}

function handleDoubleClick(e) {
  e.preventDefault();
  if (selectedTask) {
    completeTask(selectedTask);
  }
}

function handleRightClick(e) {
  e.preventDefault();
  if (selectedTask) {
    deleteTask(selectedTask);
  }
}

function isPointInJar(x, y) {
  // Cylindrical jar shape
  const dx = x - jarBounds.x;
  const dy = y - jarBounds.y;
  const radius = jarBounds.width / 2;

  return Math.abs(dx) < radius &&
         y > jarBounds.topY &&
         y < jarBounds.bottomY;
}

function isPointInJarInterior(x, y) {
  const glassThickness = 8;
  const dx = x - jarBounds.x;
  const dy = y - jarBounds.y;
  const radius = jarBounds.width / 2 - glassThickness;

  return Math.abs(dx) < radius &&
         y > jarBounds.topY + glassThickness &&
         y < jarBounds.bottomY - glassThickness;
}

function tapGlass() {
  initAudio();
  playSound('tap');

  // Make droplets jiggle
  waterDroplets.forEach(drop => {
    drop.vx = (Math.random() - 0.5) * 2;
    drop.vy = Math.random() * -1;
  });
}

// Rendering
function loop() {
  requestAnimationFrame(loop);
  animationFrame++;

  const now = Date.now();
  const delta = now - lastUpdateTime;
  lastUpdateTime = now;

  update(delta);
  render();
}

function update(delta) {
  // Update organism health
  tasks.forEach(task => {
    task.organism.health = getTaskHealth(task);
  });

  // Update water droplets
  updateWaterDroplets(delta);

  // Maybe spawn new droplet
  if (Math.random() < 0.01 && waterDroplets.length < 15) {
    spawnWaterDroplet();
  }
}

function updateWaterDroplets(delta) {
  for (let i = waterDroplets.length - 1; i >= 0; i--) {
    const drop = waterDroplets[i];

    drop.x += drop.vx * delta / 16;
    drop.y += drop.vy * delta / 16;
    drop.vy += 0.02;
    drop.vx *= 0.98;

    // Remove if off jar
    if (drop.y > jarBounds.bottomY || drop.x < jarBounds.leftX || drop.x > jarBounds.rightX) {
      waterDroplets.splice(i, 1);
    }
  }
}

function spawnWaterDroplet() {
  const x = jarBounds.leftX + Math.random() * jarBounds.width;
  const y = jarBounds.topY + 20 + Math.random() * jarBounds.height * 0.3;

  waterDroplets.push({
    x,
    y,
    vx: 0,
    vy: 0.1,
    size: 2 + Math.random() * 3
  });
}

function render() {
  // Clear
  ctx.fillStyle = '#1a1610';
  ctx.fillRect(0, 0, width, height);

  // Lighting (time-based)
  const hour = new Date().getHours();
  let ambientLight;
  if (hour >= 6 && hour < 8) {
    ambientLight = { r: 255, g: 200, b: 150, a: 0.3 }; // sunrise
  } else if (hour >= 8 && hour < 18) {
    ambientLight = { r: 255, g: 240, b: 220, a: 0.4 }; // day
  } else if (hour >= 18 && hour < 20) {
    ambientLight = { r: 255, g: 180, b: 120, a: 0.3 }; // sunset
  } else {
    ambientLight = { r: 150, g: 180, b: 220, a: 0.2 }; // night
  }

  // Draw shelf
  drawShelf();

  // Draw jar
  drawJarBack(ambientLight);

  // Draw jar contents
  drawJarContents(ambientLight);

  // Draw jar front
  drawJarFront(ambientLight);
}

function drawShelf() {
  const shelfY = jarBounds.bottomY + 10;
  const shelfHeight = 30;

  // Wood grain
  ctx.fillStyle = '#3a2f1f';
  ctx.fillRect(0, shelfY, width, shelfHeight);

  ctx.fillStyle = '#2a1f0f';
  for (let i = 0; i < 5; i++) {
    const x = Math.random() * width;
    const w = 40 + Math.random() * 100;
    ctx.fillRect(x, shelfY, w, shelfHeight);
  }

  // Shadow
  const grad = ctx.createLinearGradient(0, shelfY, 0, shelfY + shelfHeight);
  grad.addColorStop(0, 'rgba(0,0,0,0.4)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, shelfY, width, shelfHeight);
}

function drawJarBack(light) {
  const x = jarBounds.x;
  const y = jarBounds.y;
  const w = jarBounds.width;
  const h = jarBounds.height;

  // Back glass
  ctx.fillStyle = `rgba(200, 220, 215, 0.1)`;
  ctx.beginPath();
  ctx.ellipse(x, y - h/2 + 20, w/2 - 5, 15, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = `rgba(200, 220, 215, 0.08)`;
  ctx.fillRect(x - w/2 + 5, y - h/2 + 20, w - 10, h - 20);
}

function drawJarContents(light) {
  const x = jarBounds.x;
  const bottomY = jarBounds.bottomY;
  const w = jarBounds.width;
  const h = jarBounds.height;

  ctx.save();
  ctx.beginPath();
  ctx.rect(x - w/2 + 8, jarBounds.topY + 8, w - 16, h - 16);
  ctx.clip();

  // Gravel layer
  const gravelTop = bottomY - h * 0.1;
  ctx.fillStyle = '#4a3d30';
  ctx.fillRect(x - w/2 + 8, gravelTop, w - 16, h * 0.1);

  for (let i = 0; i < 30; i++) {
    const px = x - w/2 + 8 + Math.random() * (w - 16);
    const py = gravelTop + Math.random() * h * 0.1;
    ctx.fillStyle = ['#6a5d50', '#5a4d40', '#7a6d60'][Math.floor(Math.random() * 3)];
    ctx.beginPath();
    ctx.arc(px, py, 2 + Math.random() * 3, 0, Math.PI * 2);
    ctx.fill();
  }

  // Charcoal layer
  const charcoalTop = gravelTop - h * 0.03;
  ctx.fillStyle = '#2a2420';
  ctx.fillRect(x - w/2 + 8, charcoalTop, w - 16, h * 0.03);

  // Soil layer
  const soilTop = charcoalTop - h * 0.17;
  const soilGrad = ctx.createLinearGradient(0, soilTop, 0, charcoalTop);
  soilGrad.addColorStop(0, '#5a4a3a');
  soilGrad.addColorStop(1, '#4a3a2a');
  ctx.fillStyle = soilGrad;
  ctx.fillRect(x - w/2 + 8, soilTop, w - 16, h * 0.17);

  // Soil texture
  for (let i = 0; i < 40; i++) {
    const px = x - w/2 + 8 + Math.random() * (w - 16);
    const py = soilTop + Math.random() * h * 0.17;
    ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.3})`;
    ctx.beginPath();
    ctx.arc(px, py, 1, 0, Math.PI * 2);
    ctx.fill();
  }

  // Moisture vapor
  ctx.fillStyle = `rgba(200, 220, 230, ${0.02 + Math.sin(animationFrame * 0.02) * 0.01})`;
  for (let i = 0; i < 3; i++) {
    const vy = soilTop - i * 30 - animationFrame * 0.1 % 100;
    ctx.fillRect(x - w/2 + 8, vy, w - 16, 30);
  }

  // Organisms
  tasks.forEach(task => {
    drawOrganism(task, light);
  });

  ctx.restore();
}

function drawOrganism(task, light) {
  const org = task.organism;
  const sway = Math.sin(animationFrame * 0.02 + org.phase) * 2;

  ctx.save();
  ctx.translate(org.x + sway * 0.3, org.y);

  const healthColor = interpolateHealth(org.health);

  // Bloom glow
  if (task.completed && task.completedAt) {
    const bloomAge = Date.now() - task.completedAt;
    if (bloomAge < 3000) {
      const glowAlpha = 1 - bloomAge / 3000;
      const glowSize = 20 + (bloomAge / 3000) * 20;
      const glowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
      glowGrad.addColorStop(0, `rgba(255, 220, 150, ${glowAlpha * 0.4})`);
      glowGrad.addColorStop(1, 'rgba(255, 220, 150, 0)');
      ctx.fillStyle = glowGrad;
      ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
    }
  }

  ctx.scale(org.scale, org.scale);

  switch (org.type) {
    case 'fern':
      drawFern(org, healthColor, sway);
      break;
    case 'mushroom':
      drawMushroom(org, healthColor);
      break;
    case 'moss':
      drawMoss(org, healthColor);
      break;
    case 'snail':
      drawSnail(org, healthColor, animationFrame);
      break;
    case 'cricket':
      drawCricket(org, healthColor, animationFrame);
      break;
    case 'flower':
      drawFlower(org, healthColor, sway, task.completed);
      break;
  }

  ctx.restore();
}

function drawFern(org, color, sway) {
  const frondCount = 3;

  for (let f = 0; f < frondCount; f++) {
    const angle = (f / frondCount) * Math.PI * 0.5 - Math.PI * 0.25;
    const length = 15 + f * 5;

    ctx.save();
    ctx.rotate(angle + sway * 0.02);

    // Stem
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -length);
    ctx.stroke();

    // Leaflets
    for (let i = 1; i < 8; i++) {
      const y = -i * (length / 8);
      const leafSize = 3 + Math.sin(i * 0.5) * 2;

      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(-leafSize, y, leafSize, leafSize * 0.6, -Math.PI * 0.3, 0, Math.PI * 2);
      ctx.fill();

      ctx.beginPath();
      ctx.ellipse(leafSize, y, leafSize, leafSize * 0.6, Math.PI * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }
}

function drawMushroom(org, color) {
  // Stalk
  ctx.fillStyle = interpolateColor('#d4c5a0', color, 0.5);
  ctx.fillRect(-1.5, -8, 3, 8);

  // Cap
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(0, -10, 6, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Spots if red
  if (org.color.includes('c44e52')) {
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.beginPath();
    ctx.arc(-2, -11, 1.5, 0, Math.PI * 2);
    ctx.arc(2, -10, 1, 0, Math.PI * 2);
    ctx.arc(0, -9, 1.2, 0, Math.PI * 2);
    ctx.fill();
  }

  // Spores if completed
  if (org.bloomTime && Date.now() - org.bloomTime < 2000) {
    const age = Date.now() - org.bloomTime;
    ctx.fillStyle = `rgba(200, 200, 150, ${1 - age / 2000})`;
    for (let i = 0; i < 5; i++) {
      const sx = (Math.random() - 0.5) * 8;
      const sy = -10 - (age / 2000) * 20;
      ctx.beginPath();
      ctx.arc(sx, sy, 0.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

function drawMoss(org, color) {
  // Spreading carpet
  for (let i = 0; i < 12; i++) {
    const x = (i - 6) * 2;
    const y = Math.sin(i * 0.5) * 1;
    const size = 2 + Math.random() * 1.5;

    ctx.fillStyle = color;
    ctx.globalAlpha = 0.7 + Math.random() * 0.3;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawSnail(org, color, frame) {
  const movePhase = (frame * 0.005 + org.phase) % (Math.PI * 2);
  const bodyExtend = Math.sin(movePhase) * 1.5;

  // Shell
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(0, -3, 3.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.arc(0, -3, 2, 0, Math.PI * 2);
  ctx.stroke();

  // Body
  ctx.fillStyle = interpolateColor(color, '#d4c5a0', 0.4);
  ctx.fillRect(-1 - bodyExtend, -1, 2 + bodyExtend, 1.5);

  // Eyestalks
  ctx.strokeStyle = ctx.fillStyle;
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(-1 - bodyExtend, -1);
  ctx.lineTo(-2 - bodyExtend, -2);
  ctx.moveTo(-0.5 - bodyExtend, -1);
  ctx.lineTo(-1.5 - bodyExtend, -2.5);
  ctx.stroke();
}

function drawCricket(org, color, frame) {
  const hopPhase = (frame * 0.05 + org.phase) % (Math.PI * 2);
  const hop = hopPhase < 0.3 ? Math.sin(hopPhase / 0.3 * Math.PI) * -3 : 0;

  ctx.save();
  ctx.translate(0, hop);

  // Body
  ctx.fillStyle = color;
  ctx.fillRect(-2, -1, 4, 2);

  // Head
  ctx.beginPath();
  ctx.arc(-2, 0, 1.5, 0, Math.PI * 2);
  ctx.fill();

  // Legs
  ctx.strokeStyle = color;
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(-1, 1);
  ctx.lineTo(-2, 3);
  ctx.moveTo(1, 1);
  ctx.lineTo(2, 3);

  // Back legs
  ctx.moveTo(2, 0);
  ctx.lineTo(4, -1);
  ctx.lineTo(5, 1);
  ctx.stroke();

  // Antennae
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(-2, -1);
  ctx.lineTo(-3, -3);
  ctx.moveTo(-2, -1);
  ctx.lineTo(-1.5, -3);
  ctx.stroke();

  ctx.restore();
}

function drawFlower(org, color, sway, completed) {
  // Stem
  ctx.strokeStyle = '#5d9e6c';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(sway, -8, sway * 0.5, -15);
  ctx.stroke();

  ctx.save();
  ctx.translate(sway * 0.5, -15);

  // Petals
  const petalCount = completed ? 6 : 5;
  const petalSize = completed ? 4 : 3;

  for (let i = 0; i < petalCount; i++) {
    const angle = (i / petalCount) * Math.PI * 2;
    ctx.save();
    ctx.rotate(angle);

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(0, -petalSize, petalSize * 0.6, petalSize, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // Center
  ctx.fillStyle = '#f4e4a0';
  ctx.beginPath();
  ctx.arc(0, 0, 2, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawJarFront(light) {
  const x = jarBounds.x;
  const y = jarBounds.y;
  const w = jarBounds.width;
  const h = jarBounds.height;

  // Glass front with tint
  ctx.strokeStyle = 'rgba(180, 200, 210, 0.3)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x - w/2 + 5, y - h/2 + 20);
  ctx.lineTo(x - w/2 + 5, y + h/2 - 5);
  ctx.moveTo(x + w/2 - 5, y - h/2 + 20);
  ctx.lineTo(x + w/2 - 5, y + h/2 - 5);
  ctx.stroke();

  // Bottom curve
  ctx.beginPath();
  ctx.ellipse(x, y + h/2 - 5, w/2 - 5, 10, 0, 0, Math.PI);
  ctx.stroke();

  // Specular highlight
  const highlightGrad = ctx.createLinearGradient(x - w/2, y, x - w/2 + 30, y);
  highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
  highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
  ctx.fillStyle = highlightGrad;
  ctx.fillRect(x - w/2 + 5, y - h/2 + 20, 25, h - 30);

  // Condensation droplets
  waterDroplets.forEach(drop => {
    ctx.fillStyle = 'rgba(200, 220, 230, 0.4)';
    ctx.beginPath();
    ctx.arc(drop.x, drop.y, drop.size, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.beginPath();
    ctx.arc(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.3, 0, Math.PI * 2);
    ctx.fill();
  });

  // Metal lid
  const lidHeight = 12;
  const lidTop = y - h/2;

  ctx.fillStyle = '#5a5a5a';
  ctx.fillRect(x - w/2 - 5, lidTop, w + 10, lidHeight);

  // Lid texture
  ctx.strokeStyle = '#4a4a4a';
  ctx.lineWidth = 1;
  for (let i = 0; i < 20; i++) {
    const lx = x - w/2 - 5 + (i / 20) * (w + 10);
    ctx.beginPath();
    ctx.moveTo(lx, lidTop);
    ctx.lineTo(lx, lidTop + lidHeight);
    ctx.stroke();
  }

  ctx.fillStyle = '#6a6a6a';
  ctx.fillRect(x - w/2 - 5, lidTop, w + 10, 2);

  // Lid band
  ctx.strokeStyle = '#7a7a7a';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x - w/2 - 3, lidTop + lidHeight);
  ctx.lineTo(x + w/2 + 3, lidTop + lidHeight);
  ctx.stroke();
}

function interpolateHealth(health) {
  const healthy = { r: 90, g: 140, b: 90 };
  const wilted = { r: 160, g: 140, b: 80 };

  const r = Math.floor(wilted.r + (healthy.r - wilted.r) * health);
  const g = Math.floor(wilted.g + (healthy.g - wilted.g) * health);
  const b = Math.floor(wilted.b + (healthy.b - wilted.b) * health);

  return `rgb(${r}, ${g}, ${b})`;
}

function interpolateColor(c1, c2, t) {
  const hex1 = c1.replace('#', '');
  const hex2 = c2.replace('#', '');

  const r1 = parseInt(hex1.slice(0, 2), 16);
  const g1 = parseInt(hex1.slice(2, 4), 16);
  const b1 = parseInt(hex1.slice(4, 6), 16);

  const r2 = parseInt(hex2.slice(0, 2), 16);
  const g2 = parseInt(hex2.slice(2, 4), 16);
  const b2 = parseInt(hex2.slice(4, 6), 16);

  const r = Math.floor(r1 + (r2 - r1) * t);
  const g = Math.floor(g1 + (g2 - g1) * t);
  const b = Math.floor(b1 + (b2 - b1) * t);

  return `rgb(${r}, ${g}, ${b})`;
}

// Audio
function initAudio() {
  if (!audioInitialized) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    audioInitialized = true;
  }
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
}

function playSound(type) {
  if (!audioContext) return;

  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.connect(gain);
  gain.connect(audioContext.destination);

  const now = audioContext.currentTime;

  switch (type) {
    case 'tap':
      osc.frequency.setValueAtTime(120, now);
      osc.frequency.exponentialRampToValueAtTime(60, now + 0.1);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
      break;

    case 'bloom':
      osc.frequency.setValueAtTime(400, now);
      osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);
      gain.gain.setValueAtTime(0.05, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
      osc.start(now);
      osc.stop(now + 0.4);
      break;

    case 'add':
      osc.frequency.setValueAtTime(300, now);
      gain.gain.setValueAtTime(0.03, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      osc.start(now);
      osc.stop(now + 0.1);
      break;

    case 'delete':
      osc.frequency.setValueAtTime(200, now);
      osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
      gain.gain.setValueAtTime(0.05, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
      break;
  }
}

// Start
init();
</script>

</body>
</html>