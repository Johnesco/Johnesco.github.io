<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>todooo 033 - handwritten notebook</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Segoe Script', 'Comic Sans MS', cursive, sans-serif;
  background: #2a2a2a;
  overflow: hidden;
  user-select: none;
}
#canvas {
  display: block;
  cursor: crosshair;
  box-shadow: 0 8px 40px rgba(0,0,0,0.6);
}
#input {
  position: absolute;
  border: none;
  background: transparent;
  outline: none;
  font-family: inherit;
  font-size: 16px;
  color: transparent;
  caret-color: #333;
  z-index: 10;
  pointer-events: none;
}
#speaker {
  position: absolute;
  top: 20px;
  right: 20px;
  font-size: 24px;
  cursor: pointer;
  z-index: 20;
  user-select: none;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<input id="input" type="text" autocomplete="off" />
<div id="speaker">ðŸ”Š</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const input = document.getElementById('input');
const speaker = document.getElementById('speaker');

// Setup
const W = canvas.width = 800;
const H = canvas.height = 1000;
const LINE_HEIGHT = 32;
const MARGIN_LEFT = 80;
const MARGIN_TOP = 100;
const PAPER_BG = '#f5f0e8';
const LINE_COLOR = '#c8d8e8';
const MARGIN_COLOR = '#e8a0a0';
const TEXT_COLOR = '#333';
const HIGHLIGHT_COLOR = 'rgba(255,255,150,0.3)';

let soundEnabled = true;
let tasks = [];
let doodles = [];
let userDrawings = [];
let activeLine = -1;
let hoveredLine = -1;
let drawMode = false;
let eraserMode = false;
let currentPath = [];
let cursorBlink = true;
let doodleCount = 0;

// Load from localStorage
function load() {
  const data = localStorage.getItem('todooo-033');
  if (data) {
    const parsed = JSON.parse(data);
    tasks = parsed.tasks || [];
    doodles = parsed.doodles || [];
    userDrawings = parsed.userDrawings || [];
    doodleCount = parsed.doodleCount || 0;
  }
}

function save() {
  localStorage.setItem('todooo-033', JSON.stringify({
    tasks, doodles, userDrawings, doodleCount
  }));
}

// Random helpers
const rand = (min, max) => Math.random() * (max - min) + min;
const randInt = (min, max) => Math.floor(rand(min, max));

// Sketchy line drawing
function sketchyLine(x1, y1, x2, y2, layers = 2) {
  for (let l = 0; l < layers; l++) {
    ctx.beginPath();
    const segments = Math.max(5, Math.floor(Math.hypot(x2 - x1, y2 - y1) / 10));
    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const x = x1 + (x2 - x1) * t + rand(-0.3, 0.3);
      const y = y1 + (y2 - y1) * t + rand(-0.3, 0.3);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.lineWidth = rand(0.8, 1.2);
    ctx.stroke();
  }
}

// Wobbly line (for paper lines)
function wobblyLine(x1, y1, x2, y2, amplitude = 0.5) {
  ctx.beginPath();
  const segments = 50;
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    const x = x1 + (x2 - x1) * t;
    const wave = Math.sin(t * Math.PI * 4) * amplitude;
    const y = y1 + wave + rand(-0.2, 0.2);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.lineWidth = 0.8;
  ctx.stroke();
}

// Sketchy rect
function sketchyRect(x, y, w, h) {
  const overshoot = 2;
  sketchyLine(x, y, x + w + overshoot, y);
  sketchyLine(x + w, y, x + w, y + h + overshoot);
  sketchyLine(x + w, y + h, x - overshoot, y + h);
  sketchyLine(x, y + h, x, y - overshoot);
}

// Sketchy checkmark
function sketchyCheck(x, y, size) {
  const x1 = x, y1 = y + size / 2;
  const x2 = x + size / 3, y2 = y + size;
  const x3 = x + size, y3 = y;
  sketchyLine(x1, y1, x2, y2, 2);
  sketchyLine(x2, y2, x3, y3, 2);
}

// Handwritten text
function handwriteText(text, x, y, size = 16) {
  ctx.font = `${size}px 'Segoe Script', 'Comic Sans MS', cursive`;
  ctx.fillStyle = TEXT_COLOR;
  let offsetX = 0;
  for (let i = 0; i < text.length; i++) {
    ctx.save();
    const charX = x + offsetX;
    const charY = y + rand(-1, 1) + Math.sin(offsetX / 20) * 0.5;
    ctx.translate(charX, charY);
    ctx.rotate(rand(-0.03, 0.03));
    ctx.fillText(text[i], 0, 0);
    ctx.restore();
    offsetX += ctx.measureText(text[i]).width + rand(-0.5, 0.8);
  }
}

// Draw paper texture
function drawPaper() {
  // Background
  ctx.fillStyle = PAPER_BG;
  ctx.fillRect(0, 0, W, H);

  // Vignette
  const grad = ctx.createRadialGradient(W/2, H/2, 200, W/2, H/2, 700);
  grad.addColorStop(0, 'rgba(0,0,0,0)');
  grad.addColorStop(1, 'rgba(0,0,0,0.1)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Paper texture noise
  for (let i = 0; i < 800; i++) {
    ctx.fillStyle = `rgba(0,0,0,${rand(0.01, 0.03)})`;
    ctx.fillRect(rand(0, W), rand(0, H), 1, 1);
  }

  // Coffee stain
  ctx.strokeStyle = 'rgba(139,90,43,0.03)';
  ctx.lineWidth = 20;
  ctx.beginPath();
  ctx.arc(W - 120, 80, 40, 0, Math.PI * 2);
  ctx.stroke();

  // Ruled lines
  ctx.strokeStyle = LINE_COLOR;
  for (let i = 0; i < 30; i++) {
    const y = MARGIN_TOP + i * LINE_HEIGHT;
    wobblyLine(0, y, W, y);
  }

  // Margin line
  ctx.strokeStyle = MARGIN_COLOR;
  wobblyLine(MARGIN_LEFT, 0, MARGIN_LEFT, H, 1);

  // Title
  ctx.fillStyle = TEXT_COLOR;
  handwriteText('things to do', W/2 - 80, 50, 24);
  sketchyLine(W/2 - 100, 58, W/2 + 100, 58);
  sketchyLine(W/2 - 102, 61, W/2 + 98, 61);

  // Date
  const date = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  handwriteText(date, W - 180, 30, 12);

  // Page number
  handwriteText('pg. 1', W - 60, H - 20, 12);

  // Task count
  const completed = tasks.filter(t => t.done).length;
  handwriteText(`${completed} of ${tasks.length} done`, 20, H - 20, 12);
}

// Draw task
function drawTask(task, lineNum) {
  const y = MARGIN_TOP + lineNum * LINE_HEIGHT;
  const checkX = MARGIN_LEFT - 50;
  const checkY = y - 14;
  const textX = MARGIN_LEFT + 10;
  const textY = y;

  // Hover highlight
  if (hoveredLine === lineNum && !task.done) {
    ctx.fillStyle = HIGHLIGHT_COLOR;
    ctx.fillRect(MARGIN_LEFT, y - 20, W - MARGIN_LEFT - 20, LINE_HEIGHT);
  }

  // Checkbox
  ctx.strokeStyle = TEXT_COLOR;
  sketchyRect(checkX, checkY, 16, 16);

  // Checkmark if done
  if (task.done) {
    sketchyCheck(checkX + 2, checkY + 2, 12);
  }

  // Text
  ctx.fillStyle = task.done ? '#999' : TEXT_COLOR;
  handwriteText(task.text, textX, textY);

  // Strikethrough if done
  if (task.done) {
    ctx.strokeStyle = TEXT_COLOR;
    ctx.lineWidth = 1.5;
    const textWidth = ctx.measureText(task.text).width * 1.2;
    const strikeY = y - 8;
    ctx.beginPath();
    const segments = 20;
    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const x = textX + textWidth * t;
      const yOff = Math.sin(t * Math.PI * 3) * 1.5;
      if (i === 0) ctx.moveTo(x, strikeY + yOff);
      else ctx.lineTo(x, strikeY + yOff);
    }
    ctx.stroke();
  }

  // Scribble if deleted
  if (task.deleted) {
    ctx.strokeStyle = `rgba(51,51,51,${task.deleteFade || 0.3})`;
    ctx.lineWidth = 2;
    for (let i = 0; i < 6; i++) {
      const angle = rand(0, Math.PI);
      const len = rand(80, 150);
      const startX = textX + rand(-10, 10);
      const startY = y - 10 + rand(-5, 5);
      sketchyLine(startX, startY, startX + Math.cos(angle) * len, startY + Math.sin(angle) * len, 1);
    }
  }
}

// Draw doodle
function drawDoodle(doodle) {
  ctx.strokeStyle = TEXT_COLOR;
  ctx.lineWidth = 1;
  ctx.fillStyle = TEXT_COLOR;

  const {type, x, y, size} = doodle;

  switch(type) {
    case 'star':
      ctx.beginPath();
      for (let i = 0; i < 10; i++) {
        const angle = (i * Math.PI * 2 / 10) - Math.PI / 2;
        const r = i % 2 === 0 ? size : size / 2;
        const px = x + Math.cos(angle) * r;
        const py = y + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
      break;

    case 'spiral':
      ctx.beginPath();
      for (let i = 0; i < 50; i++) {
        const angle = i * 0.3;
        const r = i * 0.3;
        const px = x + Math.cos(angle) * r;
        const py = y + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
      break;

    case 'flower':
      ctx.beginPath();
      ctx.arc(x, y, size/4, 0, Math.PI * 2);
      ctx.stroke();
      for (let i = 0; i < 6; i++) {
        const angle = i * Math.PI * 2 / 6;
        ctx.beginPath();
        ctx.arc(x + Math.cos(angle) * size/2, y + Math.sin(angle) * size/2, size/4, 0, Math.PI * 2);
        ctx.stroke();
      }
      break;

    case 'arrow':
      sketchyLine(x, y, x + size, y - size/2);
      sketchyLine(x + size, y - size/2, x + size - 8, y - size/2 - 5);
      sketchyLine(x + size, y - size/2, x + size - 8, y - size/2 + 5);
      break;

    case 'heart':
      ctx.beginPath();
      ctx.moveTo(x, y + size/4);
      ctx.bezierCurveTo(x, y, x - size/2, y - size/2, x - size/2, y);
      ctx.bezierCurveTo(x - size/2, y + size/4, x, y + size/2, x, y + size);
      ctx.bezierCurveTo(x, y + size/2, x + size/2, y + size/4, x + size/2, y);
      ctx.bezierCurveTo(x + size/2, y - size/2, x, y, x, y + size/4);
      ctx.stroke();
      break;

    case 'face':
      ctx.beginPath();
      ctx.arc(x, y, size/2, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillRect(x - size/5, y - size/6, 2, 2);
      ctx.fillRect(x + size/5 - 2, y - size/6, 2, 2);
      ctx.beginPath();
      ctx.arc(x, y, size/4, 0.2, Math.PI - 0.2);
      ctx.stroke();
      break;

    case 'lightning':
      sketchyLine(x, y, x + size/4, y + size/2, 1);
      sketchyLine(x + size/4, y + size/2, x - size/4, y + size/2, 1);
      sketchyLine(x - size/4, y + size/2, x, y + size, 1);
      break;

    default:
      ctx.beginPath();
      ctx.arc(x, y, size/2, 0, Math.PI * 2);
      ctx.stroke();
  }
}

// Draw user drawings
function drawUserDrawings() {
  ctx.strokeStyle = TEXT_COLOR;
  ctx.lineWidth = 1.2;
  userDrawings.forEach(path => {
    if (path.length < 2) return;
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) {
      ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.stroke();
  });
}

// Draw cursor
function drawCursor() {
  if (activeLine >= 0 && cursorBlink) {
    const y = MARGIN_TOP + activeLine * LINE_HEIGHT;
    const x = MARGIN_LEFT + 10 + ctx.measureText(input.value).width * 1.1;
    ctx.fillStyle = TEXT_COLOR;
    ctx.fillRect(x, y - 18, 1.5, 20);
  }
}

// Main render
function render() {
  ctx.clearRect(0, 0, W, H);
  drawPaper();

  // Draw tasks
  tasks.forEach((task, i) => {
    if (!task.deleted || task.deleteFade > 0.1) {
      drawTask(task, task.line);
    }
  });

  // Draw doodles
  doodles.forEach(drawDoodle);

  // Draw user drawings
  drawUserDrawings();

  // Draw current path
  if (currentPath.length > 0) {
    ctx.strokeStyle = TEXT_COLOR;
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    for (let i = 1; i < currentPath.length; i++) {
      ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
  }

  // Draw cursor
  drawCursor();
}

// Get line number from y coordinate
function getLineNum(y) {
  const lineNum = Math.floor((y - MARGIN_TOP + LINE_HEIGHT/2) / LINE_HEIGHT);
  return lineNum >= 0 && lineNum < 28 ? lineNum : -1;
}

// Find task on line
function findTaskOnLine(lineNum) {
  return tasks.findIndex(t => t.line === lineNum && !t.deleted);
}

// Add doodle
function addDoodle() {
  const types = ['star', 'spiral', 'flower', 'arrow', 'heart', 'face', 'lightning'];
  const type = types[randInt(0, types.length)];
  const isLeft = Math.random() > 0.5;
  const x = isLeft ? rand(10, MARGIN_LEFT - 30) : rand(W - 80, W - 20);
  const y = rand(MARGIN_TOP + 50, H - 100);
  const size = rand(12, 24);
  doodles.push({type, x, y, size});
  if (doodles.length > 20) doodles.shift();
  save();
}

// Play sound
let _audioCtx;
function getAudioCtx() { if (!_audioCtx) _audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (_audioCtx.state === 'suspended') _audioCtx.resume(); return _audioCtx; }
function playSound(type) {
  if (!soundEnabled) return;
  const audioCtx = getAudioCtx();
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();

  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  switch(type) {
    case 'write':
      oscillator.frequency.value = 100 + Math.random() * 50;
      gainNode.gain.value = 0.02;
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.02);
      break;
    case 'check':
      oscillator.frequency.value = 300;
      gainNode.gain.value = 0.05;
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.05);
      break;
    case 'delete':
      oscillator.frequency.value = 80;
      gainNode.gain.value = 0.08;
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.1);
      break;
  }
}

// Event handlers
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  if (drawMode) {
    currentPath.push({x, y});
    render();
    return;
  }

  const lineNum = getLineNum(y);
  hoveredLine = lineNum;

  // Check if hovering over checkbox
  if (x >= MARGIN_LEFT - 55 && x <= MARGIN_LEFT - 35 && lineNum >= 0) {
    canvas.style.cursor = 'pointer';
  } else if (lineNum >= 0 && x > MARGIN_LEFT) {
    canvas.style.cursor = 'text';
  } else {
    canvas.style.cursor = 'crosshair';
  }

  render();
});

canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const lineNum = getLineNum(y);

  // Eraser mode
  if (eraserMode) {
    // Remove doodles near click
    doodles = doodles.filter(d => Math.hypot(d.x - x, d.y - y) > 30);
    // Remove user drawings near click
    userDrawings = userDrawings.filter(path => {
      return !path.some(p => Math.hypot(p.x - x, p.y - y) < 20);
    });
    save();
    render();
    return;
  }

  // Drawing mode with Shift
  if (e.shiftKey) {
    drawMode = true;
    currentPath = [{x, y}];
    return;
  }

  if (lineNum < 0) return;

  // Check if clicking checkbox
  if (x >= MARGIN_LEFT - 55 && x <= MARGIN_LEFT - 35) {
    const taskIdx = findTaskOnLine(lineNum);
    if (taskIdx >= 0) {
      tasks[taskIdx].done = !tasks[taskIdx].done;
      playSound('check');
      save();
      render();
    }
    return;
  }

  // Click on line to add/edit task
  if (x > MARGIN_LEFT) {
    const taskIdx = findTaskOnLine(lineNum);
    if (taskIdx >= 0) {
      // Edit existing (on double click, handled separately)
      return;
    }

    // Start new task
    activeLine = lineNum;
    input.value = '';
    const inputY = MARGIN_TOP + lineNum * LINE_HEIGHT - 18;
    input.style.left = (MARGIN_LEFT + 10) + 'px';
    input.style.top = inputY + 'px';
    input.style.width = (W - MARGIN_LEFT - 40) + 'px';
    input.style.pointerEvents = 'auto';
    input.focus();
    render();
  }
});

canvas.addEventListener('mouseup', () => {
  if (drawMode && currentPath.length > 1) {
    userDrawings.push([...currentPath]);
    save();
  }
  drawMode = false;
  currentPath = [];
  render();
});

canvas.addEventListener('dblclick', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const lineNum = getLineNum(y);

  if (lineNum < 0 || x <= MARGIN_LEFT) return;

  const taskIdx = findTaskOnLine(lineNum);
  if (taskIdx >= 0) {
    activeLine = lineNum;
    input.value = tasks[taskIdx].text;
    tasks.splice(taskIdx, 1);
    const inputY = MARGIN_TOP + lineNum * LINE_HEIGHT - 18;
    input.style.left = (MARGIN_LEFT + 10) + 'px';
    input.style.top = inputY + 'px';
    input.style.width = (W - MARGIN_LEFT - 40) + 'px';
    input.style.pointerEvents = 'auto';
    input.focus();
    save();
    render();
  }
});

canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const lineNum = getLineNum(y);

  if (lineNum < 0) return;

  const taskIdx = findTaskOnLine(lineNum);
  if (taskIdx >= 0) {
    tasks[taskIdx].deleted = true;
    tasks[taskIdx].deleteFade = 1;
    playSound('delete');

    // Fade out animation
    const fadeInterval = setInterval(() => {
      tasks[taskIdx].deleteFade -= 0.05;
      if (tasks[taskIdx].deleteFade <= 0.3) {
        clearInterval(fadeInterval);
        save();
      }
      render();
    }, 50);

    save();
    render();
  }
});

input.addEventListener('input', (e) => {
  playSound('write');
  render();
});

input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && input.value.trim()) {
    const text = input.value.trim();
    tasks.push({
      text,
      line: activeLine,
      done: false,
      deleted: false
    });

    doodleCount++;
    if (doodleCount % 3 === 0) {
      addDoodle();
    }

    input.value = '';
    input.style.pointerEvents = 'none';
    activeLine = -1;
    save();
    render();
  } else if (e.key === 'Escape') {
    input.value = '';
    input.style.pointerEvents = 'none';
    activeLine = -1;
    render();
  }
});

input.addEventListener('blur', () => {
  if (input.value.trim() && activeLine >= 0) {
    const text = input.value.trim();
    tasks.push({
      text,
      line: activeLine,
      done: false,
      deleted: false
    });

    doodleCount++;
    if (doodleCount % 3 === 0) {
      addDoodle();
    }

    save();
  }
  input.value = '';
  input.style.pointerEvents = 'none';
  activeLine = -1;
  render();
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'e' || e.key === 'E') {
    eraserMode = !eraserMode;
    canvas.style.cursor = eraserMode ? 'not-allowed' : 'crosshair';
  } else if (e.key === 'n' || e.key === 'N') {
    if (confirm('Start a new page? Current page will be archived.')) {
      // Archive current page
      const archiveKey = `todooo-033-archive-${Date.now()}`;
      localStorage.setItem(archiveKey, JSON.stringify({tasks, doodles, userDrawings}));

      // Clear current
      tasks = [];
      doodles = [];
      userDrawings = [];
      doodleCount = 0;
      save();
      render();
    }
  } else if ((e.key === 'Delete' || e.key === 'Backspace') && activeLine < 0) {
    // Delete last task
    if (tasks.length > 0) {
      const lastTask = tasks[tasks.length - 1];
      if (!lastTask.deleted) {
        lastTask.deleted = true;
        lastTask.deleteFade = 1;
        playSound('delete');

        setTimeout(() => {
          save();
          render();
        }, 1000);

        render();
      }
    }
  }
});

speaker.addEventListener('click', () => {
  soundEnabled = !soundEnabled;
  speaker.textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
});

// Cursor blink
setInterval(() => {
  cursorBlink = !cursorBlink;
  if (activeLine >= 0) render();
}, 500);

// Initialize
load();
render();

// Animation loop for smooth rendering
function animate() {
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
