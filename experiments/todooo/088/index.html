<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Island - Part 2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a1a2a;
            font-family: 'Georgia', serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100vh;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 13px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #welcome {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            text-align: center;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
            pointer-events: none;
            transition: opacity 1s;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui"></div>
    <div id="welcome"></div>

    <script>
        'use strict';

        // ============================================================
        // CONFIG
        // ============================================================

        const CONFIG = {
            STORAGE_KEY: 'todooo-088',
            ISLAND_SIZE: 200,
            TILE_SIZE: 4,
            PLAYER_SPEED: 0.8,
            CAMERA_LERP: 0.08,
            ZOOM_MIN: 0.5,
            ZOOM_MAX: 3.0,
            ZOOM_DEFAULT: 1.0,
            ZOOM_STEP: 0.1,
            TIDE_CYCLE_MS: 6 * 60 * 1000, // 6 minutes
            TIDE_MIN: 0.35,
            TIDE_MAX: 0.40,
            WATER_THRESHOLD: 0.35,
            LAND_THRESHOLD: 0.40,
            STAR_COUNT: 120,
            NOISE_OCTAVES: 4,
            ISLAND_RADIUS: 0.42,
            MAX_RAINDROPS: 200,
            MAX_CLOUDS: 8
        };

        // ============================================================
        // UTILITY FUNCTIONS (noise, hash, lerp, color)
        // ============================================================

        // Simple hash function for seeded random
        function hashSeed(seed) {
            let h = seed;
            h = Math.imul(h ^ (h >>> 16), 0x85ebca6b);
            h = Math.imul(h ^ (h >>> 13), 0xc2b2ae35);
            return (h ^ (h >>> 16)) >>> 0;
        }

        class SeededRandom {
            constructor(seed) {
                this.seed = hashSeed(seed);
            }

            next() {
                this.seed = Math.imul(this.seed ^ (this.seed >>> 7), 0x85ebca6b);
                this.seed = Math.imul(this.seed ^ (this.seed >>> 9), 0xc2b2ae35);
                return ((this.seed ^ (this.seed >>> 16)) >>> 0) / 4294967296;
            }
        }

        // Simple 2D noise using permutation table
        class NoiseGenerator {
            constructor(seed) {
                this.perm = new Array(512);
                const rng = new SeededRandom(seed);
                const p = Array.from({length: 256}, (_, i) => i);

                // Fisher-Yates shuffle with seeded random
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(rng.next() * (i + 1));
                    [p[i], p[j]] = [p[j], p[i]];
                }

                for (let i = 0; i < 512; i++) {
                    this.perm[i] = p[i & 255];
                }
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;

                x -= Math.floor(x);
                y -= Math.floor(y);

                const u = this.fade(x);
                const v = this.fade(y);

                const a = this.perm[X] + Y;
                const aa = this.perm[a];
                const ab = this.perm[a + 1];
                const b = this.perm[X + 1] + Y;
                const ba = this.perm[b];
                const bb = this.perm[b + 1];

                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[aa], x, y), this.grad(this.perm[ba], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[ab], x, y - 1), this.grad(this.perm[bb], x - 1, y - 1))
                );
            }

            octaveNoise(x, y, octaves) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }

                return total / maxValue;
            }
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function clamp(val, min, max) {
            return Math.min(Math.max(val, min), max);
        }

        function colorLerp(c1, c2, t) {
            return {
                r: Math.floor(lerp(c1.r, c2.r, t)),
                g: Math.floor(lerp(c1.g, c2.g, t)),
                b: Math.floor(lerp(c1.b, c2.b, t))
            };
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r: 0, g: 0, b: 0};
        }

        function rgbToString(rgb) {
            return `rgb(${rgb.r},${rgb.g},${rgb.b})`;
        }

        // ============================================================
        // STATE (single state object that later versions extend)
        // ============================================================

        const state = {
            player: {
                x: 100,
                y: 100,
                speed: CONFIG.PLAYER_SPEED,
                dir: 0,
                dustTimer: 0
            },
            camera: {
                x: 100,
                y: 100,
                zoom: CONFIG.ZOOM_DEFAULT
            },
            time: {
                current: Date.now(),
                hour: 0,
                minute: 0,
                period: 'day'
            },
            tide: 0.375,
            weather: {
                current: 'clear',
                nextTransition: 0,
                intensity: 0,
                windDir: 0,
                windSpeed: 0,
                cloudCover: 0,
                raindrops: [],
                clouds: [],
                lightning: { active: false, timer: 0, alpha: 0 },
                fog: 0
            },
            audio: {
                ctx: null,
                enabled: true,
                nodes: {},
                muted: false
            },
            terrain: null,
            terrainColors: null,
            islandSeed: 0,
            visited: false,
            totalVisits: 0,
            totalTime: 0,
            sessionStart: Date.now(),
            stars: [],
            input: {
                up: false,
                down: false,
                left: false,
                right: false
            },
            ui: {
                showInfo: true,
                welcomeFade: 3000,
                infoFade: 5000,
                soundNotification: 0
            }
        };

        // ============================================================
        // TERRAIN GENERATION
        // ============================================================

        function generateTerrain(seed) {
            const size = CONFIG.ISLAND_SIZE;
            const terrain = Array(size).fill(null).map(() => Array(size).fill(0));
            const noise = new NoiseGenerator(seed);
            const rng = new SeededRandom(seed + 1000);

            const centerX = size / 2;
            const centerY = size / 2;
            const maxDist = size * CONFIG.ISLAND_RADIUS;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    // Distance from center
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Radial falloff with some noise for irregular shape
                    const radialNoise = noise.octaveNoise(x * 0.02, y * 0.02, 2) * 0.2;
                    const falloff = 1 - clamp((dist - radialNoise * 20) / maxDist, 0, 1);

                    // Layered noise for terrain height
                    let height = noise.octaveNoise(x * 0.03, y * 0.03, CONFIG.NOISE_OCTAVES);
                    height = (height + 1) * 0.5; // Normalize to 0-1

                    // Apply falloff to create island shape
                    height *= Math.pow(falloff, 1.5);

                    terrain[y][x] = height;
                }
            }

            return terrain;
        }

        function computeTerrainColors(terrain, seed) {
            const size = CONFIG.ISLAND_SIZE;
            const colors = Array(size).fill(null).map(() => Array(size).fill(null));
            const rng = new SeededRandom(seed + 2000);

            // Color palettes for each terrain type
            const palettes = {
                deepWater: hexToRgb('#1a3a5a'),
                shallowWater: hexToRgb('#2a5a7a'),
                wetSand: hexToRgb('#c4a868'),
                sand: hexToRgb('#d4b890'),
                grass1: hexToRgb('#4a7a3a'),
                grass2: hexToRgb('#3a6a2a'),
                denseGrass: hexToRgb('#3a5a2a'),
                rock: hexToRgb('#6a6a68'),
                highRock: hexToRgb('#5a5a58'),
                snow: hexToRgb('#d8d8d8')
            };

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const height = terrain[y][x];
                    let baseColor;

                    if (height < 0.25) {
                        baseColor = palettes.deepWater;
                    } else if (height < 0.35) {
                        const t = (height - 0.25) / 0.10;
                        baseColor = colorLerp(palettes.deepWater, palettes.shallowWater, t);
                    } else if (height < 0.40) {
                        baseColor = palettes.wetSand;
                    } else if (height < 0.45) {
                        const t = (height - 0.40) / 0.05;
                        baseColor = colorLerp(palettes.sand, palettes.grass1, t);
                    } else if (height < 0.65) {
                        const t = (height - 0.45) / 0.20;
                        baseColor = colorLerp(palettes.grass1, palettes.grass2, t);
                    } else if (height < 0.75) {
                        const t = (height - 0.65) / 0.10;
                        baseColor = colorLerp(palettes.grass2, palettes.denseGrass, t);
                    } else if (height < 0.85) {
                        const t = (height - 0.75) / 0.10;
                        baseColor = colorLerp(palettes.denseGrass, palettes.rock, t);
                    } else if (height < 0.92) {
                        const t = (height - 0.85) / 0.07;
                        baseColor = colorLerp(palettes.rock, palettes.highRock, t);
                    } else {
                        const t = (height - 0.92) / 0.08;
                        baseColor = colorLerp(palettes.highRock, palettes.snow, t);
                    }

                    // Add color variation
                    const variation = 5;
                    const color = {
                        r: clamp(baseColor.r + (rng.next() - 0.5) * variation * 2, 0, 255),
                        g: clamp(baseColor.g + (rng.next() - 0.5) * variation * 2, 0, 255),
                        b: clamp(baseColor.b + (rng.next() - 0.5) * variation * 2, 0, 255)
                    };

                    colors[y][x] = color;
                }
            }

            return colors;
        }

        function findStartPosition(terrain) {
            const size = CONFIG.ISLAND_SIZE;
            const centerX = size / 2;
            const centerY = size / 2;

            // Find nearest beach to center
            let bestDist = Infinity;
            let bestX = centerX;
            let bestY = centerY;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const height = terrain[y][x];
                    // Look for sand/beach areas
                    if (height >= 0.40 && height <= 0.50) {
                        const dx = x - centerX;
                        const dy = y - centerY;
                        const dist = dx * dx + dy * dy;
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestX = x;
                            bestY = y;
                        }
                    }
                }
            }

            return {x: bestX, y: bestY};
        }

        // ============================================================
        // TIME SYSTEM (day/night, tides)
        // ============================================================

        function updateTime() {
            const now = new Date();
            state.time.current = now.getTime();
            state.time.hour = now.getHours();
            state.time.minute = now.getMinutes();

            // Determine time period
            const hour = state.time.hour;
            if (hour >= 22 || hour < 5) {
                state.time.period = 'night';
            } else if (hour >= 5 && hour < 7) {
                state.time.period = 'dawn';
            } else if (hour >= 7 && hour < 11) {
                state.time.period = 'morning';
            } else if (hour >= 11 && hour < 14) {
                state.time.period = 'midday';
            } else if (hour >= 14 && hour < 17) {
                state.time.period = 'afternoon';
            } else if (hour >= 17 && hour < 19) {
                state.time.period = 'sunset';
            } else {
                state.time.period = 'dusk';
            }
        }

        function updateTide() {
            const cyclePosition = (Date.now() % CONFIG.TIDE_CYCLE_MS) / CONFIG.TIDE_CYCLE_MS;
            const tideWave = Math.sin(cyclePosition * Math.PI * 2);
            state.tide = lerp(CONFIG.TIDE_MIN, CONFIG.TIDE_MAX, (tideWave + 1) * 0.5);
        }

        function getLightingMultiplier() {
            const hour = state.time.hour;
            const minute = state.time.minute;
            const timeValue = hour + minute / 60;

            // Return RGB multipliers based on time of day
            switch (state.time.period) {
                case 'night':
                    return {r: 0.3, g: 0.35, b: 0.5, ambient: 0.25};
                case 'dawn':
                    const dawnT = (timeValue - 5) / 2;
                    return {
                        r: lerp(0.3, 1.0, dawnT),
                        g: lerp(0.35, 0.85, dawnT),
                        b: lerp(0.5, 0.75, dawnT),
                        ambient: lerp(0.25, 0.9, dawnT)
                    };
                case 'morning':
                    return {r: 1.0, g: 0.95, b: 0.85, ambient: 1.0};
                case 'midday':
                    return {r: 1.05, g: 1.05, b: 1.0, ambient: 1.0};
                case 'afternoon':
                    return {r: 1.1, g: 0.95, b: 0.75, ambient: 0.95};
                case 'sunset':
                    const sunsetT = (timeValue - 17) / 2;
                    return {
                        r: lerp(1.1, 0.8, sunsetT),
                        g: lerp(0.95, 0.5, sunsetT),
                        b: lerp(0.75, 0.45, sunsetT),
                        ambient: lerp(0.95, 0.4, sunsetT)
                    };
                case 'dusk':
                    const duskT = (timeValue - 19) / 3;
                    return {
                        r: lerp(0.8, 0.3, duskT),
                        g: lerp(0.5, 0.35, duskT),
                        b: lerp(0.45, 0.5, duskT),
                        ambient: lerp(0.4, 0.25, duskT)
                    };
                default:
                    return {r: 1.0, g: 1.0, b: 1.0, ambient: 1.0};
            }
        }

        function generateStars(seed) {
            const rng = new SeededRandom(seed + 3000);
            const stars = [];

            for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
                stars.push({
                    x: rng.next(),
                    y: rng.next(),
                    brightness: 0.3 + rng.next() * 0.7,
                    size: 1 + Math.floor(rng.next() * 2)
                });
            }

            return stars;
        }

        // ============================================================
        // WEATHER SYSTEM
        // ============================================================

        const WEATHER_STATES = ['clear', 'cloudy', 'rain', 'storm', 'clearing'];

        const WEATHER_CONFIG = {
            clear: {
                cloudCover: [0, 0.1],
                fog: [0, 0],
                windSpeed: [0.1, 0.3],
                rainRate: 0,
                duration: [120000, 180000]
            },
            cloudy: {
                cloudCover: [0.3, 0.6],
                fog: [0.05, 0.15],
                windSpeed: [0.3, 0.5],
                rainRate: 0,
                duration: [120000, 240000]
            },
            rain: {
                cloudCover: [0.5, 0.8],
                fog: [0.2, 0.4],
                windSpeed: [0.4, 0.6],
                rainRate: 3,
                duration: [120000, 180000]
            },
            storm: {
                cloudCover: [0.8, 1.0],
                fog: [0.3, 0.5],
                windSpeed: [0.6, 0.9],
                rainRate: 8,
                duration: [90000, 150000]
            },
            clearing: {
                cloudCover: [0.4, 0.2],
                fog: [0.2, 0.05],
                windSpeed: [0.4, 0.2],
                rainRate: 1,
                duration: [60000, 90000]
            }
        };

        function initWeather() {
            // Random starting weather
            const rng = new SeededRandom(state.islandSeed + 5000);
            const stateIndex = Math.floor(rng.next() * WEATHER_STATES.length);
            state.weather.current = WEATHER_STATES[stateIndex];
            state.weather.nextTransition = Date.now() + 120000;
            state.weather.windDir = rng.next() * Math.PI * 2;

            // Initialize clouds
            for (let i = 0; i < CONFIG.MAX_CLOUDS; i++) {
                state.weather.clouds.push({
                    x: Math.random() * CONFIG.ISLAND_SIZE,
                    y: Math.random() * CONFIG.ISLAND_SIZE,
                    width: 15 + Math.random() * 25,
                    height: 10 + Math.random() * 15,
                    opacity: 0.3 + Math.random() * 0.3,
                    speed: 0.02 + Math.random() * 0.03
                });
            }
        }

        function updateWeather() {
            const now = Date.now();
            const dt = 1 / 60;

            // Check for weather transition
            if (now >= state.weather.nextTransition) {
                transitionWeather();
            }

            // Get current weather config
            const config = WEATHER_CONFIG[state.weather.current];

            // Gradually adjust parameters toward target
            const targetCloudCover = state.weather.current === 'clearing' ?
                config.cloudCover[1] : lerp(config.cloudCover[0], config.cloudCover[1], state.weather.intensity);
            const targetFog = state.weather.current === 'clearing' ?
                config.fog[1] : lerp(config.fog[0], config.fog[1], state.weather.intensity);
            const targetWindSpeed = state.weather.current === 'clearing' ?
                config.windSpeed[1] : lerp(config.windSpeed[0], config.windSpeed[1], state.weather.intensity);

            state.weather.cloudCover += (targetCloudCover - state.weather.cloudCover) * 0.02;
            state.weather.fog += (targetFog - state.weather.fog) * 0.02;
            state.weather.windSpeed += (targetWindSpeed - state.weather.windSpeed) * 0.02;

            // Ramp intensity
            state.weather.intensity = Math.min(1, state.weather.intensity + 0.005);

            // Rotate wind direction slowly
            state.weather.windDir += 0.0001;

            // Update clouds
            for (const cloud of state.weather.clouds) {
                cloud.x += Math.cos(state.weather.windDir) * cloud.speed * state.weather.windSpeed;
                cloud.y += Math.sin(state.weather.windDir) * cloud.speed * state.weather.windSpeed;

                // Wrap around
                if (cloud.x < -cloud.width) cloud.x = CONFIG.ISLAND_SIZE + cloud.width;
                if (cloud.x > CONFIG.ISLAND_SIZE + cloud.width) cloud.x = -cloud.width;
                if (cloud.y < -cloud.height) cloud.y = CONFIG.ISLAND_SIZE + cloud.height;
                if (cloud.y > CONFIG.ISLAND_SIZE + cloud.height) cloud.y = -cloud.height;

                // Update opacity based on cloud cover
                cloud.opacity = 0.2 + state.weather.cloudCover * 0.4;
            }

            // Update rain
            if (config.rainRate > 0) {
                // Spawn new raindrops
                const spawnCount = config.rainRate * state.weather.intensity;
                for (let i = 0; i < spawnCount && state.weather.raindrops.length < CONFIG.MAX_RAINDROPS; i++) {
                    const offsetX = (Math.random() - 0.5) * 150;
                    const offsetY = (Math.random() - 0.5) * 100;
                    state.weather.raindrops.push({
                        x: state.camera.x + offsetX,
                        y: state.camera.y + offsetY - 80,
                        speed: 2 + Math.random() * 1,
                        opacity: 0.3 + Math.random() * 0.3
                    });
                }
            }

            // Update existing raindrops
            for (let i = state.weather.raindrops.length - 1; i >= 0; i--) {
                const drop = state.weather.raindrops[i];
                drop.x += Math.cos(state.weather.windDir) * state.weather.windSpeed * 0.5;
                drop.y += drop.speed;

                // Check if hit terrain
                const tileX = Math.floor(drop.x);
                const tileY = Math.floor(drop.y);
                if (tileX >= 0 && tileX < CONFIG.ISLAND_SIZE && tileY >= 0 && tileY < CONFIG.ISLAND_SIZE) {
                    if (state.terrain[tileY][tileX] >= state.tide) {
                        state.weather.raindrops.splice(i, 1);
                        continue;
                    }
                }

                // Remove if off screen
                if (drop.y > state.camera.y + 100) {
                    state.weather.raindrops.splice(i, 1);
                }
            }

            // Lightning during storms
            if (state.weather.current === 'storm' && state.weather.intensity > 0.5) {
                if (!state.weather.lightning.active && Math.random() < 0.001) {
                    triggerLightning();
                }
            }

            // Update lightning
            if (state.weather.lightning.active) {
                state.weather.lightning.alpha -= 0.03;
                if (state.weather.lightning.alpha <= 0) {
                    state.weather.lightning.active = false;
                }
            }
        }

        function transitionWeather() {
            const currentIndex = WEATHER_STATES.indexOf(state.weather.current);
            const nextIndex = (currentIndex + 1) % WEATHER_STATES.length;
            state.weather.current = WEATHER_STATES[nextIndex];
            state.weather.intensity = 0;

            // Set next transition time
            const config = WEATHER_CONFIG[state.weather.current];
            const duration = lerp(config.duration[0], config.duration[1], Math.random());
            state.weather.nextTransition = Date.now() + duration;
        }

        function triggerLightning() {
            state.weather.lightning.active = true;
            state.weather.lightning.alpha = 0.8;

            // Thunder sound after delay
            const delay = 1000 + Math.random() * 2000;
            setTimeout(() => {
                playThunder();
            }, delay);
        }

        // ============================================================
        // CAMERA
        // ============================================================

        function updateCamera() {
            // Smooth follow player
            state.camera.x += (state.player.x - state.camera.x) * CONFIG.CAMERA_LERP;
            state.camera.y += (state.player.y - state.camera.y) * CONFIG.CAMERA_LERP;
        }

        function screenToWorld(screenX, screenY, canvas) {
            const worldX = (screenX - canvas.width / 2) / (CONFIG.TILE_SIZE * state.camera.zoom) + state.camera.x;
            const worldY = (screenY - canvas.height / 2) / (CONFIG.TILE_SIZE * state.camera.zoom) + state.camera.y;
            return {x: worldX, y: worldY};
        }

        function worldToScreen(worldX, worldY, canvas) {
            const screenX = (worldX - state.camera.x) * CONFIG.TILE_SIZE * state.camera.zoom + canvas.width / 2;
            const screenY = (worldY - state.camera.y) * CONFIG.TILE_SIZE * state.camera.zoom + canvas.height / 2;
            return {x: screenX, y: screenY};
        }

        // ============================================================
        // PLAYER
        // ============================================================

        function updatePlayer() {
            let dx = 0;
            let dy = 0;

            if (state.input.up) dy -= 1;
            if (state.input.down) dy += 1;
            if (state.input.left) dx -= 1;
            if (state.input.right) dx += 1;

            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            const isMoving = dx !== 0 || dy !== 0;

            if (isMoving) {
                const newX = state.player.x + dx * state.player.speed;
                const newY = state.player.y + dy * state.player.speed;

                // Check collision
                if (canWalkOn(newX, newY)) {
                    state.player.x = newX;
                    state.player.y = newY;

                    // Update direction
                    state.player.dir = Math.atan2(dy, dx);

                    // Dust particles
                    state.player.dustTimer++;

                    // Footstep sound
                    if (state.player.dustTimer % 15 === 0) {
                        playFootstep();
                    }
                }
            }
        }

        function canWalkOn(x, y) {
            const tileX = Math.floor(x);
            const tileY = Math.floor(y);

            if (tileX < 0 || tileX >= CONFIG.ISLAND_SIZE || tileY < 0 || tileY >= CONFIG.ISLAND_SIZE) {
                return false;
            }

            const height = state.terrain[tileY][tileX];
            const waterLevel = state.tide;

            // Cannot walk on water
            return height >= waterLevel;
        }

        function getCompassDirection() {
            const centerX = CONFIG.ISLAND_SIZE / 2;
            const centerY = CONFIG.ISLAND_SIZE / 2;
            const dx = state.player.x - centerX;
            const dy = state.player.y - centerY;
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            if (angle >= -45 && angle < 45) return 'East';
            if (angle >= 45 && angle < 135) return 'South';
            if (angle >= -135 && angle < -45) return 'North';
            return 'West';
        }

        // ============================================================
        // AUDIO SYSTEM
        // ============================================================

        function initAudioContext() {
            if (!state.audio.ctx) {
                try {
                    state.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();

                    // Start ambient loops
                    if (!state.audio.muted) {
                        startAmbientSounds();
                    }
                } catch (e) {
                    console.warn('Web Audio API not supported', e);
                }
            } else if (state.audio.ctx.state === 'suspended') {
                state.audio.ctx.resume();
            }
        }

        function startAmbientSounds() {
            if (!state.audio.ctx || state.audio.muted) return;

            // Ocean ambient
            if (!state.audio.nodes.ocean) {
                const bufferSize = state.audio.ctx.sampleRate * 2;
                const buffer = state.audio.ctx.createBuffer(1, bufferSize, state.audio.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = state.audio.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;

                const filter = state.audio.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                const lfo = state.audio.ctx.createOscillator();
                lfo.frequency.value = 0.3;
                const lfoGain = state.audio.ctx.createGain();
                lfoGain.gain.value = 100;
                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                lfo.start();

                const gain = state.audio.ctx.createGain();
                gain.gain.value = 0.02;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(state.audio.ctx.destination);
                noise.start();

                state.audio.nodes.ocean = { noise, filter, gain, lfo };
            }

            // Wind ambient
            if (!state.audio.nodes.wind) {
                const bufferSize = state.audio.ctx.sampleRate * 2;
                const buffer = state.audio.ctx.createBuffer(1, bufferSize, state.audio.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = state.audio.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;

                const filter = state.audio.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 800;
                filter.Q.value = 0.5;

                const gain = state.audio.ctx.createGain();
                gain.gain.value = 0;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(state.audio.ctx.destination);
                noise.start();

                state.audio.nodes.wind = { noise, filter, gain };
            }

            // Rain ambient
            if (!state.audio.nodes.rain) {
                const bufferSize = state.audio.ctx.sampleRate * 2;
                const buffer = state.audio.ctx.createBuffer(1, bufferSize, state.audio.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = state.audio.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;

                const filter = state.audio.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 2000;

                const gain = state.audio.ctx.createGain();
                gain.gain.value = 0;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(state.audio.ctx.destination);
                noise.start();

                state.audio.nodes.rain = { noise, filter, gain };
            }
        }

        function updateAmbientSounds() {
            if (!state.audio.ctx || state.audio.muted || !state.audio.nodes.wind) return;

            // Update wind volume based on weather
            const targetWindVolume = state.weather.windSpeed * 0.08;
            const currentWindVolume = state.audio.nodes.wind.gain.gain.value;
            state.audio.nodes.wind.gain.gain.value = lerp(currentWindVolume, targetWindVolume, 0.05);

            // Update rain volume
            if (state.audio.nodes.rain) {
                const targetRainVolume = (state.weather.current === 'rain' || state.weather.current === 'storm') ?
                    state.weather.intensity * 0.05 : 0;
                const currentRainVolume = state.audio.nodes.rain.gain.gain.value;
                state.audio.nodes.rain.gain.gain.value = lerp(currentRainVolume, targetRainVolume, 0.05);
            }
        }

        function playThunder() {
            if (!state.audio.ctx || state.audio.muted) return;

            const osc = state.audio.ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = 60;

            const gain = state.audio.ctx.createGain();
            gain.gain.value = 0.3;
            gain.gain.exponentialRampToValueAtTime(0.01, state.audio.ctx.currentTime + 3);

            osc.connect(gain);
            gain.connect(state.audio.ctx.destination);

            osc.start();
            osc.stop(state.audio.ctx.currentTime + 3);
        }

        function playFootstep() {
            if (!state.audio.ctx || state.audio.muted) return;

            const bufferSize = state.audio.ctx.sampleRate * 0.05;
            const buffer = state.audio.ctx.createBuffer(1, bufferSize, state.audio.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / bufferSize * 10);
            }

            const noise = state.audio.ctx.createBufferSource();
            noise.buffer = buffer;

            const gain = state.audio.ctx.createGain();
            gain.gain.value = 0.02;

            noise.connect(gain);
            gain.connect(state.audio.ctx.destination);
            noise.start();
        }

        function toggleSound() {
            state.audio.muted = !state.audio.muted;
            state.ui.soundNotification = Date.now();

            if (state.audio.muted) {
                // Mute all audio nodes
                if (state.audio.nodes.ocean) state.audio.nodes.ocean.gain.gain.value = 0;
                if (state.audio.nodes.wind) state.audio.nodes.wind.gain.gain.value = 0;
                if (state.audio.nodes.rain) state.audio.nodes.rain.gain.gain.value = 0;
            } else {
                initAudioContext();
            }
        }

        // ============================================================
        // RENDERER
        // ============================================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', {alpha: false});

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function render() {
            const lighting = getLightingMultiplier();

            // Calculate visible bounds
            const halfWidth = canvas.width / (2 * CONFIG.TILE_SIZE * state.camera.zoom);
            const halfHeight = canvas.height / (2 * CONFIG.TILE_SIZE * state.camera.zoom);

            const startX = Math.max(0, Math.floor(state.camera.x - halfWidth - 1));
            const endX = Math.min(CONFIG.ISLAND_SIZE, Math.ceil(state.camera.x + halfWidth + 1));
            const startY = Math.max(0, Math.floor(state.camera.y - halfHeight - 1));
            const endY = Math.min(CONFIG.ISLAND_SIZE, Math.ceil(state.camera.y + halfHeight + 1));

            // Clear with ocean color
            const deepWater = hexToRgb('#0a1a2a');
            ctx.fillStyle = rgbToString({
                r: Math.floor(deepWater.r * lighting.r * lighting.ambient),
                g: Math.floor(deepWater.g * lighting.g * lighting.ambient),
                b: Math.floor(deepWater.b * lighting.b * lighting.ambient)
            });
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Render stars if night
            if (state.time.period === 'night' || state.time.period === 'dusk') {
                const starAlpha = state.time.period === 'night' ? 1.0 :
                    1.0 - ((state.time.hour - 19) / 3);
                renderStars(starAlpha);
            }

            // Render terrain
            renderTerrain(startX, endX, startY, endY, lighting);

            // Render cloud shadows
            if (state.time.period !== 'night') {
                renderClouds(startX, endX, startY, endY);
            }

            // Render foam at waterline
            renderFoam(startX, endX, startY, endY);

            // Render rain
            renderRain();

            // Render fog
            renderFog(startX, endX, startY, endY);

            // Render player
            renderPlayer();

            // Render lightning
            renderLightning();
        }

        function renderTerrain(startX, endX, startY, endY, lighting) {
            const shimmer = Math.sin(Date.now() * 0.001) * 0.05 + 1.0;
            const waterLevel = state.tide;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const height = state.terrain[y][x];
                    let color = {...state.terrainColors[y][x]};

                    // Handle tidal zone
                    if (height >= CONFIG.TIDE_MIN && height <= CONFIG.TIDE_MAX) {
                        if (height < waterLevel) {
                            // Currently underwater
                            const shallowWater = hexToRgb('#2a5a7a');
                            const t = (waterLevel - height) / (CONFIG.TIDE_MAX - CONFIG.TIDE_MIN);
                            color = colorLerp(state.terrainColors[y][x], shallowWater, t * 0.7);
                        }
                    }

                    // Apply shimmer to water
                    if (height < waterLevel) {
                        color.r = Math.floor(color.r * shimmer);
                        color.g = Math.floor(color.g * shimmer);
                        color.b = Math.floor(color.b * shimmer);
                    }

                    // Apply lighting
                    color.r = clamp(Math.floor(color.r * lighting.r * lighting.ambient), 0, 255);
                    color.g = clamp(Math.floor(color.g * lighting.g * lighting.ambient), 0, 255);
                    color.b = clamp(Math.floor(color.b * lighting.b * lighting.ambient), 0, 255);

                    const screenPos = worldToScreen(x, y, canvas);
                    const size = CONFIG.TILE_SIZE * state.camera.zoom;

                    ctx.fillStyle = rgbToString(color);
                    ctx.fillRect(
                        Math.floor(screenPos.x),
                        Math.floor(screenPos.y),
                        Math.ceil(size),
                        Math.ceil(size)
                    );
                }
            }
        }

        function renderClouds(startX, endX, startY, endY) {
            if (state.weather.cloudCover < 0.1) return;

            ctx.fillStyle = `rgba(30, 30, 40, ${state.weather.cloudCover * 0.3})`;

            for (const cloud of state.weather.clouds) {
                // Check if cloud overlaps visible area
                if (cloud.x + cloud.width < startX || cloud.x > endX ||
                    cloud.y + cloud.height < startY || cloud.y > endY) {
                    continue;
                }

                // Draw shadow for tiles under cloud
                for (let y = Math.floor(cloud.y); y < Math.ceil(cloud.y + cloud.height); y++) {
                    for (let x = Math.floor(cloud.x); x < Math.ceil(cloud.x + cloud.width); x++) {
                        if (x >= startX && x < endX && y >= startY && y < endY) {
                            if (x >= 0 && x < CONFIG.ISLAND_SIZE && y >= 0 && y < CONFIG.ISLAND_SIZE) {
                                // Check if on land
                                if (state.terrain[y][x] >= state.tide) {
                                    const screenPos = worldToScreen(x, y, canvas);
                                    const size = CONFIG.TILE_SIZE * state.camera.zoom;

                                    // Elliptical falloff
                                    const cx = cloud.x + cloud.width / 2;
                                    const cy = cloud.y + cloud.height / 2;
                                    const dx = (x - cx) / (cloud.width / 2);
                                    const dy = (y - cy) / (cloud.height / 2);
                                    const dist = dx * dx + dy * dy;

                                    if (dist < 1) {
                                        const alpha = (1 - dist) * cloud.opacity;
                                        ctx.fillStyle = `rgba(30, 30, 40, ${alpha * state.weather.cloudCover})`;
                                        ctx.fillRect(
                                            Math.floor(screenPos.x),
                                            Math.floor(screenPos.y),
                                            Math.ceil(size),
                                            Math.ceil(size)
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        function renderFoam(startX, endX, startY, endY) {
            const waterLevel = state.tide;
            const foamPhase = (Date.now() * 0.003) % 1;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const height = state.terrain[y][x];

                    // Check if this is at the water edge
                    if (Math.abs(height - waterLevel) < 0.02) {
                        // Check neighbors to see if we're at land-water boundary
                        let isEdge = false;
                        const neighbors = [
                            [x-1, y], [x+1, y], [x, y-1], [x, y+1]
                        ];

                        for (const [nx, ny] of neighbors) {
                            if (nx >= 0 && nx < CONFIG.ISLAND_SIZE && ny >= 0 && ny < CONFIG.ISLAND_SIZE) {
                                const nh = state.terrain[ny][nx];
                                if ((height < waterLevel && nh >= waterLevel) ||
                                    (height >= waterLevel && nh < waterLevel)) {
                                    isEdge = true;
                                    break;
                                }
                            }
                        }

                        if (isEdge && Math.random() < 0.15) {
                            const screenPos = worldToScreen(x + Math.random(), y + Math.random(), canvas);
                            const size = (1 + Math.sin(foamPhase * Math.PI * 2 + x + y) * 0.5) * state.camera.zoom;
                            ctx.fillRect(screenPos.x, screenPos.y, size, size);
                        }
                    }
                }
            }
        }

        function renderRain() {
            if (state.weather.raindrops.length === 0) return;

            for (const drop of state.weather.raindrops) {
                const screenPos = worldToScreen(drop.x, drop.y, canvas);

                // Check if on screen
                if (screenPos.x < -10 || screenPos.x > canvas.width + 10 ||
                    screenPos.y < -10 || screenPos.y > canvas.height + 10) {
                    continue;
                }

                const angle = state.weather.windDir + Math.PI / 2;
                const length = 3 * state.camera.zoom;
                const endX = screenPos.x + Math.cos(angle) * length;
                const endY = screenPos.y + Math.sin(angle) * length;

                ctx.strokeStyle = `rgba(200, 220, 255, ${drop.opacity})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(screenPos.x, screenPos.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
        }

        function renderFog(startX, endX, startY, endY) {
            if (state.weather.fog < 0.05) return;

            const fogColor = state.time.period === 'night' ?
                'rgba(40, 50, 70, ' : 'rgba(180, 190, 200, ';

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const dx = x - state.player.x;
                    const dy = y - state.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 5) {
                        const fogAmount = Math.min(1, (dist - 5) / 30) * state.weather.fog;

                        if (fogAmount > 0.05) {
                            const screenPos = worldToScreen(x, y, canvas);
                            const size = CONFIG.TILE_SIZE * state.camera.zoom;

                            ctx.fillStyle = fogColor + fogAmount + ')';
                            ctx.fillRect(
                                Math.floor(screenPos.x),
                                Math.floor(screenPos.y),
                                Math.ceil(size),
                                Math.ceil(size)
                            );
                        }
                    }
                }
            }
        }

        function renderPlayer() {
            const screenPos = worldToScreen(state.player.x, state.player.y, canvas);
            const size = 6 * state.camera.zoom;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(screenPos.x + 2 * state.camera.zoom, screenPos.y + 2 * state.camera.zoom, size / 2, 0, Math.PI * 2);
            ctx.fill();

            // Player body
            ctx.fillStyle = '#e8c888';
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, size / 2, 0, Math.PI * 2);
            ctx.fill();

            // Outline
            ctx.strokeStyle = '#c8a868';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Dust particles
            if (state.input.up || state.input.down || state.input.left || state.input.right) {
                if (state.player.dustTimer % 10 === 0) {
                    renderDustPuff(screenPos.x, screenPos.y);
                }
            }
        }

        function renderDustPuff(x, y) {
            const alpha = 0.3;
            ctx.fillStyle = `rgba(200, 180, 150, ${alpha})`;

            for (let i = 0; i < 3; i++) {
                const offsetX = (Math.random() - 0.5) * 4 * state.camera.zoom;
                const offsetY = (Math.random() - 0.5) * 4 * state.camera.zoom;
                const size = (1 + Math.random() * 2) * state.camera.zoom;

                ctx.beginPath();
                ctx.arc(x + offsetX, y + offsetY, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function renderStars(alpha) {
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;

            for (const star of state.stars) {
                const x = star.x * canvas.width;
                const y = star.y * canvas.height;
                const brightness = star.brightness * alpha;
                const twinkle = Math.sin(Date.now() * 0.001 + star.x * 100) * 0.2 + 0.8;

                ctx.globalAlpha = brightness * twinkle;
                ctx.fillRect(x, y, star.size, star.size);
            }

            ctx.globalAlpha = 1.0;
        }

        function renderLightning() {
            if (state.weather.lightning.active) {
                ctx.fillStyle = `rgba(255, 255, 255, ${state.weather.lightning.alpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // ============================================================
        // INPUT
        // ============================================================

        function setupInput() {
            window.addEventListener('keydown', (e) => {
                // Initialize audio on first interaction
                if (!state.audio.ctx) {
                    initAudioContext();
                }

                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        state.input.up = true;
                        e.preventDefault();
                        break;
                    case 's':
                    case 'arrowdown':
                        state.input.down = true;
                        e.preventDefault();
                        break;
                    case 'a':
                    case 'arrowleft':
                        state.input.left = true;
                        e.preventDefault();
                        break;
                    case 'd':
                    case 'arrowright':
                        state.input.right = true;
                        e.preventDefault();
                        break;
                    case 'm':
                        toggleSound();
                        e.preventDefault();
                        break;
                }
            });

            window.addEventListener('keyup', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        state.input.up = false;
                        break;
                    case 's':
                    case 'arrowdown':
                        state.input.down = false;
                        break;
                    case 'a':
                    case 'arrowleft':
                        state.input.left = false;
                        break;
                    case 'd':
                    case 'arrowright':
                        state.input.right = false;
                        break;
                }
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -CONFIG.ZOOM_STEP : CONFIG.ZOOM_STEP;
                state.camera.zoom = clamp(
                    state.camera.zoom + delta,
                    CONFIG.ZOOM_MIN,
                    CONFIG.ZOOM_MAX
                );
            }, {passive: false});

            // Initialize audio on click too
            canvas.addEventListener('click', () => {
                if (!state.audio.ctx) {
                    initAudioContext();
                }
            });
        }

        // ============================================================
        // SAVE / LOAD
        // ============================================================

        function saveState() {
            const saveData = {
                player: {
                    x: state.player.x,
                    y: state.player.y
                },
                islandSeed: state.islandSeed,
                totalVisits: state.totalVisits,
                totalTime: state.totalTime + (Date.now() - state.sessionStart),
                lastVisit: Date.now()
            };

            try {
                localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(saveData));
            } catch (e) {
                console.warn('Failed to save state:', e);
            }
        }

        function loadState() {
            try {
                const saved = localStorage.getItem(CONFIG.STORAGE_KEY);
                if (saved) {
                    const data = JSON.parse(saved);
                    state.islandSeed = data.islandSeed;
                    state.totalVisits = data.totalVisits + 1;
                    state.totalTime = data.totalTime || 0;
                    state.visited = true;
                    return data;
                }
            } catch (e) {
                console.warn('Failed to load state:', e);
            }
            return null;
        }

        // ============================================================
        // UI
        // ============================================================

        function updateUI() {
            const uiEl = document.getElementById('ui');
            const welcomeEl = document.getElementById('welcome');

            // Welcome message
            const elapsed = Date.now() - state.sessionStart;
            if (elapsed < state.ui.welcomeFade) {
                const visitText = state.totalVisits === 1 ? 'First visit' : `Visit #${state.totalVisits}`;
                welcomeEl.textContent = visitText;
                welcomeEl.style.opacity = 1 - (elapsed / state.ui.welcomeFade);
            } else {
                welcomeEl.style.opacity = 0;
            }

            // Info display
            let infoText = '';
            if (elapsed < state.ui.infoFade) {
                const hour12 = state.time.hour % 12 || 12;
                const ampm = state.time.hour >= 12 ? 'PM' : 'AM';
                const timeStr = `${hour12}:${String(state.time.minute).padStart(2, '0')} ${ampm}`;
                const compass = getCompassDirection();
                infoText = `${timeStr}<br>${compass}`;

                // Add weather
                const weatherNames = {
                    clear: 'Clear',
                    cloudy: 'Cloudy',
                    rain: 'Rain',
                    storm: 'Storm',
                    clearing: 'Clearing'
                };
                infoText += `<br>${weatherNames[state.weather.current]}`;

                uiEl.innerHTML = infoText;
                uiEl.style.opacity = 1;
            } else {
                uiEl.style.opacity = Math.max(0, 1 - (elapsed - state.ui.infoFade) / 500);
            }

            // Sound notification
            if (state.ui.soundNotification > 0) {
                const notifElapsed = Date.now() - state.ui.soundNotification;
                if (notifElapsed < 2000) {
                    const notifText = state.audio.muted ? 'Sound Off' : 'Sound On';
                    ctx.fillStyle = `rgba(255, 255, 255, ${1 - notifElapsed / 2000})`;
                    ctx.font = '14px Georgia';
                    ctx.textAlign = 'center';
                    ctx.fillText(notifText, canvas.width / 2, 50);
                    ctx.textAlign = 'left';
                } else {
                    state.ui.soundNotification = 0;
                }
            }
        }

        // ============================================================
        // MAIN LOOP
        // ============================================================

        function initialize() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Load or create new save
            const savedData = loadState();

            if (!state.visited) {
                // First time - generate new island
                state.islandSeed = Math.floor(Math.random() * 1000000);
                state.totalVisits = 1;
            }

            // Generate terrain
            state.terrain = generateTerrain(state.islandSeed);
            state.terrainColors = computeTerrainColors(state.terrain, state.islandSeed);
            state.stars = generateStars(state.islandSeed);

            // Initialize weather
            initWeather();

            // Set player position
            if (savedData && savedData.player) {
                state.player.x = savedData.player.x;
                state.player.y = savedData.player.y;
            } else {
                const startPos = findStartPosition(state.terrain);
                state.player.x = startPos.x;
                state.player.y = startPos.y;
            }

            // Initialize camera
            state.camera.x = state.player.x;
            state.camera.y = state.player.y;

            setupInput();

            // Auto-save every 10 seconds
            setInterval(saveState, 10000);

            // Save on page unload
            window.addEventListener('beforeunload', saveState);

            // Start game loop
            gameLoop();
        }

        function gameLoop() {
            updateTime();
            updateTide();
            updateWeather();
            updatePlayer();
            updateCamera();
            updateAmbientSounds();
            render();
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        // Start the experience
        initialize();
    </script>
</body>
</html>
