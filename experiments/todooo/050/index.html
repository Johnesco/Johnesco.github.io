<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>050 â€” Synesthesia</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: #06060a;
}
canvas { display: block; }
#soundToggle {
  position: fixed;
  top: 16px;
  right: 16px;
  width: 32px;
  height: 32px;
  background: rgba(255,255,255,0.1);
  border-radius: 50%;
  border: 1px solid rgba(255,255,255,0.2);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: opacity 0.5s;
  z-index: 10;
}
#soundToggle:hover { background: rgba(255,255,255,0.15); }
#soundToggle.hidden { opacity: 0; pointer-events: none; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<button id="soundToggle" title="Toggle Sound">ðŸ”Š</button>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const soundToggle = document.getElementById('soundToggle');

let W, H, audioCtx, soundEnabled = true, mouseX = 0, mouseY = 0, mouseActive = false;
let shapes = [], currentWord = [], mode = 0, typewriterX = 40, typewriterY = 80;
const modes = ['free', 'radial', 'gravity', 'orbit'];
const STORAGE_KEY = 'todooo-050';

// Initialize
function init() {
  resize();
  window.addEventListener('resize', resize);
  canvas.addEventListener('mousemove', e => {
    mouseX = e.clientX; mouseY = e.clientY; mouseActive = true;
  });
  canvas.addEventListener('mouseleave', () => mouseActive = false);
  document.addEventListener('keydown', handleKey);
  soundToggle.addEventListener('click', toggleSound);

  try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {}

  loadState();
  animate();
  setTimeout(() => soundToggle.classList.add('hidden'), 3000);
}

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  if (!mouseActive) { mouseX = W/2; mouseY = H/2; }
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  soundToggle.textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
  soundToggle.classList.remove('hidden');
  setTimeout(() => soundToggle.classList.add('hidden'), 2000);
}

// Character mappings
function getCharData(char) {
  const c = char.toLowerCase();
  const isVowel = 'aeiou'.includes(c);
  const isLetter = /[a-z]/.test(c);
  const isNumber = /[0-9]/.test(c);
  const isPunct = /[^\w\s]/.test(c);

  let hue, sat, bright, freq, waveType, shapeType, lifespan;

  if (c === ' ') {
    return { hue: 0, sat: 0, bright: 100, freq: 130.81, waveType: 'sine',
             shapeType: 'ripple', lifespan: 3000, size: 80 };
  }

  if (isLetter) {
    const index = c.charCodeAt(0) - 97;
    hue = (index / 26) * 360;
    sat = isVowel ? 90 : 70;
    bright = isVowel ? 75 : 65;
    freq = 220 * Math.pow(2, index / 13); // 2 octaves across a-z
    waveType = isVowel ? 'sine' : 'triangle';
    lifespan = isVowel ? 8000 : 6000;

    if (index < 6) shapeType = 'circle';
    else if (index < 12) shapeType = 'square';
    else if (index < 18) shapeType = 'triangle';
    else if (index < 24) shapeType = 'star';
    else shapeType = 'diamond';
  } else if (isNumber) {
    const n = parseInt(c);
    hue = (n / 10) * 360;
    sat = 30;
    bright = 60;
    freq = 440 + n * 50;
    waveType = 'square';
    shapeType = 'ring';
    lifespan = 5000;
  } else if (isPunct) {
    hue = 45;
    sat = 20;
    bright = 80;
    freq = 1000 + Math.random() * 500;
    waveType = 'noise';
    shapeType = 'punct';
    lifespan = 3000;
  } else {
    return null;
  }

  return { hue, sat, bright, freq, waveType, shapeType, lifespan,
           size: 20 + Math.random() * 30 };
}

// Position based on mode
function getPosition(charData) {
  let x, y;

  if (mouseActive && mode === 0) {
    x = mouseX + (Math.random() - 0.5) * 60;
    y = mouseY + (Math.random() - 0.5) * 60;
  } else if (mode === 0) { // typewriter flow
    x = typewriterX + (Math.random() - 0.5) * 20;
    y = typewriterY + (Math.random() - 0.5) * 20;
    typewriterX += 50;
    if (typewriterX > W - 80) {
      typewriterX = 40;
      typewriterY += 60;
      if (typewriterY > H - 80) typewriterY = 80;
    }
  } else if (mode === 1) { // radial
    const angle = (shapes.length * 0.3) % (Math.PI * 2);
    const radius = 200 + Math.random() * 100;
    x = W/2 + Math.cos(angle) * radius;
    y = H/2 + Math.sin(angle) * radius;
  } else if (mode === 2) { // gravity
    x = Math.random() * W;
    y = Math.random() * 100;
  } else { // orbit
    const angle = Math.random() * Math.PI * 2;
    const radius = 100 + (charData.hue / 360) * 300;
    x = W/2 + Math.cos(angle) * radius;
    y = H/2 + Math.sin(angle) * radius;
  }

  return { x, y };
}

// Sound
function playSound(charData) {
  if (!soundEnabled || !audioCtx) return;

  const now = audioCtx.currentTime;
  const duration = 0.15;

  if (charData.waveType === 'noise') {
    const bufferSize = audioCtx.sampleRate * duration;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.1, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
    noise.connect(gain).connect(audioCtx.destination);
    noise.start(now);
  } else {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = charData.waveType;
    osc.frequency.value = charData.freq;
    gain.gain.setValueAtTime(0.15, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + duration);
  }
}

// Handle keypress
function handleKey(e) {
  if (e.key === 'Tab') {
    e.preventDefault();
    mode = (mode + 1) % modes.length;
    return;
  }

  if (e.key === 'Escape') {
    shapes.forEach(s => s.opacity = 0);
    if (soundEnabled && audioCtx) {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.frequency.setValueAtTime(200, now);
      osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.5);
    }
    currentWord = [];
    return;
  }

  if (e.key === 'Enter') {
    shapes.forEach(s => {
      s.pulse = 1;
      s.lifespan *= 0.5;
    });
    currentWord = [];
    if (soundEnabled && audioCtx) {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.frequency.value = 110;
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.3);
    }
    return;
  }

  if (e.key === 'Backspace') {
    const recent = shapes.filter(s => s.opacity > 0).pop();
    if (recent) {
      recent.implode = true;
      if (soundEnabled && audioCtx) {
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.setValueAtTime(recent.freq, now);
        osc.frequency.exponentialRampToValueAtTime(recent.freq * 0.5, now + 0.2);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + 0.2);
      }
    }
    if (currentWord.length) currentWord.pop();
    return;
  }

  if (e.key.length === 1) {
    const charData = getCharData(e.key);
    if (!charData) return;

    const pos = getPosition(charData);
    const shape = {
      ...charData,
      x: pos.x,
      y: pos.y,
      vx: (Math.random() - 0.5) * 0.5,
      vy: (Math.random() - 0.5) * 0.5,
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.02,
      opacity: 1,
      scale: 0,
      birth: Date.now(),
      pulse: 0,
      implode: false,
      wordId: currentWord.length
    };

    shapes.push(shape);
    currentWord.push(shape);
    playSound(charData);

    if (e.key === ' ') {
      currentWord.forEach(s => s.pulse = 0.5);
      currentWord = [];
    }
  }
}

// Draw shape
function drawShape(s) {
  const color = `hsla(${s.hue}, ${s.sat}%, ${s.bright}%, ${s.opacity})`;
  ctx.fillStyle = color;
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;

  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.rotate(s.rotation);
  ctx.scale(s.scale, s.scale);

  const sz = s.size;

  if (s.shapeType === 'circle' || s.shapeType === 'ripple') {
    ctx.beginPath();
    ctx.arc(0, 0, sz, 0, Math.PI * 2);
    if (s.shapeType === 'ripple') ctx.stroke();
    else ctx.fill();
  } else if (s.shapeType === 'square') {
    ctx.fillRect(-sz/2, -sz/2, sz, sz);
  } else if (s.shapeType === 'triangle') {
    ctx.beginPath();
    ctx.moveTo(0, -sz);
    ctx.lineTo(sz * 0.866, sz/2);
    ctx.lineTo(-sz * 0.866, sz/2);
    ctx.closePath();
    ctx.fill();
  } else if (s.shapeType === 'star') {
    const points = 5 + Math.floor(s.hue / 120);
    ctx.beginPath();
    for (let i = 0; i < points * 2; i++) {
      const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
      const r = i % 2 === 0 ? sz : sz * 0.5;
      const x = Math.cos(angle) * r;
      const y = Math.sin(angle) * r;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
  } else if (s.shapeType === 'diamond') {
    ctx.beginPath();
    ctx.moveTo(0, -sz);
    ctx.lineTo(sz, 0);
    ctx.lineTo(0, sz);
    ctx.lineTo(-sz, 0);
    ctx.closePath();
    ctx.fill();
  } else if (s.shapeType === 'ring') {
    ctx.beginPath();
    ctx.arc(0, 0, sz, 0, Math.PI * 2);
    ctx.stroke();
  } else if (s.shapeType === 'punct') {
    ctx.fillRect(-sz/4, -sz/4, sz/2, sz/2);
  }

  ctx.restore();
}

// Update and draw
function animate() {
  requestAnimationFrame(animate);

  // Calculate average color for background
  let avgH = 0, avgS = 0, avgL = 0, count = 0;
  shapes.forEach(s => {
    if (s.opacity > 0) {
      avgH += s.hue * s.opacity;
      avgS += s.sat * s.opacity;
      avgL += s.bright * s.opacity;
      count += s.opacity;
    }
  });
  if (count > 0) {
    avgH /= count;
    avgS /= count;
    avgL /= count;
    ctx.fillStyle = `hsla(${avgH}, ${avgS}%, ${avgL}%, 0.05)`;
    ctx.fillRect(0, 0, W, H);
  }

  // Fade background
  ctx.fillStyle = 'rgba(6, 6, 10, 0.15)';
  ctx.fillRect(0, 0, W, H);

  const now = Date.now();

  shapes.forEach((s, i) => {
    // Birth animation
    const age = now - s.birth;
    if (age < 200 && !s.implode) {
      s.scale = age < 100 ? (age / 100) * 1.2 : 1.2 - ((age - 100) / 100) * 0.2;
    } else if (!s.implode) {
      s.scale = 1;
    }

    // Pulse
    if (s.pulse > 0) {
      s.scale = 1 + s.pulse * 0.3;
      s.pulse -= 0.05;
    }

    // Implode
    if (s.implode) {
      s.scale *= 0.9;
      s.opacity *= 0.9;
      if (s.scale < 0.1) s.opacity = 0;
    }

    // Movement
    s.x += s.vx;
    s.y += s.vy;
    s.rotation += s.rotSpeed;

    // Gravity mode
    if (mode === 2 && !s.implode) {
      s.vy += 0.2;
      if (s.y > H - s.size) {
        s.y = H - s.size;
        s.vy *= -0.3;
      }
    }

    // Orbit mode
    if (mode === 3 && !s.implode) {
      const dx = s.x - W/2;
      const dy = s.y - H/2;
      const angle = Math.atan2(dy, dx);
      const radius = Math.sqrt(dx*dx + dy*dy);
      const newAngle = angle + 0.01;
      s.x = W/2 + Math.cos(newAngle) * radius;
      s.y = H/2 + Math.sin(newAngle) * radius;
    }

    // Fade
    if (!s.implode) {
      const lifePct = age / s.lifespan;
      if (lifePct > 1) {
        s.opacity = Math.max(0, 0.03 - (lifePct - 1) * 0.003);
      } else {
        s.opacity = 1 - lifePct * 0.5;
      }
    }

    // Draw
    if (s.opacity > 0.001) drawShape(s);
  });

  // Clean up old shapes
  shapes = shapes.filter(s => s.opacity > 0.001 || Date.now() - s.birth < s.lifespan + 10000);
}

// Persistence
function saveState() {
  const state = {
    mode,
    shapes: shapes.slice(-50).map(s => ({...s, opacity: s.opacity * 0.03}))
  };
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch(e) {}
}

function loadState() {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    if (data) {
      const state = JSON.parse(data);
      mode = state.mode || 0;
      if (state.shapes) {
        shapes = state.shapes.map(s => ({
          ...s,
          birth: Date.now() - s.lifespan,
          opacity: 0.03,
          vx: 0,
          vy: 0
        }));
      }
    }
  } catch(e) {}
}

window.addEventListener('beforeunload', saveState);

init();
</script>
</body>
</html>
