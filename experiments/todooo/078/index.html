<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>078 Clockwork - Mechanical Automaton</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #1a1008;
            font-family: 'Georgia', serif;
            color: #c49a3c;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        #input-overlay {
            position: absolute;
            display: none;
            z-index: 100;
        }

        #task-input {
            background: rgba(196, 154, 60, 0.9);
            border: 2px solid #b87333;
            padding: 8px 12px;
            font-size: 16px;
            font-family: 'Georgia', serif;
            color: #1a1008;
            outline: none;
            border-radius: 3px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
        }

        #task-input::placeholder {
            color: #4a3820;
        }

        #tooltip {
            position: absolute;
            background: rgba(30, 20, 10, 0.95);
            border: 1px solid #c49a3c;
            padding: 8px 12px;
            font-size: 14px;
            color: #c49a3c;
            pointer-events: none;
            display: none;
            border-radius: 3px;
            max-width: 300px;
            word-wrap: break-word;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
            z-index: 50;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="input-overlay">
        <input type="text" id="task-input" placeholder="Enter task..." maxlength="100">
    </div>
    <div id="tooltip"></div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const inputOverlay = document.getElementById('input-overlay');
        const taskInput = document.getElementById('task-input');
        const tooltip = document.getElementById('tooltip');

        let width, height;
        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Audio setup (lazy)
        let audioCtx = null;
        let audioInitialized = false;

        function initAudio() {
            if (!audioInitialized) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                audioInitialized = true;
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playTick(frequency = 800) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = frequency;
            osc.type = 'square';
            gain.gain.value = 0.02;
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
            osc.stop(audioCtx.currentTime + 0.05);
        }

        function playClick() {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 0.1;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 0.02));
            }
            const source = audioCtx.createBufferSource();
            const gain = audioCtx.createGain();
            source.buffer = buffer;
            source.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.value = 0.15;
            source.start();
        }

        function playChime() {
            if (!audioCtx) return;
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C, E, G, C
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.value = freq;
                    osc.type = 'sine';
                    gain.gain.value = 0.1;
                    osc.start();
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);
                    osc.stop(audioCtx.currentTime + 1.5);
                }, i * 150);
            });
        }

        // Task/Gear data
        let gears = [];
        const STORAGE_KEY = 'todooo-078';

        class Gear {
            constructor(text, x, y) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.completed = false;
                this.radius = this.calculateRadius();
                this.teeth = Math.floor(this.radius / 6);
                this.color = this.calculateColor();
                this.angle = Math.random() * Math.PI * 2;
                this.speed = this.completed ? (30 / this.radius) : 0; // radians per second
                this.direction = 1; // 1 or -1
                this.id = Date.now() + Math.random();
                this.lastTickTime = 0;
                this.breaking = false;
                this.pieces = [];
            }

            calculateRadius() {
                const len = this.text.length;
                return Math.max(40, Math.min(120, 40 + len * 2));
            }

            calculateColor() {
                const hash = this.hashCode(this.text);
                const colors = ['#c49a3c', '#b87333', '#555560'];
                return colors[Math.abs(hash) % colors.length];
            }

            hashCode(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash |= 0;
                }
                return hash;
            }

            update(dt) {
                if (this.breaking) {
                    this.pieces.forEach(p => {
                        p.vy += 300 * dt; // gravity
                        p.x += p.vx * dt;
                        p.y += p.vy * dt;
                        p.angle += p.spin * dt;
                    });
                    return;
                }

                if (this.completed) {
                    this.angle += this.speed * this.direction * dt;

                    // Tick sound
                    const tickInterval = 0.5 / Math.abs(this.speed);
                    if (Date.now() - this.lastTickTime > tickInterval * 1000) {
                        playTick(600 + this.radius);
                        this.lastTickTime = Date.now();
                    }
                }
            }

            draw(ctx) {
                if (this.breaking) {
                    this.pieces.forEach(p => {
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.angle);
                        ctx.fillStyle = this.color;
                        ctx.globalAlpha = 0.7;
                        ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                        ctx.restore();
                    });
                    return;
                }

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Draw gear body
                ctx.beginPath();
                for (let i = 0; i < this.teeth; i++) {
                    const angle1 = (i / this.teeth) * Math.PI * 2;
                    const angle2 = ((i + 0.5) / this.teeth) * Math.PI * 2;
                    const angle3 = ((i + 1) / this.teeth) * Math.PI * 2;

                    const outerRadius = this.radius;
                    const innerRadius = this.radius * 0.8;

                    const x1 = Math.cos(angle1) * innerRadius;
                    const y1 = Math.sin(angle1) * innerRadius;
                    const x2 = Math.cos(angle1) * outerRadius;
                    const y2 = Math.sin(angle1) * outerRadius;
                    const x3 = Math.cos(angle2) * outerRadius;
                    const y3 = Math.sin(angle2) * outerRadius;
                    const x4 = Math.cos(angle3) * outerRadius;
                    const y4 = Math.sin(angle3) * outerRadius;
                    const x5 = Math.cos(angle3) * innerRadius;
                    const y5 = Math.sin(angle3) * innerRadius;

                    if (i === 0) {
                        ctx.moveTo(x1, y1);
                    }
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                    ctx.lineTo(x4, y4);
                    ctx.lineTo(x5, y5);
                }
                ctx.closePath();

                // Fill
                ctx.fillStyle = this.color;
                if (this.completed) {
                    ctx.shadowColor = 'rgba(255, 200, 100, 0.5)';
                    ctx.shadowBlur = 10;
                }
                ctx.fill();
                ctx.shadowBlur = 0;

                // Inner circle
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = this.completed ?
                    this.lightenColor(this.color, 20) :
                    this.darkenColor(this.color, 20);
                ctx.fill();

                // Stroke
                ctx.strokeStyle = this.darkenColor(this.color, 30);
                ctx.lineWidth = 2;
                ctx.stroke();

                // Center axle
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#222';
                ctx.fill();
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Specular highlight if active
                if (this.completed) {
                    ctx.beginPath();
                    ctx.arc(-this.radius * 0.2, -this.radius * 0.2, this.radius * 0.15, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 200, 0.3)';
                    ctx.fill();
                }

                ctx.restore();
            }

            lightenColor(color, amount) {
                const hex = color.replace('#', '');
                const r = Math.min(255, parseInt(hex.substr(0, 2), 16) + amount);
                const g = Math.min(255, parseInt(hex.substr(2, 2), 16) + amount);
                const b = Math.min(255, parseInt(hex.substr(4, 2), 16) + amount);
                return `rgb(${r}, ${g}, ${b})`;
            }

            darkenColor(color, amount) {
                const hex = color.replace('#', '');
                const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - amount);
                const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - amount);
                const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - amount);
                return `rgb(${r}, ${g}, ${b})`;
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) < this.radius;
            }

            complete() {
                if (this.completed) return;
                this.completed = true;
                this.speed = 30 / this.radius;
                this.lastTickTime = Date.now();
                playClick();
                updateMeshConnections();
                saveGears();
            }

            breakApart() {
                this.breaking = true;
                const pieceCount = 12;
                for (let i = 0; i < pieceCount; i++) {
                    const angle = (i / pieceCount) * Math.PI * 2;
                    const dist = this.radius * (0.5 + Math.random() * 0.5);
                    this.pieces.push({
                        x: this.x + Math.cos(angle) * dist,
                        y: this.y + Math.sin(angle) * dist,
                        vx: Math.cos(angle) * (100 + Math.random() * 100),
                        vy: Math.sin(angle) * (100 + Math.random() * 100) - 100,
                        angle: Math.random() * Math.PI * 2,
                        spin: (Math.random() - 0.5) * 10,
                        size: 5 + Math.random() * 10
                    });
                }
            }
        }

        // Find valid position for new gear
        function findGearPosition() {
            if (gears.length === 0) {
                return { x: width / 2, y: height / 2 };
            }

            // Try to mesh with existing gears
            for (let attempt = 0; attempt < 100; attempt++) {
                const existingGear = gears[Math.floor(Math.random() * gears.length)];
                const angle = Math.random() * Math.PI * 2;
                const distance = existingGear.radius + 80; // approximate mesh distance
                const x = existingGear.x + Math.cos(angle) * distance;
                const y = existingGear.y + Math.sin(angle) * distance;

                // Check bounds
                if (x < 100 || x > width - 100 || y < 100 || y > height - 100) {
                    continue;
                }

                // Check overlap with other gears
                let overlap = false;
                for (let gear of gears) {
                    const dx = x - gear.x;
                    const dy = y - gear.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 150) { // minimum distance
                        overlap = true;
                        break;
                    }
                }

                if (!overlap) {
                    return { x, y };
                }
            }

            // Fallback: random position
            return {
                x: 150 + Math.random() * (width - 300),
                y: 150 + Math.random() * (height - 300)
            };
        }

        // Update mesh connections (rotation directions)
        function updateMeshConnections() {
            // Reset directions
            gears.forEach(g => g.direction = 0);

            // Find a completed gear to start from
            const startGear = gears.find(g => g.completed);
            if (!startGear) return;

            startGear.direction = 1;
            const queue = [startGear];
            const visited = new Set([startGear.id]);

            while (queue.length > 0) {
                const current = queue.shift();

                // Find meshed neighbors
                for (let gear of gears) {
                    if (!gear.completed || visited.has(gear.id)) continue;

                    const dx = gear.x - current.x;
                    const dy = gear.y - current.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const meshDist = current.radius + gear.radius;

                    if (Math.abs(dist - meshDist) < 30) {
                        gear.direction = -current.direction;
                        visited.add(gear.id);
                        queue.push(gear);
                    }
                }
            }
        }

        // Automaton figure
        class Automaton {
            constructor() {
                this.x = width / 2;
                this.y = 80;
                this.wingAngle = 0;
                this.active = false;
            }

            update(dt) {
                const progress = getCompletionProgress();
                this.active = progress === 1;

                if (this.active) {
                    this.wingAngle += dt * 8;
                }
            }

            draw(ctx) {
                const progress = getCompletionProgress();

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.globalAlpha = Math.min(1, progress * 2);

                // Perch
                ctx.strokeStyle = '#b87333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-30, 0);
                ctx.lineTo(30, 0);
                ctx.stroke();

                // Bird body
                ctx.fillStyle = '#c49a3c';
                ctx.beginPath();
                ctx.ellipse(0, -10, 12, 16, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#8a6a2c';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Head
                ctx.beginPath();
                ctx.arc(0, -22, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Eye
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(3, -23, 2, 0, Math.PI * 2);
                ctx.fill();

                // Beak
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(6, -22);
                ctx.lineTo(12, -21);
                ctx.lineTo(6, -20);
                ctx.closePath();
                ctx.fill();

                // Wings
                const wingFlap = this.active ? Math.sin(this.wingAngle) * 0.5 : 0;

                // Left wing
                ctx.save();
                ctx.rotate(-0.3 + wingFlap);
                ctx.fillStyle = '#b87333';
                ctx.beginPath();
                ctx.ellipse(-8, -10, 8, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#8a6a2c';
                ctx.stroke();
                ctx.restore();

                // Right wing
                ctx.save();
                ctx.rotate(0.3 - wingFlap);
                ctx.fillStyle = '#b87333';
                ctx.beginPath();
                ctx.ellipse(8, -10, 8, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#8a6a2c';
                ctx.stroke();
                ctx.restore();

                // Legs
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-4, -2);
                ctx.lineTo(-4, 5);
                ctx.moveTo(4, -2);
                ctx.lineTo(4, 5);
                ctx.stroke();

                ctx.restore();
            }
        }

        const automaton = new Automaton();

        // Completion progress
        function getCompletionProgress() {
            if (gears.length === 0) return 0;
            const completed = gears.filter(g => g.completed && !g.breaking).length;
            return completed / gears.length;
        }

        // Background decorations
        let rivets = [];
        function generateRivets() {
            rivets = [];
            for (let i = 0; i < 50; i++) {
                rivets.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: 2 + Math.random() * 3
                });
            }
        }
        generateRivets();

        // Steam particles
        let steamParticles = [];
        function createSteamParticle() {
            steamParticles.push({
                x: Math.random() * width,
                y: height + 10,
                vy: -20 - Math.random() * 30,
                vx: (Math.random() - 0.5) * 10,
                life: 1,
                decay: 0.3 + Math.random() * 0.3,
                size: 10 + Math.random() * 20
            });
        }

        // Storage
        function saveGears() {
            const data = gears.filter(g => !g.breaking).map(g => ({
                text: g.text,
                x: g.x,
                y: g.y,
                completed: g.completed
            }));
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        function loadGears() {
            try {
                const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
                gears = data.map(d => {
                    const g = new Gear(d.text, d.x, d.y);
                    g.completed = d.completed;
                    if (g.completed) {
                        g.speed = 30 / g.radius;
                    }
                    return g;
                });
                updateMeshConnections();
            } catch (e) {
                gears = [];
            }
        }

        loadGears();

        // Input handling
        let pendingPosition = null;

        canvas.addEventListener('click', (e) => {
            initAudio();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicked on gear
            const clickedGear = gears.find(g => !g.breaking && g.contains(x, y));
            if (clickedGear) {
                return; // handle in other events
            }

            // Open input for new task
            pendingPosition = { x, y };
            inputOverlay.style.left = e.clientX + 'px';
            inputOverlay.style.top = e.clientY + 'px';
            inputOverlay.style.display = 'block';
            taskInput.value = '';
            taskInput.focus();
        });

        canvas.addEventListener('dblclick', (e) => {
            initAudio();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const clickedGear = gears.find(g => !g.breaking && g.contains(x, y));
            if (clickedGear) {
                clickedGear.complete();

                // Check if all complete
                if (getCompletionProgress() === 1) {
                    playChime();
                }
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            initAudio();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const clickedGear = gears.find(g => !g.breaking && g.contains(x, y));
            if (clickedGear) {
                clickedGear.breakApart();
                setTimeout(() => {
                    gears = gears.filter(g => g !== clickedGear);
                    updateMeshConnections();
                    saveGears();
                }, 1000);
            }
        });

        let hoveredGear = null;
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            hoveredGear = gears.find(g => !g.breaking && g.contains(x, y));

            if (hoveredGear) {
                tooltip.textContent = hoveredGear.text;
                tooltip.style.left = e.clientX + 15 + 'px';
                tooltip.style.top = e.clientY + 15 + 'px';
                tooltip.style.display = 'block';
            } else {
                tooltip.style.display = 'none';
            }
        });

        taskInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const text = taskInput.value.trim();
                if (text && pendingPosition) {
                    const gear = new Gear(text, pendingPosition.x, pendingPosition.y);
                    gears.push(gear);
                    saveGears();
                }
                inputOverlay.style.display = 'none';
                pendingPosition = null;
            } else if (e.key === 'Escape') {
                inputOverlay.style.display = 'none';
                pendingPosition = null;
            }
        });

        taskInput.addEventListener('blur', () => {
            setTimeout(() => {
                inputOverlay.style.display = 'none';
            }, 200);
        });

        // Drawing
        function drawBackground() {
            // Base color
            ctx.fillStyle = '#1a1008';
            ctx.fillRect(0, 0, width, height);

            // Vignette
            const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height) * 0.7);
            gradient.addColorStop(0, 'rgba(26, 16, 8, 0)');
            gradient.addColorStop(1, 'rgba(10, 6, 2, 0.8)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Rivets
            ctx.fillStyle = '#444';
            rivets.forEach(r => {
                ctx.beginPath();
                ctx.arc(r.x, r.y, r.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        function drawConnections() {
            // Draw connecting rods between some gears
            ctx.strokeStyle = 'rgba(184, 115, 51, 0.4)';
            ctx.lineWidth = 4;

            for (let i = 0; i < gears.length; i++) {
                for (let j = i + 1; j < gears.length; j++) {
                    const g1 = gears[i];
                    const g2 = gears[j];

                    if (g1.breaking || g2.breaking) continue;

                    const dx = g2.x - g1.x;
                    const dy = g2.y - g1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const meshDist = g1.radius + g2.radius;

                    // Draw rod if gears are meshed
                    if (Math.abs(dist - meshDist) < 30 && g1.completed && g2.completed) {
                        ctx.beginPath();
                        ctx.moveTo(g1.x, g1.y);
                        ctx.lineTo(g2.x, g2.y);
                        ctx.stroke();
                    }
                }
            }

            // Springs for isolated gears
            ctx.strokeStyle = 'rgba(196, 154, 60, 0.3)';
            ctx.lineWidth = 2;

            gears.forEach((gear, i) => {
                if (gear.breaking) return;

                let isolated = true;
                for (let other of gears) {
                    if (other === gear || other.breaking) continue;
                    const dx = other.x - gear.x;
                    const dy = other.y - gear.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200) {
                        isolated = false;
                        break;
                    }
                }

                if (isolated && Math.random() < 0.3) {
                    const targetX = gear.x + (Math.random() - 0.5) * 100;
                    const targetY = gear.y + (Math.random() - 0.5) * 100;

                    ctx.beginPath();
                    const segments = 8;
                    for (let s = 0; s <= segments; s++) {
                        const t = s / segments;
                        const x = gear.x + (targetX - gear.x) * t;
                        const y = gear.y + (targetY - gear.y) * t;
                        const offset = (s % 2 === 0 ? -1 : 1) * 5;
                        const perpX = -(targetY - gear.y) / dist * offset;
                        const perpY = (targetX - gear.x) / dist * offset;

                        if (s === 0) {
                            ctx.moveTo(x + perpX, y + perpY);
                        } else {
                            ctx.lineTo(x + perpX, y + perpY);
                        }
                    }
                    ctx.stroke();
                }
            });
        }

        function drawSteam() {
            steamParticles.forEach(p => {
                ctx.fillStyle = `rgba(150, 120, 80, ${p.life * 0.15})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawEngraving() {
            const completed = gears.filter(g => g.completed && !g.breaking).length;
            ctx.fillStyle = 'rgba(196, 154, 60, 0.3)';
            ctx.font = '14px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText(`${completed} gears turning`, width / 2, height - 20);
        }

        // Animation loop
        let lastTime = performance.now();
        let lastSteamTime = 0;

        function animate(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            // Update
            gears.forEach(g => g.update(dt));
            automaton.update(dt);

            // Update steam
            if (currentTime - lastSteamTime > 200) {
                createSteamParticle();
                lastSteamTime = currentTime;
            }

            steamParticles.forEach(p => {
                p.y += p.vy * dt;
                p.x += p.vx * dt;
                p.life -= p.decay * dt;
            });
            steamParticles = steamParticles.filter(p => p.life > 0);

            // Draw
            drawBackground();
            drawSteam();
            drawConnections();
            gears.forEach(g => g.draw(ctx));
            automaton.draw(ctx);
            drawEngraving();

            // Clean up broken gears that fell off screen
            gears = gears.filter(g => {
                if (!g.breaking) return true;
                return g.pieces.some(p => p.y < height + 100);
            });

            requestAnimationFrame(animate);
        }

        animate(performance.now());

        // Regenerate rivets on resize
        window.addEventListener('resize', () => {
            generateRivets();
            automaton.x = width / 2;
        });
    </script>
</body>
</html>
