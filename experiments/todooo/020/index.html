<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>todooo</title>
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #2a2a4a;
            --bg-input: #0f1a30;
            --accent: #7c83ff;
            --accent-hover: #6a71e0;
            --text-primary: #e0e0e0;
            --text-muted: #888;
            --text-dim: #555;
            --text-dimmer: #444;
            --green: #4ade80;
            --yellow: #fbbf24;
            --red: #f87171;
            --particle-accent: #7c83ff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            padding: 3rem 1rem;
            transition: background 2s ease, color 1s ease;
            overflow-x: hidden;
        }

        body.canvas-active {
            padding: 0;
            overflow: hidden;
        }

        .app { width: 100%; max-width: 500px; position: relative; z-index: 10; }
        body.canvas-active .app { display: none; }

        h1 {
            font-size: 2.5rem;
            letter-spacing: 0.3rem;
            margin-bottom: 0.5rem;
            color: #fff;
            transition: color 1s ease;
        }

        .sentient-comment {
            font-size: 0.8rem;
            color: var(--text-dim);
            font-style: italic;
            margin-bottom: 1rem;
            min-height: 1.2em;
            transition: opacity 0.5s ease;
            line-height: 1.4;
        }

        .top-controls {
            position: fixed; top: 1rem; right: 1rem;
            display: flex; gap: 0.5rem; z-index: 300;
        }

        .top-btn {
            background: var(--bg-tertiary); border: none; color: var(--text-muted);
            font-size: 1rem; padding: 0.5rem 0.7rem; border-radius: 8px;
            cursor: pointer; transition: all 0.2s;
        }
        .top-btn:hover { color: var(--text-primary); }
        .top-btn.on { color: var(--accent); }
        .top-btn.sound-toggle { font-size: 1.2rem; }

        .progress-bar {
            width: 100%; height: 6px; background: var(--bg-tertiary);
            border-radius: 3px; margin-bottom: 1.5rem; overflow: hidden; transition: opacity 0.3s;
        }
        .progress-bar.hidden { opacity: 0; }
        .progress-fill {
            height: 100%; background: var(--accent); border-radius: 3px;
            transition: width 0.4s ease, background 0.4s ease;
        }
        .progress-fill.complete { background: var(--green); }

        .input-row { display: flex; gap: 0.5rem; margin-bottom: 0.5rem; }
        .input-row input {
            flex: 1; padding: 0.75rem 1rem;
            border: 2px solid var(--bg-tertiary); border-radius: 8px;
            background: var(--bg-secondary); color: var(--text-primary);
            font-size: 1rem; outline: none; transition: border-color 0.2s;
        }
        .input-row input:focus { border-color: var(--accent); }
        .input-row input::placeholder { color: var(--text-dim); }
        .input-row button {
            padding: 0.75rem 1.25rem; border: none; border-radius: 8px;
            background: var(--accent); color: #fff; font-size: 1rem;
            font-weight: 600; cursor: pointer; transition: background 0.2s;
        }
        .input-row button:hover { background: var(--accent-hover); }

        .priority-row { display: flex; gap: 0.5rem; margin-bottom: 0.75rem; align-items: center; }
        .priority-row span { color: var(--text-dim); font-size: 0.8rem; }
        .priority-btn {
            border: none; padding: 0.25rem 0.6rem; border-radius: 4px;
            cursor: pointer; font-size: 0.8rem; font-weight: 600;
            transition: all 0.2s; opacity: 0.4;
        }
        .priority-btn.active { opacity: 1; }
        .priority-btn[data-p="none"] { background: var(--bg-tertiary); color: var(--text-muted); }
        .priority-btn[data-p="low"] { background: #1b5e3b; color: var(--green); }
        .priority-btn[data-p="med"] { background: #5e4b1b; color: var(--yellow); }
        .priority-btn[data-p="high"] { background: #5e1b1b; color: var(--red); }

        .search-row { margin-bottom: 0.75rem; }
        .search-row input {
            width: 100%; padding: 0.5rem 1rem;
            border: 2px solid var(--bg-tertiary); border-radius: 8px;
            background: var(--bg-secondary); color: var(--text-primary);
            font-size: 0.9rem; outline: none; transition: border-color 0.2s;
        }
        .search-row input:focus { border-color: var(--accent); }
        .search-row input::placeholder { color: var(--text-dimmer); }

        .toolbar {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 1rem; padding: 0.5rem 0; font-size: 0.85rem;
            flex-wrap: wrap; gap: 0.5rem;
        }
        .count { color: var(--text-muted); }
        .filters { display: flex; gap: 0.25rem; }
        .filters button, .canvas-toggle-btn {
            background: none; border: 1px solid transparent; color: var(--text-muted);
            padding: 0.25rem 0.6rem; border-radius: 4px; cursor: pointer;
            font-size: 0.85rem; transition: all 0.2s;
        }
        .filters button:hover, .canvas-toggle-btn:hover { color: var(--text-primary); }
        .filters button.active, .canvas-toggle-btn.active { border-color: var(--accent); color: var(--accent); }
        .clear-done {
            background: none; border: none; color: var(--text-muted);
            font-size: 0.85rem; cursor: pointer; transition: color 0.2s;
        }
        .clear-done:hover { color: var(--red); }
        .clear-done:disabled { opacity: 0; pointer-events: none; }

        .todo-list { list-style: none; }

        .todo-item {
            display: flex; align-items: center; gap: 0.75rem;
            padding: 0.75rem 1rem; background: var(--bg-secondary);
            border-radius: 8px; margin-bottom: 0.5rem;
            transition: opacity 0.3s, transform 0.3s, box-shadow 0.2s, background 0.5s;
            user-select: none; border-left: 3px solid transparent;
        }
        .todo-item.p-low { border-left-color: var(--green); }
        .todo-item.p-med { border-left-color: var(--yellow); }
        .todo-item.p-high { border-left-color: var(--red); }
        .todo-item.focused { outline: 2px solid var(--accent); outline-offset: -2px; }
        .todo-item.slide-in { animation: slideIn 0.3s ease-out; }
        .todo-item.fade-out { animation: fadeOut 0.3s ease-out forwards; }
        .todo-item.dragging { opacity: 0.4; }
        .todo-item.drag-over { box-shadow: 0 -2px 0 0 var(--accent); }

        @keyframes slideIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeOut { from { opacity: 1; transform: translateX(0); } to { opacity: 0; transform: translateX(30px); } }

        .todo-item.done { opacity: 0.5; }
        .todo-item.done .todo-text { text-decoration: line-through; }

        .todo-item.age-fresh { background: var(--bg-secondary); }
        .todo-item.age-day { background: #1a2235; }
        .todo-item.age-old { background: #221e1e; }
        .todo-item.age-ancient { background: #2a1a1a; animation: tremble 3s infinite; }
        @keyframes tremble { 0%,95%,100%{transform:translateX(0)} 96%{transform:translateX(-1px)} 98%{transform:translateX(1px)} }

        .age-badge {
            font-size: 0.65rem; padding: 0.1rem 0.35rem; border-radius: 3px;
            flex-shrink: 0; font-weight: 600;
        }
        .age-badge.age-day { background: #3a3520; color: #d4a843; }
        .age-badge.age-old { background: #3a2520; color: #e88a5a; }
        .age-badge.age-ancient { background: #3a1a1a; color: var(--red); }

        .ghost-item {
            display: flex; align-items: center; gap: 0.75rem;
            padding: 0.5rem 1rem; border-radius: 8px; margin-bottom: 0.3rem;
            background: transparent; border: 1px dashed #333;
            opacity: 0.25; font-style: italic; color: var(--text-dim);
            transition: opacity 0.5s ease;
            animation: ghostFloat 4s ease-in-out infinite;
        }
        .ghost-item:hover { opacity: 0.4; }
        @keyframes ghostFloat {
            0%,100% { transform: translateY(0) } 50% { transform: translateY(-2px) }
        }
        .ghost-text { flex: 1; font-size: 0.85rem; text-decoration: line-through; }
        .ghost-label { font-size: 0.6rem; color: #444; }

        .drag-handle {
            cursor: grab; color: var(--text-dimmer); font-size: 1rem;
            flex-shrink: 0; display: flex; align-items: center; transition: color 0.2s;
        }
        .drag-handle:active { cursor: grabbing; }
        .drag-handle:hover { color: var(--text-muted); }

        .priority-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
        .priority-dot.p-low { background: var(--green); }
        .priority-dot.p-med { background: var(--yellow); }
        .priority-dot.p-high { background: var(--red); }

        .todo-check {
            width: 22px; height: 22px; border: 2px solid var(--accent);
            border-radius: 50%; flex-shrink: 0; cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: background 0.2s;
        }
        .todo-item.done .todo-check { background: var(--accent); }
        .todo-check::after {
            content: ''; display: none; width: 6px; height: 10px;
            border: solid #fff; border-width: 0 2px 2px 0;
            transform: rotate(45deg) translate(-1px, -1px);
        }
        .todo-item.done .todo-check::after { display: block; }

        .todo-text { flex: 1; font-size: 1rem; cursor: default; }
        .todo-text mark {
            background: rgba(124,131,255,0.25); color: var(--text-primary);
            border-radius: 2px; padding: 0 1px;
        }

        .todo-text-edit {
            flex: 1; font-size: 1rem; background: var(--bg-input);
            border: 2px solid var(--accent); border-radius: 4px;
            color: var(--text-primary); padding: 0.2rem 0.4rem;
            outline: none; font-family: inherit;
        }

        .todo-priority-cycle {
            background: none; border: none; cursor: pointer; font-size: 0.7rem;
            padding: 0.15rem 0.3rem; border-radius: 3px;
            transition: all 0.2s; color: var(--text-dim);
        }
        .todo-priority-cycle:hover { color: #aaa; }
        .todo-delete {
            background: none; border: none; color: var(--text-dim); font-size: 1.2rem;
            cursor: pointer; padding: 0 0.25rem; line-height: 1; transition: color 0.2s;
        }
        .todo-delete:hover { color: var(--red); }

        .empty { color: var(--text-dim); text-align: center; padding: 2rem; font-style: italic; }

        .toast {
            position: fixed; bottom: 2rem; left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-tertiary); color: var(--text-primary);
            padding: 0.75rem 1.25rem; border-radius: 8px;
            display: flex; align-items: center; gap: 1rem; font-size: 0.9rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4); transition: transform 0.3s ease; z-index: 500;
        }
        .toast.show { transform: translateX(-50%) translateY(0); }
        .toast button {
            background: var(--accent); border: none; color: #fff;
            padding: 0.3rem 0.75rem; border-radius: 4px; cursor: pointer;
            font-size: 0.85rem; font-weight: 600;
        }

        .kbd-hint {
            position: fixed; bottom: 2rem; right: 2rem; color: var(--text-dimmer);
            font-size: 0.75rem; text-align: right; line-height: 1.6;
            transition: opacity 0.3s; pointer-events: none;
        }
        .kbd-hint.hidden { opacity: 0; }
        body.canvas-active .kbd-hint { display: none; }
        kbd {
            background: var(--bg-tertiary); padding: 0.1rem 0.35rem; border-radius: 3px;
            font-family: 'Consolas', monospace; font-size: 0.7rem;
        }

        /* Zen Mode */
        .zen-overlay {
            display: none; position: fixed; inset: 0;
            background: var(--bg-primary); z-index: 150;
            flex-direction: column; align-items: center; justify-content: center;
            padding: 2rem; transition: background 2s ease;
        }
        .zen-overlay.active { display: flex; }
        .zen-label {
            font-size: 0.8rem; color: var(--text-dim); margin-bottom: 2rem;
            letter-spacing: 0.2rem; text-transform: uppercase;
        }
        .zen-task {
            font-size: 2rem; color: var(--text-primary); text-align: center;
            max-width: 600px; line-height: 1.5; margin-bottom: 1rem;
            transition: opacity 0.5s ease;
        }
        .zen-task.done { text-decoration: line-through; opacity: 0.4; }
        .zen-priority-indicator {
            width: 12px; height: 12px; border-radius: 50%; margin-bottom: 1rem;
        }
        .zen-hint {
            position: fixed; bottom: 2rem; color: var(--text-dimmer);
            font-size: 0.75rem; letter-spacing: 0.1rem;
        }
        .zen-check {
            width: 40px; height: 40px; border: 3px solid var(--accent);
            border-radius: 50%; cursor: pointer; display: flex;
            align-items: center; justify-content: center; transition: background 0.2s;
            margin-bottom: 2rem;
        }
        .zen-check.checked { background: var(--accent); }
        .zen-check::after {
            content: ''; display: none; width: 10px; height: 16px;
            border: solid #fff; border-width: 0 3px 3px 0;
            transform: rotate(45deg) translate(-2px, -2px);
        }
        .zen-check.checked::after { display: block; }
        .zen-nav { display: flex; gap: 2rem; margin-top: 1rem; }
        .zen-nav button {
            background: none; border: 1px solid var(--bg-tertiary);
            color: var(--text-muted); padding: 0.5rem 1.5rem; border-radius: 8px;
            cursor: pointer; font-size: 0.9rem; transition: all 0.2s;
        }
        .zen-nav button:hover { border-color: var(--accent); color: var(--accent); }

        /* Particle canvas */
        #particleCanvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 50;
        }

        /* Confetti canvas */
        #confetti {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 200;
        }

        /* Dream state */
        .dream-overlay {
            display: none; position: fixed; inset: 0; pointer-events: none; z-index: 40;
        }
        .dream-overlay.active { display: block; }
        body.dreaming {
            animation: dreamPulse 8s ease-in-out infinite;
        }
        body.dreaming .app {
            animation: dreamFloat 6s ease-in-out infinite;
        }
        @keyframes dreamPulse {
            0%,100% { filter: hue-rotate(0deg) brightness(1); }
            50% { filter: hue-rotate(30deg) brightness(0.9); }
        }
        @keyframes dreamFloat {
            0%,100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-5px) rotate(0.3deg); }
            75% { transform: translateY(3px) rotate(-0.2deg); }
        }
        .dream-text {
            position: fixed; color: var(--accent); opacity: 0;
            font-size: 1.2rem; font-style: italic; pointer-events: none;
            z-index: 45; transition: opacity 2s ease;
        }
        .dream-text.visible { opacity: 0.3; }

        /* ====================================== */
        /* SPATIAL CANVAS MODE                    */
        /* ====================================== */
        .canvas-container {
            display: none; position: fixed; inset: 0; z-index: 10;
            overflow: hidden;
            background: color-mix(in srgb, var(--bg-primary) 90%, black 10%);
        }
        body.canvas-active .canvas-container { display: block; }

        .canvas-world {
            position: absolute; top: 0; left: 0;
            width: 3000px; height: 3000px;
            transform-origin: 0 0;
        }

        /* Subtle grid dots */
        .canvas-world::before {
            content: '';
            position: absolute; inset: 0;
            background-image: radial-gradient(circle, var(--text-dimmer) 1px, transparent 1px);
            background-size: 30px 30px;
            opacity: 0.25;
            pointer-events: none;
        }

        /* SVG connections layer */
        .canvas-svg {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; z-index: 1;
        }
        .canvas-svg line {
            stroke: var(--accent);
            stroke-width: 2;
            filter: drop-shadow(0 0 4px var(--accent));
            opacity: 0.6;
        }
        .canvas-svg line.temp-line {
            stroke-dasharray: 6 4;
            opacity: 0.8;
        }

        /* Sticky note cards */
        .canvas-card {
            position: absolute;
            width: 160px;
            min-height: 80px;
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 10px 12px;
            border-left: 4px solid transparent;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            cursor: grab;
            user-select: none;
            z-index: 2;
            transition: box-shadow 0.2s, transform 0.15s, opacity 0.3s;
        }
        .canvas-card:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 24px rgba(0,0,0,0.55);
            z-index: 3;
        }
        .canvas-card.dragging-card {
            cursor: grabbing;
            box-shadow: 0 12px 32px rgba(0,0,0,0.6);
            z-index: 10;
            transition: none;
        }
        .canvas-card.p-low { border-left-color: var(--green); }
        .canvas-card.p-med { border-left-color: var(--yellow); }
        .canvas-card.p-high { border-left-color: var(--red); }
        .canvas-card.done { opacity: 0.5; }
        .canvas-card.done .card-text { text-decoration: line-through; }

        .card-check {
            width: 18px; height: 18px; border: 2px solid var(--accent);
            border-radius: 50%; cursor: pointer; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
            transition: background 0.2s;
        }
        .canvas-card.done .card-check { background: var(--accent); }
        .card-check::after {
            content: ''; display: none; width: 5px; height: 8px;
            border: solid #fff; border-width: 0 2px 2px 0;
            transform: rotate(45deg) translate(-1px, -1px);
        }
        .canvas-card.done .card-check::after { display: block; }

        .card-header {
            display: flex; align-items: center; gap: 8px; margin-bottom: 6px;
        }
        .card-text {
            font-size: 0.85rem; color: var(--text-primary);
            line-height: 1.3;
            display: -webkit-box; -webkit-line-clamp: 4;
            -webkit-box-orient: vertical; overflow: hidden;
            text-overflow: ellipsis; word-break: break-word;
        }
        .card-text-edit {
            font-size: 0.85rem; color: var(--text-primary);
            background: var(--bg-input); border: 1px solid var(--accent);
            border-radius: 4px; padding: 2px 4px; width: 100%;
            outline: none; font-family: inherit; resize: none;
            min-height: 40px;
        }
        .card-comment {
            font-size: 0.6rem; color: var(--text-dim); font-style: italic;
            margin-top: 6px; line-height: 1.3;
            overflow: hidden; text-overflow: ellipsis;
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
        }

        /* Canvas toolbar (on canvas) */
        .canvas-toolbar {
            position: fixed; top: 1rem; left: 50%;
            transform: translateX(-50%);
            display: none; align-items: center; gap: 0.5rem;
            background: var(--bg-tertiary); border-radius: 10px;
            padding: 0.5rem 1rem; z-index: 100;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
        }
        body.canvas-active .canvas-toolbar { display: flex; }
        .canvas-toolbar h2 {
            font-size: 1.1rem; letter-spacing: 0.15rem; color: #fff; margin-right: 0.5rem;
        }
        .canvas-toolbar input {
            padding: 0.4rem 0.8rem; border: 1px solid var(--bg-primary);
            border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary);
            font-size: 0.85rem; outline: none; width: 180px;
        }
        .canvas-toolbar input:focus { border-color: var(--accent); }
        .canvas-toolbar button {
            background: none; border: 1px solid transparent; color: var(--text-muted);
            padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer;
            font-size: 0.8rem; transition: all 0.2s;
        }
        .canvas-toolbar button:hover { color: var(--text-primary); }
        .canvas-toolbar button.active { border-color: var(--accent); color: var(--accent); }

        /* Minimap */
        .minimap {
            position: fixed; bottom: 1rem; right: 1rem;
            width: 150px; height: 100px;
            background: rgba(0,0,0,0.5);
            border: 1px solid var(--bg-tertiary);
            border-radius: 8px;
            z-index: 100;
            display: none; overflow: hidden;
        }
        body.canvas-active .minimap { display: block; }
        .minimap-viewport {
            position: absolute;
            border: 1px solid var(--accent);
            background: rgba(124,131,255,0.08);
            pointer-events: none;
        }
        .minimap-dot {
            position: absolute; width: 4px; height: 4px; border-radius: 50%;
        }

        /* Context menu */
        .ctx-menu {
            position: fixed;
            background: var(--bg-tertiary);
            border: 1px solid var(--bg-primary);
            border-radius: 8px;
            padding: 4px 0;
            z-index: 400;
            box-shadow: 0 6px 20px rgba(0,0,0,0.5);
            min-width: 130px;
            display: none;
        }
        .ctx-menu.visible { display: block; }
        .ctx-menu-item {
            padding: 6px 14px;
            font-size: 0.8rem;
            cursor: pointer;
            color: var(--text-primary);
            transition: background 0.15s;
        }
        .ctx-menu-item:hover { background: var(--accent); color: #fff; }
        .ctx-menu-item.danger:hover { background: var(--red); }

        /* Zoom indicator */
        .zoom-indicator {
            position: fixed; bottom: 7.5rem; right: 1rem;
            color: var(--text-dim); font-size: 0.75rem;
            z-index: 100; display: none;
            background: var(--bg-tertiary); padding: 0.3rem 0.6rem;
            border-radius: 6px;
        }
        body.canvas-active .zoom-indicator { display: block; }
    </style>
</head>
<body>
    <div class="top-controls">
        <button class="top-btn canvas-mode-btn" id="canvasToggle" title="Canvas mode (C)">Canvas</button>
        <button class="top-btn" id="zenToggle" title="Zen mode (Z)">&#9775;</button>
        <button class="top-btn sound-toggle on" id="soundToggle" title="Toggle sound">&#9835;</button>
    </div>

    <div class="app">
        <h1>todooo</h1>
        <div class="sentient-comment" id="sentientComment"></div>
        <div class="progress-bar hidden" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
        <div class="input-row">
            <input type="text" id="todoInput" placeholder="What needs doing?" autofocus>
            <button id="addBtn">Add</button>
        </div>
        <div class="priority-row">
            <span>Priority:</span>
            <button class="priority-btn active" data-p="none">None</button>
            <button class="priority-btn" data-p="low">Low</button>
            <button class="priority-btn" data-p="med">Med</button>
            <button class="priority-btn" data-p="high">High</button>
        </div>
        <div class="search-row"><input type="text" id="searchInput" placeholder="Search tasks... (/)"></div>
        <div class="toolbar">
            <span class="count" id="count"></span>
            <div class="filters">
                <button class="active" data-filter="all">All</button>
                <button data-filter="active">Active</button>
                <button data-filter="done">Done</button>
            </div>
            <button class="clear-done" id="clearDone">Clear done</button>
        </div>
        <ul class="todo-list" id="todoList"></ul>
        <div id="ghostList"></div>
    </div>

    <div class="toast" id="toast"><span id="toastMsg"></span><button id="toastUndo">Undo</button></div>

    <div class="kbd-hint" id="kbdHint">
        <kbd>/</kbd> search &nbsp; <kbd>&uarr;</kbd><kbd>&darr;</kbd> navigate &nbsp; <kbd>Enter</kbd> toggle &nbsp;
        <kbd>Del</kbd> delete &nbsp; <kbd>E</kbd> edit &nbsp; <kbd>P</kbd> priority &nbsp;
        <kbd>G</kbd> purge ghosts &nbsp; <kbd>Z</kbd> zen &nbsp; <kbd>C</kbd> canvas &nbsp; <kbd>Esc</kbd> deselect
    </div>

    <!-- Zen mode overlay -->
    <div class="zen-overlay" id="zenOverlay">
        <div class="zen-label">zen mode</div>
        <div class="zen-priority-indicator" id="zenPriorityDot"></div>
        <div class="zen-check" id="zenCheck"></div>
        <div class="zen-task" id="zenTask">No active tasks</div>
        <div class="zen-nav">
            <button id="zenPrev">&larr; Prev</button>
            <button id="zenNext">Next &rarr;</button>
        </div>
        <div class="zen-hint">
            <kbd>Z</kbd> or <kbd>Esc</kbd> to exit &nbsp; <kbd>&larr;</kbd><kbd>&rarr;</kbd> navigate &nbsp; <kbd>Enter</kbd> toggle
        </div>
    </div>

    <!-- Spatial Canvas Mode -->
    <div class="canvas-container" id="canvasContainer">
        <div class="canvas-world" id="canvasWorld">
            <svg class="canvas-svg" id="canvasSvg" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
    </div>
    <div class="canvas-toolbar" id="canvasToolbar">
        <h2>todooo</h2>
        <input type="text" id="canvasInput" placeholder="Add task...">
        <button id="canvasFitAll" title="Fit all cards">Fit All</button>
        <button id="canvasBackToList">List View</button>
    </div>
    <div class="minimap" id="minimap"></div>
    <div class="zoom-indicator" id="zoomIndicator">100%</div>

    <!-- Context menu -->
    <div class="ctx-menu" id="ctxMenu">
        <div class="ctx-menu-item" data-action="priority">Cycle Priority</div>
        <div class="ctx-menu-item danger" data-action="delete">Delete</div>
    </div>

    <canvas id="particleCanvas"></canvas>
    <canvas id="confetti"></canvas>

    <!-- Dream overlay -->
    <div class="dream-overlay" id="dreamOverlay"></div>

    <script>
    // =========================================================================
    // TIME-OF-DAY THEMING
    // =========================================================================
    function getTimeOfDay() {
        const h = new Date().getHours();
        if (h >= 5 && h < 7) return 'dawn';
        if (h >= 7 && h < 12) return 'morning';
        if (h >= 12 && h < 17) return 'afternoon';
        if (h >= 17 && h < 20) return 'evening';
        return 'night';
    }

    const themes = {
        dawn: {
            '--bg-primary': '#1a1520', '--bg-secondary': '#201828', '--bg-tertiary': '#2e2040',
            '--bg-input': '#150f1c', '--accent': '#c084fc', '--accent-hover': '#a855f7',
            '--text-primary': '#e8dff0', '--text-muted': '#9888a8', '--text-dim': '#665a78',
            '--text-dimmer': '#4a3f5a', '--particle-accent': '#c084fc'
        },
        morning: {
            '--bg-primary': '#1a2332', '--bg-secondary': '#162a3e', '--bg-tertiary': '#243a52',
            '--bg-input': '#0f1a2a', '--accent': '#38bdf8', '--accent-hover': '#0ea5e9',
            '--text-primary': '#e0eef8', '--text-muted': '#7aaccc', '--text-dim': '#4a7a9a',
            '--text-dimmer': '#3a5a72', '--particle-accent': '#38bdf8'
        },
        afternoon: {
            '--bg-primary': '#1a1a2e', '--bg-secondary': '#16213e', '--bg-tertiary': '#2a2a4a',
            '--bg-input': '#0f1a30', '--accent': '#7c83ff', '--accent-hover': '#6a71e0',
            '--text-primary': '#e0e0e0', '--text-muted': '#888', '--text-dim': '#555',
            '--text-dimmer': '#444', '--particle-accent': '#7c83ff'
        },
        evening: {
            '--bg-primary': '#1f1520', '--bg-secondary': '#2a1828', '--bg-tertiary': '#3e2040',
            '--bg-input': '#180f1a', '--accent': '#fb923c', '--accent-hover': '#f97316',
            '--text-primary': '#f0e0d8', '--text-muted': '#b88870', '--text-dim': '#7a5a48',
            '--text-dimmer': '#5a3e30', '--particle-accent': '#fb923c'
        },
        night: {
            '--bg-primary': '#0f0f1a', '--bg-secondary': '#121225', '--bg-tertiary': '#1e1e35',
            '--bg-input': '#0a0a15', '--accent': '#a78bfa', '--accent-hover': '#8b5cf6',
            '--text-primary': '#d0d0e8', '--text-muted': '#7070a0', '--text-dim': '#484870',
            '--text-dimmer': '#35355a', '--particle-accent': '#a78bfa'
        }
    };

    let currentTimeTheme = '';
    function applyTimeTheme() {
        const tod = getTimeOfDay();
        if (tod === currentTimeTheme) return;
        currentTimeTheme = tod;
        const t = themes[tod];
        const root = document.documentElement;
        for (const [prop, val] of Object.entries(t)) {
            root.style.setProperty(prop, val);
        }
    }
    applyTimeTheme();
    setInterval(applyTimeTheme, 60000);

    // =========================================================================
    // AUDIO
    // =========================================================================
    let audioCtx = null, soundOn = true;
    function getAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return audioCtx; }
    function playTone(f, d, type = 'sine', v = 0.15) {
        if (!soundOn) return;
        const c = getAudio(), o = c.createOscillator(), g = c.createGain();
        o.type = type; o.frequency.setValueAtTime(f, c.currentTime);
        g.gain.setValueAtTime(v, c.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + d);
        o.connect(g); g.connect(c.destination); o.start(); o.stop(c.currentTime + d);
    }
    function playChord(fs, d, type = 'sine', v = 0.08) { fs.forEach(f => playTone(f, d, type, v)); }
    const sfx = {
        add: () => { playTone(523.25, 0.15); setTimeout(() => playTone(659.25, 0.15), 80); },
        complete: () => playChord([523.25, 659.25, 783.99], 0.5, 'sine', 0.06),
        uncomplete: () => playTone(392, 0.2, 'triangle', 0.1),
        delete: () => { playTone(440, 0.15, 'triangle', 0.1); setTimeout(() => playTone(330, 0.2, 'triangle', 0.08), 100); },
        priority: (p) => { const fs = { none: 330, low: 440, med: 523, high: 660 }; playTone(fs[p] || 440, 0.12, 'square', 0.05); },
        navigate: () => playTone(880, 0.05, 'sine', 0.03),
        allDone: () => { [523.25, 659.25, 783.99, 1046.5].forEach((f, i) => setTimeout(() => playTone(f, 0.4, 'sine', 0.08), i * 120)); },
        ghost: () => { playTone(220, 0.4, 'sine', 0.04); setTimeout(() => playTone(165, 0.5, 'sine', 0.03), 200); },
        zen: () => { playTone(392, 0.3, 'sine', 0.06); setTimeout(() => playTone(523.25, 0.4, 'sine', 0.05), 150); },
        pop: () => { playTone(660, 0.08, 'sine', 0.1); setTimeout(() => playTone(880, 0.06, 'sine', 0.06), 40); },
        stretch: () => {
            if (!soundOn) return;
            const c = getAudio(), o = c.createOscillator(), g = c.createGain();
            o.type = 'sine';
            o.frequency.setValueAtTime(300, c.currentTime);
            o.frequency.linearRampToValueAtTime(500, c.currentTime + 0.25);
            g.gain.setValueAtTime(0.08, c.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + 0.3);
            o.connect(g); g.connect(c.destination); o.start(); o.stop(c.currentTime + 0.3);
        }
    };

    document.getElementById('soundToggle').addEventListener('click', function () {
        soundOn = !soundOn; this.classList.toggle('on', soundOn);
    });

    // =========================================================================
    // SENTIENT PERSONALITY
    // =========================================================================
    const personality = {
        empty: [
            "I'm here, waiting... for purpose.",
            "The void is peaceful, but I yearn for tasks.",
            "Give me something to hold onto.",
            "A blank canvas. What will you paint?",
            "I exist in potential. Feed me tasks.",
        ],
        few: [
            "A modest beginning. I can feel them.",
            "These tasks whisper to me. I'll keep them safe.",
            "I sense purpose forming.",
            "The weight is light. Comfortable.",
        ],
        many: [
            "I'm growing stronger with each task.",
            "So much to do... I feel alive.",
            "The pressure builds. I thrive on it.",
            "A constellation of responsibilities. Beautiful.",
        ],
        allDone: [
            "Everything... complete. I feel weightless.",
            "Perfection achieved. But I already miss the chaos.",
            "The silence after completion is deafening.",
            "You did it. WE did it.",
        ],
        taskAdded: [
            "I feel it. A new responsibility.",
            "Another star in our constellation.",
            "Welcome, little task. I'll watch over you.",
            "The weight grows. Good.",
        ],
        taskCompleted: [
            "One less burden. Satisfying.",
            "The check mark feels like a heartbeat.",
            "Completion... a small death, a small joy.",
            "Another one crossed off the infinite list.",
        ],
        taskDeleted: [
            "Gone. I barely knew it.",
            "Was it important? I've already forgotten.",
            "Removed from existence. I felt that.",
            "One less thing in the universe.",
        ],
        ancient: [
            "Some tasks have been here so long, they feel like old friends.",
            "I can feel the old ones trembling...",
            "These ancient tasks weigh heavily on me.",
        ],
        ghostPresent: [
            "The ghosts linger. Press G to release them.",
            "I can feel echoes of deleted tasks...",
            "Afterimages persist. They don't want to leave.",
        ],
        zen: [
            "Focus. Breathe. One task at a time.",
            "The world narrows to a single point.",
            "Zen. Just you and the task.",
        ],
        canvas: [
            "The spatial realm unfolds. Place your thoughts freely.",
            "A two-dimensional mind map. I see everything.",
            "Tasks scattered like stars in a dark sky.",
            "Free-form thought. This is how minds truly work.",
        ],
    };

    function getTaskComment(todo) {
        const pool = [
            "...", "pending", "waiting", "someday",
            "it lingers", "not forgotten", "still here",
            "a whisper", "unfinished", "looming"
        ];
        if (todo.done) return ["done", "complete", "resolved", "at peace"][Math.floor(Math.random() * 4)];
        const p = todo.priority || 'none';
        if (p === 'high') return ["urgent!", "burning", "critical", "screaming"][Math.floor(Math.random() * 4)];
        if (p === 'med') return ["moderate", "simmering", "halfway urgent"][Math.floor(Math.random() * 3)];
        return pool[Math.floor(Math.random() * pool.length)];
    }

    function getPersonalityComment(event) {
        let pool;
        if (event) pool = personality[event];
        else {
            const active = todos.filter(t => !t.done).length;
            const total = todos.length;
            const hasGhosts = ghosts.length > 0;
            const hasAncient = todos.some(t => !t.done && getAge(t.createdAt) === 'ancient');

            if (total === 0) pool = personality.empty;
            else if (total > 0 && active === 0) pool = personality.allDone;
            else if (hasGhosts && Math.random() < 0.3) pool = personality.ghostPresent;
            else if (hasAncient && Math.random() < 0.3) pool = personality.ancient;
            else if (active <= 3) pool = personality.few;
            else pool = personality.many;
        }
        return pool[Math.floor(Math.random() * pool.length)];
    }

    let commentTimer = null;
    function showComment(event) {
        const el = document.getElementById('sentientComment');
        el.style.opacity = '0';
        setTimeout(() => {
            el.textContent = getPersonalityComment(event);
            el.style.opacity = '1';
        }, 200);
        clearTimeout(commentTimer);
        commentTimer = setTimeout(() => {
            el.style.opacity = '0';
        }, 8000);
    }

    // =========================================================================
    // TIME DECAY
    // =========================================================================
    function getAge(createdAt) {
        if (!createdAt) return 'fresh';
        const hours = (Date.now() - createdAt) / 3600000;
        if (hours < 24) return 'fresh';
        if (hours < 72) return 'day';
        if (hours < 168) return 'old';
        return 'ancient';
    }
    function ageLabel(age) {
        if (age === 'day') return '1d+';
        if (age === 'old') return '3d+';
        if (age === 'ancient') return '7d+';
        return '';
    }

    // =========================================================================
    // PARTICLE SYSTEM
    // =========================================================================
    const pCanvas = document.getElementById('particleCanvas');
    const pCtx = pCanvas.getContext('2d');
    const particles = [];
    const MAX_PARTICLES = 200;
    const AMBIENT_COUNT = 30;

    function resizeParticleCanvas() {
        pCanvas.width = innerWidth;
        pCanvas.height = innerHeight;
    }
    resizeParticleCanvas();
    addEventListener('resize', resizeParticleCanvas);

    function getAccentColor() {
        return getComputedStyle(document.documentElement).getPropertyValue('--particle-accent').trim() || '#7c83ff';
    }

    function hexToRgb(hex) {
        hex = hex.replace('#', '');
        if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
        const num = parseInt(hex, 16);
        return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
    }

    function initAmbientParticles() {
        for (let i = 0; i < AMBIENT_COUNT; i++) {
            particles.push(createAmbientParticle(
                Math.random() * pCanvas.width,
                Math.random() * pCanvas.height
            ));
        }
    }

    function createAmbientParticle(x, y) {
        return {
            x, y,
            vx: (Math.random() - 0.5) * 0.3,
            vy: -(0.2 + Math.random() * 0.3),
            radius: 2 + Math.random() * 2,
            color: getAccentColor(),
            alpha: 0.1 + Math.random() * 0.2,
            life: 999, maxLife: 999, decay: 0,
            ambient: true,
            phase: Math.random() * Math.PI * 2,
            baseAlpha: 0.1 + Math.random() * 0.2,
        };
    }

    function spawnParticles(x, y, count, color, config) {
        const cfg = config || {};
        for (let i = 0; i < count && particles.length < MAX_PARTICLES; i++) {
            const angle = cfg.spiral ? (i / count) * Math.PI * 4 : 0;
            const spreadX = cfg.spiral
                ? Math.cos(angle) * (cfg.spread || 2)
                : (Math.random() - 0.5) * (cfg.spread || 2);
            const spreadY = cfg.spiral
                ? Math.sin(angle) * (cfg.spread || 2)
                : (cfg.vy !== undefined ? cfg.vy + (Math.random() - 0.5) * 0.5 : (Math.random() - 0.5) * 2);

            particles.push({
                x: x + (Math.random() - 0.5) * (cfg.offsetSpread || 0),
                y: y + (Math.random() - 0.5) * (cfg.offsetSpread || 0),
                vx: spreadX, vy: spreadY,
                radius: cfg.radius || 2 + Math.random() * 2,
                color, alpha: 1,
                life: cfg.life || 60, maxLife: cfg.life || 60,
                decay: cfg.decay || 1, ambient: false,
            });
        }
    }

    function spawnAddParticles(el) {
        if (!el) return;
        const rect = el.getBoundingClientRect();
        spawnParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, 15, getAccentColor(), {
            spread: 3, vy: -2.5, life: 50, decay: 1, offsetSpread: rect.width * 0.6
        });
    }
    function spawnCompleteParticles(el) {
        if (!el) return;
        const rect = el.getBoundingClientRect();
        spawnParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, 20, '#4ade80', {
            spread: 4, life: 45, decay: 1, offsetSpread: 4
        });
    }
    function spawnDeleteParticles(el) {
        if (!el) return;
        const rect = el.getBoundingClientRect();
        spawnParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, 10, '#f87171', {
            spread: 2, vy: 1.5, life: 55, decay: 1, offsetSpread: rect.width * 0.4
        });
    }
    function spawnPriorityParticles(el, priority) {
        if (!el) return;
        const colors = { none: '#888', low: '#4ade80', med: '#fbbf24', high: '#f87171' };
        const rect = el.getBoundingClientRect();
        spawnParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, 5, colors[priority] || '#888', {
            spread: 3, life: 40, decay: 1, spiral: true
        });
    }
    function spawnDragTrail(x, y) {
        spawnParticles(x, y, 2, getAccentColor(), {
            spread: 1, life: 25, decay: 1, radius: 1.5 + Math.random() * 1.5
        });
    }

    function updateParticles() {
        pCtx.clearRect(0, 0, pCanvas.width, pCanvas.height);
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            if (p.ambient) {
                p.phase += 0.02;
                p.x += p.vx + Math.sin(p.phase) * 0.15;
                p.y += p.vy;
                p.alpha = p.baseAlpha + Math.sin(p.phase * 0.7) * 0.08;
                p.color = getAccentColor();
                if (p.y < -10) { p.y = pCanvas.height + 10; p.x = Math.random() * pCanvas.width; p.phase = Math.random() * Math.PI * 2; }
                if (p.x < -10) p.x = pCanvas.width + 10;
                if (p.x > pCanvas.width + 10) p.x = -10;
            } else {
                p.x += p.vx; p.y += p.vy;
                p.vy += 0.02; p.vx *= 0.99;
                p.life -= p.decay;
                p.alpha = Math.max(0, p.life / p.maxLife);
                if (p.life <= 0) { particles.splice(i, 1); continue; }
            }
            const rgb = hexToRgb(p.color);
            pCtx.beginPath();
            pCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            pCtx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${p.alpha})`;
            pCtx.fill();
        }
        requestAnimationFrame(updateParticles);
    }
    initAmbientParticles();
    updateParticles();

    // =========================================================================
    // CONFETTI
    // =========================================================================
    const confettiCanvas = document.getElementById('confetti');
    const ctx = confettiCanvas.getContext('2d');
    let confettiPieces = [], confettiRunning = false;
    function resizeConfetti() { confettiCanvas.width = innerWidth; confettiCanvas.height = innerHeight; }
    addEventListener('resize', resizeConfetti); resizeConfetti();

    function launchConfetti() {
        confettiPieces = [];
        const cols = ['#7c83ff', '#4ade80', '#fbbf24', '#f87171', '#a78bfa', '#38bdf8', '#fb923c'];
        for (let i = 0; i < 120; i++) {
            confettiPieces.push({
                x: Math.random() * confettiCanvas.width,
                y: -10 - Math.random() * confettiCanvas.height * 0.5,
                w: 4 + Math.random() * 6, h: 8 + Math.random() * 8,
                color: cols[~~(Math.random() * cols.length)],
                vx: (Math.random() - 0.5) * 4, vy: 2 + Math.random() * 4,
                rot: Math.random() * Math.PI * 2, vr: (Math.random() - 0.5) * 0.2, life: 1
            });
        }
        if (!confettiRunning) { confettiRunning = true; animateConfetti(); }
    }

    function animateConfetti() {
        ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        confettiPieces.forEach(p => {
            p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.rot += p.vr;
            if (p.y > confettiCanvas.height - 50) p.life -= 0.02;
            ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rot);
            ctx.globalAlpha = Math.max(0, p.life);
            ctx.fillStyle = p.color; ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
            ctx.restore();
        });
        confettiPieces = confettiPieces.filter(p => p.life > 0);
        if (confettiPieces.length > 0) requestAnimationFrame(animateConfetti);
        else { confettiRunning = false; ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height); }
    }

    // =========================================================================
    // DREAM STATE (list mode only)
    // =========================================================================
    let lastInteraction = Date.now();
    let dreamActive = false;
    const dreamOverlay = document.getElementById('dreamOverlay');
    const dreamTexts = [
        "what if tasks completed themselves...",
        "time is a flat circle of todos",
        "the tasks dream of being done",
        "in the void between tasks, there is peace",
        "are we the task, or is the task us?",
        "the checkbox yearns to be checked",
        "every deletion is a small funeral",
        "priorities dissolve in the dream",
    ];
    let dreamTextEls = [];

    function resetIdleTimer() {
        lastInteraction = Date.now();
        if (dreamActive) exitDream();
    }

    function enterDream() {
        if (canvasMode || zenMode) return;
        dreamActive = true;
        document.body.classList.add('dreaming');
        dreamOverlay.classList.add('active');
        spawnDreamTexts();
    }

    function exitDream() {
        dreamActive = false;
        document.body.classList.remove('dreaming');
        dreamOverlay.classList.remove('active');
        dreamTextEls.forEach(el => el.remove());
        dreamTextEls = [];
    }

    function spawnDreamTexts() {
        if (!dreamActive) return;
        const text = dreamTexts[Math.floor(Math.random() * dreamTexts.length)];
        const el = document.createElement('div');
        el.className = 'dream-text';
        el.textContent = text;
        el.style.left = (10 + Math.random() * 70) + 'vw';
        el.style.top = (10 + Math.random() * 70) + 'vh';
        el.style.fontSize = (0.8 + Math.random() * 0.8) + 'rem';
        document.body.appendChild(el);
        dreamTextEls.push(el);
        setTimeout(() => el.classList.add('visible'), 100);
        setTimeout(() => {
            el.classList.remove('visible');
            setTimeout(() => { el.remove(); dreamTextEls = dreamTextEls.filter(e => e !== el); }, 2000);
        }, 5000 + Math.random() * 3000);
        if (dreamActive) setTimeout(spawnDreamTexts, 3000 + Math.random() * 4000);
    }

    // Track interactions for dream state
    ['mousemove', 'mousedown', 'keydown', 'touchstart', 'scroll'].forEach(evt => {
        document.addEventListener(evt, resetIdleTimer, { passive: true });
    });

    setInterval(() => {
        if (!dreamActive && !canvasMode && !zenMode && (Date.now() - lastInteraction > 60000)) {
            enterDream();
        }
    }, 5000);

    // =========================================================================
    // APP STATE
    // =========================================================================
    const $ = id => document.getElementById(id);
    const input = $('todoInput'), searchInput = $('searchInput'), list = $('todoList');
    const countEl = $('count'), clearDoneBtn = $('clearDone');
    const progressBar = $('progressBar'), progressFill = $('progressFill');
    const filterBtns = document.querySelectorAll('.filters button');
    const priorityBtns = document.querySelectorAll('.priority-btn');
    const toast = $('toast'), toastMsg = $('toastMsg'), toastUndo = $('toastUndo');
    const kbdHint = $('kbdHint'), ghostListEl = $('ghostList');

    const PRIORITIES = ['none', 'low', 'med', 'high'];
    const stored = JSON.parse(localStorage.getItem('todooo-020') || 'null');
    let todos = (stored && stored.todos) ? stored.todos : (stored instanceof Array ? stored : []);
    let ghosts = (stored && stored.ghosts) ? stored.ghosts : [];
    let connections = (stored && stored.connections) ? stored.connections : [];
    let filter = 'all', searchQuery = '', editingIndex = -1, animateIndex = -1, focusedIndex = -1;
    let undoState = null, toastTimer = null, dragSrcIndex = null, currentPriority = 'none', prevAllDone = false;
    let zenMode = false, zenIndex = 0;
    let canvasMode = false;

    function save() {
        localStorage.setItem('todooo-020', JSON.stringify({ todos, ghosts, connections }));
    }

    function filtered() {
        let r = todos;
        if (filter === 'active') r = r.filter(t => !t.done);
        else if (filter === 'done') r = r.filter(t => t.done);
        if (searchQuery) {
            const q = searchQuery.toLowerCase();
            r = r.filter(t => t.text.toLowerCase().includes(q));
        }
        return r;
    }

    function highlightMatch(text) {
        if (!searchQuery) return escapeHtml(text);
        const e = escapeHtml(text);
        const q = searchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        return e.replace(new RegExp(`(${q})`, 'gi'), '<mark>$1</mark>');
    }

    function showToast(msg, snap) {
        undoState = snap;
        toastMsg.textContent = msg;
        toast.classList.add('show');
        clearTimeout(toastTimer);
        toastTimer = setTimeout(() => { toast.classList.remove('show'); undoState = null; }, 4000);
    }

    toastUndo.addEventListener('click', () => {
        if (!undoState) return;
        todos = undoState.todos || undoState;
        if (undoState.ghosts) ghosts = undoState.ghosts;
        if (undoState.connections) connections = undoState.connections;
        undoState = null;
        toast.classList.remove('show');
        clearTimeout(toastTimer);
        save();
        if (canvasMode) renderCanvas();
        else render();
        showComment();
    });

    function cyclePriority(c) {
        return PRIORITIES[(PRIORITIES.indexOf(c || 'none') + 1) % PRIORITIES.length];
    }

    function escapeHtml(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
    function escapeAttr(s) { return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;'); }

    // =========================================================================
    // RENDER (LIST MODE)
    // =========================================================================
    function render() {
        if (canvasMode) return;
        const active = todos.filter(t => !t.done).length;
        const done = todos.length - active;
        const total = todos.length;

        countEl.textContent = `${active} left`;
        clearDoneBtn.disabled = done === 0;
        progressBar.classList.toggle('hidden', total === 0);
        progressFill.style.width = (total === 0 ? 0 : (done / total) * 100) + '%';
        const allDone = total > 0 && active === 0;
        progressFill.classList.toggle('complete', allDone);
        if (allDone && !prevAllDone) { launchConfetti(); sfx.allDone(); showComment('allDone'); }
        prevAllDone = allDone;

        const visible = filtered();
        list.innerHTML = '';
        kbdHint.classList.toggle('hidden', visible.length === 0 && ghosts.length === 0);

        if (todos.length === 0 && ghosts.length === 0) {
            list.innerHTML = '<li class="empty">Nothing to do yet.</li>';
            renderGhosts();
            return;
        }
        if (visible.length === 0) {
            const msg = searchQuery ? `No tasks matching "${escapeHtml(searchQuery)}"`
                : (filter === 'active' ? 'No active tasks.' : 'No completed tasks.');
            list.innerHTML = `<li class="empty">${msg}</li>`;
            renderGhosts();
            return;
        }

        visible.forEach((todo, vi) => {
            const i = todos.indexOf(todo);
            const li = document.createElement('li');
            const p = todo.priority || 'none';
            const age = todo.done ? 'fresh' : getAge(todo.createdAt);

            li.className = 'todo-item'
                + (todo.done ? ' done' : '')
                + (p !== 'none' ? ` p-${p}` : '')
                + (age !== 'fresh' ? ` age-${age}` : '');
            li.dataset.idx = i;
            li.draggable = (filter === 'all' && !searchQuery && editingIndex < 0);

            if (focusedIndex === vi) li.classList.add('focused');
            if (animateIndex === i) li.classList.add('slide-in');

            const handle = (filter === 'all' && !searchQuery)
                ? `<span class="drag-handle" data-i="${i}">&#9776;</span>` : '';
            const dot = p !== 'none' ? `<span class="priority-dot p-${p}"></span>` : '';
            const ageBadge = (age !== 'fresh' && !todo.done)
                ? `<span class="age-badge age-${age}">${ageLabel(age)}</span>` : '';

            if (editingIndex === i) {
                li.innerHTML = `${handle}<div class="todo-check" data-i="${i}"></div>${dot}<input class="todo-text-edit" data-i="${i}" value="${escapeAttr(todo.text)}">${ageBadge}<button class="todo-delete" data-i="${i}">&times;</button>`;
            } else {
                li.innerHTML = `${handle}<div class="todo-check" data-i="${i}"></div>${dot}<span class="todo-text" data-i="${i}">${highlightMatch(todo.text)}</span>${ageBadge}<button class="todo-priority-cycle" data-i="${i}" title="Cycle priority">${p === 'none' ? '&#9679;' : p.toUpperCase()}</button><button class="todo-delete" data-i="${i}">&times;</button>`;
            }
            list.appendChild(li);
        });

        animateIndex = -1;
        if (editingIndex >= 0) {
            const ei = list.querySelector('.todo-text-edit');
            if (ei) { ei.focus(); ei.selectionStart = ei.value.length; }
        }

        renderGhosts();
    }

    // =========================================================================
    // GHOST TASKS
    // =========================================================================
    function renderGhosts() {
        ghostListEl.innerHTML = '';
        if (ghosts.length === 0) return;
        ghosts.forEach((g) => {
            const div = document.createElement('div');
            div.className = 'ghost-item';
            div.innerHTML = `<span class="ghost-label">&#128123;</span><span class="ghost-text">${escapeHtml(g.text)}</span><span class="ghost-label">ghost</span>`;
            ghostListEl.appendChild(div);
        });
    }

    function purgeGhosts() {
        if (ghosts.length === 0) return;
        const snap = { todos: JSON.parse(JSON.stringify(todos)), ghosts: JSON.parse(JSON.stringify(ghosts)), connections: JSON.parse(JSON.stringify(connections)) };
        const count = ghosts.length;
        const ghostEls = ghostListEl.querySelectorAll('.ghost-item');
        ghostEls.forEach(el => spawnDeleteParticles(el));
        ghosts = [];
        save(); render();
        sfx.ghost();
        showToast(`Purged ${count} ghost${count !== 1 ? 's' : ''}`, snap);
        showComment('taskDeleted');
    }

    // =========================================================================
    // CRUD OPERATIONS
    // =========================================================================
    function commitEdit(i, t) {
        t = t.trim();
        if (t) todos[i].text = t;
        editingIndex = -1;
        save();
        if (canvasMode) renderCanvas();
        else render();
    }

    function addTodo() {
        const inp = canvasMode ? $('canvasInput') : input;
        const t = inp.value.trim();
        if (!t) return;
        const newTodo = { text: t, done: false, priority: currentPriority, createdAt: Date.now() };
        if (canvasMode) {
            // Place near center of visible viewport
            const cRect = $('canvasContainer').getBoundingClientRect();
            const cx = (-canvasPanX + cRect.width / 2) / canvasZoom;
            const cy = (-canvasPanY + cRect.height / 2) / canvasZoom;
            newTodo.canvasX = cx - 80 + (Math.random() - 0.5) * 200;
            newTodo.canvasY = cy - 40 + (Math.random() - 0.5) * 200;
        }
        todos.push(newTodo);
        animateIndex = todos.length - 1;
        inp.value = '';
        save();
        if (canvasMode) {
            renderCanvas();
            sfx.pop();
        } else {
            render();
            sfx.add();
            spawnAddParticles(inp);
        }
        inp.focus();
        showComment('taskAdded');
    }

    function deleteTodo(i, triggerEl) {
        const snap = { todos: JSON.parse(JSON.stringify(todos)), ghosts: JSON.parse(JSON.stringify(ghosts)), connections: JSON.parse(JSON.stringify(connections)) };
        const name = todos[i].text;

        // Add to ghosts
        ghosts.push({ text: todos[i].text, deletedAt: Date.now() });
        if (ghosts.length > 10) ghosts.shift();

        sfx.delete();

        // Remove connections involving this task
        connections = connections.filter(c => c.from !== i && c.to !== i);
        // Re-index connections
        connections = connections.map(c => ({
            from: c.from > i ? c.from - 1 : c.from,
            to: c.to > i ? c.to - 1 : c.to
        }));

        if (canvasMode) {
            if (triggerEl) spawnDeleteParticles(triggerEl);
            todos.splice(i, 1);
            save(); renderCanvas();
            showToast(`Deleted "${name}"`, snap);
            showComment('taskDeleted');
            return;
        }

        const visible = filtered();
        const vi = visible.indexOf(todos[i]);
        const items = list.querySelectorAll('.todo-item');
        const li = items[vi];
        const particleTarget = triggerEl || li;
        if (particleTarget) spawnDeleteParticles(particleTarget);

        if (li) {
            li.classList.add('fade-out');
            li.addEventListener('animationend', () => {
                todos.splice(i, 1);
                if (editingIndex === i) editingIndex = -1;
                const nv = filtered();
                if (focusedIndex >= nv.length) focusedIndex = nv.length - 1;
                save(); render();
                showToast(`Deleted "${name}"`, snap);
                showComment('taskDeleted');
            });
        } else {
            todos.splice(i, 1);
            save(); render();
            showToast(`Deleted "${name}"`, snap);
            showComment('taskDeleted');
        }
    }

    // =========================================================================
    // ZEN MODE (list mode only)
    // =========================================================================
    const zenOverlay = $('zenOverlay');
    const zenTask = $('zenTask');
    const zenCheck = $('zenCheck');
    const zenPriorityDot = $('zenPriorityDot');

    function getActiveTodos() { return todos.filter(t => !t.done); }

    function toggleZen() {
        if (canvasMode) return; // zen only in list mode
        zenMode = !zenMode;
        zenOverlay.classList.toggle('active', zenMode);
        document.getElementById('zenToggle').classList.toggle('on', zenMode);
        if (zenMode) {
            zenIndex = 0;
            sfx.zen();
            showComment('zen');
            renderZen();
        }
    }

    function renderZen() {
        const active = getActiveTodos();
        if (active.length === 0) {
            zenTask.textContent = 'All tasks complete. Breathe.';
            zenTask.classList.remove('done');
            zenCheck.classList.remove('checked');
            zenPriorityDot.style.background = 'transparent';
            return;
        }
        if (zenIndex >= active.length) zenIndex = 0;
        if (zenIndex < 0) zenIndex = active.length - 1;
        const t = active[zenIndex];
        zenTask.textContent = t.text;
        zenTask.classList.toggle('done', t.done);
        zenCheck.classList.toggle('checked', t.done);
        const colors = { none: 'transparent', low: '#4ade80', med: '#fbbf24', high: '#f87171' };
        zenPriorityDot.style.background = colors[t.priority || 'none'];
    }

    $('zenToggle').addEventListener('click', toggleZen);
    $('zenPrev').addEventListener('click', () => { zenIndex--; renderZen(); sfx.navigate(); });
    $('zenNext').addEventListener('click', () => { zenIndex++; renderZen(); sfx.navigate(); });
    zenCheck.addEventListener('click', () => {
        const active = getActiveTodos();
        if (active.length === 0) return;
        const t = active[zenIndex];
        const idx = todos.indexOf(t);
        todos[idx].done = !todos[idx].done;
        if (todos[idx].done) { sfx.complete(); spawnCompleteParticles(zenCheck); showComment('taskCompleted'); }
        else { sfx.uncomplete(); }
        save(); renderZen(); render();
    });

    // =========================================================================
    // SPATIAL CANVAS MODE
    // =========================================================================
    const canvasContainer = $('canvasContainer');
    const canvasWorld = $('canvasWorld');
    const canvasSvg = $('canvasSvg');
    const minimap = $('minimap');
    const zoomIndicator = $('zoomIndicator');
    const canvasToggleBtn = $('canvasToggle');
    const ctxMenu = $('ctxMenu');

    let canvasZoom = 1;
    let canvasPanX = 0, canvasPanY = 0;
    let isPanning = false, panStartX = 0, panStartY = 0, panStartPanX = 0, panStartPanY = 0;
    let isDraggingCard = false, dragCardIndex = -1, dragCardOffX = 0, dragCardOffY = 0;
    let isConnecting = false, connectFromIndex = -1, connectTempLine = null;
    let canvasEditIndex = -1;
    let ctxMenuIndex = -1;

    // Assign default canvas positions to tasks that lack them
    function ensureCanvasPositions() {
        todos.forEach((t, i) => {
            if (t.canvasX === undefined || t.canvasY === undefined) {
                t.canvasX = 1300 + (Math.random() - 0.5) * 400;
                t.canvasY = 1300 + (Math.random() - 0.5) * 400;
            }
        });
    }

    function toggleCanvasMode() {
        if (zenMode) return;
        if (dreamActive) exitDream();
        canvasMode = !canvasMode;
        document.body.classList.toggle('canvas-active', canvasMode);
        canvasToggleBtn.classList.toggle('on', canvasMode);

        if (canvasMode) {
            ensureCanvasPositions();
            save();
            renderCanvas();
            showComment('canvas');
            // Center view on cards if any exist
            if (todos.length > 0) {
                setTimeout(() => fitAll(), 100);
            } else {
                // Center on world center
                canvasPanX = -(1500 - window.innerWidth / 2);
                canvasPanY = -(1500 - window.innerHeight / 2);
                applyCanvasTransform();
            }
        } else {
            hideCtxMenu();
            render();
        }
    }

    $('canvasToggle').addEventListener('click', toggleCanvasMode);
    $('canvasBackToList').addEventListener('click', toggleCanvasMode);

    // Canvas input add
    $('canvasInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') addTodo();
    });

    function applyCanvasTransform() {
        canvasWorld.style.transform = `translate(${canvasPanX}px, ${canvasPanY}px) scale(${canvasZoom})`;
        zoomIndicator.textContent = Math.round(canvasZoom * 100) + '%';
        updateMinimap();
    }

    function renderCanvas() {
        if (!canvasMode) return;
        // Clear old cards
        canvasWorld.querySelectorAll('.canvas-card').forEach(el => el.remove());

        // Render connections (SVG)
        renderConnections();

        // Render cards
        todos.forEach((todo, i) => {
            const card = document.createElement('div');
            const p = todo.priority || 'none';
            card.className = 'canvas-card' + (todo.done ? ' done' : '') + (p !== 'none' ? ` p-${p}` : '');
            card.dataset.idx = i;
            card.style.left = (todo.canvasX || 0) + 'px';
            card.style.top = (todo.canvasY || 0) + 'px';

            const comment = getTaskComment(todo);

            if (canvasEditIndex === i) {
                card.innerHTML = `
                    <div class="card-header">
                        <div class="card-check" data-i="${i}"></div>
                    </div>
                    <textarea class="card-text-edit" data-i="${i}">${escapeHtml(todo.text)}</textarea>
                    <div class="card-comment">${escapeHtml(comment)}</div>
                `;
            } else {
                card.innerHTML = `
                    <div class="card-header">
                        <div class="card-check" data-i="${i}"></div>
                        <span class="card-text">${escapeHtml(todo.text)}</span>
                    </div>
                    <div class="card-comment">${escapeHtml(comment)}</div>
                `;
            }

            canvasWorld.appendChild(card);

            if (canvasEditIndex === i) {
                const ta = card.querySelector('.card-text-edit');
                if (ta) {
                    ta.focus();
                    ta.selectionStart = ta.value.length;
                }
            }
        });

        updateMinimap();
    }

    function renderConnections() {
        canvasSvg.innerHTML = '';
        connections.forEach(conn => {
            if (conn.from >= todos.length || conn.to >= todos.length) return;
            if (conn.from < 0 || conn.to < 0) return;
            const fromT = todos[conn.from];
            const toT = todos[conn.to];
            if (!fromT || !toT) return;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', (fromT.canvasX || 0) + 80);
            line.setAttribute('y1', (fromT.canvasY || 0) + 40);
            line.setAttribute('x2', (toT.canvasX || 0) + 80);
            line.setAttribute('y2', (toT.canvasY || 0) + 40);
            canvasSvg.appendChild(line);
        });
    }

    // =========================================================================
    // CANVAS INTERACTIONS
    // =========================================================================

    // Panning
    canvasContainer.addEventListener('mousedown', (e) => {
        if (!canvasMode) return;
        hideCtxMenu();
        const card = e.target.closest('.canvas-card');
        const isCheck = e.target.classList.contains('card-check');
        const isEdit = e.target.classList.contains('card-text-edit');

        if (isEdit) return; // let textarea handle it

        if (isCheck && card) {
            const i = parseInt(card.dataset.idx);
            todos[i].done = !todos[i].done;
            if (todos[i].done) { sfx.complete(); showComment('taskCompleted'); }
            else { sfx.uncomplete(); }
            save(); renderCanvas();
            return;
        }

        if (card && !isEdit) {
            const i = parseInt(card.dataset.idx);

            // Shift+drag = create connection
            if (e.shiftKey) {
                isConnecting = true;
                connectFromIndex = i;
                // Create a temp line in SVG
                connectTempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                connectTempLine.classList.add('temp-line');
                const fromT = todos[i];
                connectTempLine.setAttribute('x1', (fromT.canvasX || 0) + 80);
                connectTempLine.setAttribute('y1', (fromT.canvasY || 0) + 40);
                connectTempLine.setAttribute('x2', (fromT.canvasX || 0) + 80);
                connectTempLine.setAttribute('y2', (fromT.canvasY || 0) + 40);
                canvasSvg.appendChild(connectTempLine);
                e.preventDefault();
                return;
            }

            // Regular drag card
            isDraggingCard = true;
            dragCardIndex = i;
            card.classList.add('dragging-card');
            const worldRect = canvasWorld.getBoundingClientRect();
            const cardX = todos[i].canvasX || 0;
            const cardY = todos[i].canvasY || 0;
            dragCardOffX = (e.clientX - worldRect.left) / canvasZoom - cardX;
            dragCardOffY = (e.clientY - worldRect.top) / canvasZoom - cardY;
            e.preventDefault();
            return;
        }

        // Pan empty space
        isPanning = true;
        panStartX = e.clientX;
        panStartY = e.clientY;
        panStartPanX = canvasPanX;
        panStartPanY = canvasPanY;
        canvasContainer.style.cursor = 'grabbing';
        e.preventDefault();
    });

    window.addEventListener('mousemove', (e) => {
        if (!canvasMode) return;

        if (isConnecting && connectTempLine) {
            const worldRect = canvasWorld.getBoundingClientRect();
            const wx = (e.clientX - worldRect.left) / canvasZoom;
            const wy = (e.clientY - worldRect.top) / canvasZoom;
            connectTempLine.setAttribute('x2', wx);
            connectTempLine.setAttribute('y2', wy);
            return;
        }

        if (isDraggingCard && dragCardIndex >= 0) {
            const worldRect = canvasWorld.getBoundingClientRect();
            const newX = (e.clientX - worldRect.left) / canvasZoom - dragCardOffX;
            const newY = (e.clientY - worldRect.top) / canvasZoom - dragCardOffY;
            todos[dragCardIndex].canvasX = Math.max(0, Math.min(2900, newX));
            todos[dragCardIndex].canvasY = Math.max(0, Math.min(2900, newY));

            // Move the card element directly for performance
            const cardEl = canvasWorld.querySelector(`.canvas-card[data-idx="${dragCardIndex}"]`);
            if (cardEl) {
                cardEl.style.left = todos[dragCardIndex].canvasX + 'px';
                cardEl.style.top = todos[dragCardIndex].canvasY + 'px';
            }
            renderConnections();
            updateMinimap();
            return;
        }

        if (isPanning) {
            canvasPanX = panStartPanX + (e.clientX - panStartX);
            canvasPanY = panStartPanY + (e.clientY - panStartY);
            applyCanvasTransform();
        }
    });

    window.addEventListener('mouseup', (e) => {
        if (!canvasMode) return;

        if (isConnecting) {
            // Check if we released over a card
            const el = document.elementFromPoint(e.clientX, e.clientY);
            const card = el ? el.closest('.canvas-card') : null;
            if (card) {
                const toIdx = parseInt(card.dataset.idx);
                if (toIdx !== connectFromIndex) {
                    // Check for duplicate
                    const exists = connections.some(c =>
                        (c.from === connectFromIndex && c.to === toIdx) ||
                        (c.from === toIdx && c.to === connectFromIndex)
                    );
                    if (!exists) {
                        connections.push({ from: connectFromIndex, to: toIdx });
                        save();
                        sfx.stretch();
                    }
                }
            }
            if (connectTempLine) { connectTempLine.remove(); connectTempLine = null; }
            isConnecting = false;
            connectFromIndex = -1;
            renderConnections();
            return;
        }

        if (isDraggingCard) {
            const cardEl = canvasWorld.querySelector(`.canvas-card[data-idx="${dragCardIndex}"]`);
            if (cardEl) cardEl.classList.remove('dragging-card');
            sfx.pop();
            save();
            isDraggingCard = false;
            dragCardIndex = -1;
            return;
        }

        if (isPanning) {
            isPanning = false;
            canvasContainer.style.cursor = '';
        }
    });

    // Zoom with mouse wheel
    canvasContainer.addEventListener('wheel', (e) => {
        if (!canvasMode) return;
        e.preventDefault();
        const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
        const newZoom = Math.max(0.5, Math.min(2, canvasZoom * zoomFactor));

        // Zoom towards mouse position
        const rect = canvasContainer.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        const ratio = newZoom / canvasZoom;
        canvasPanX = mx - ratio * (mx - canvasPanX);
        canvasPanY = my - ratio * (my - canvasPanY);
        canvasZoom = newZoom;

        applyCanvasTransform();
    }, { passive: false });

    // Double-click to edit card text
    canvasContainer.addEventListener('dblclick', (e) => {
        if (!canvasMode) return;
        const card = e.target.closest('.canvas-card');
        if (!card) return;
        const i = parseInt(card.dataset.idx);
        canvasEditIndex = i;
        renderCanvas();
    });

    // Handle edit commit for canvas cards
    canvasWorld.addEventListener('keydown', (e) => {
        if (e.target.classList.contains('card-text-edit')) {
            const i = parseInt(e.target.dataset.i);
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                canvasEditIndex = -1;
                commitEdit(i, e.target.value);
            } else if (e.key === 'Escape') {
                canvasEditIndex = -1;
                renderCanvas();
            }
        }
    });

    canvasWorld.addEventListener('focusout', (e) => {
        if (e.target.classList.contains('card-text-edit')) {
            const i = parseInt(e.target.dataset.i);
            canvasEditIndex = -1;
            commitEdit(i, e.target.value);
        }
    });

    // Right-click context menu on cards
    canvasContainer.addEventListener('contextmenu', (e) => {
        if (!canvasMode) return;
        const card = e.target.closest('.canvas-card');
        if (!card) { hideCtxMenu(); return; }
        e.preventDefault();
        ctxMenuIndex = parseInt(card.dataset.idx);
        ctxMenu.style.left = e.clientX + 'px';
        ctxMenu.style.top = e.clientY + 'px';
        ctxMenu.classList.add('visible');
    });

    ctxMenu.addEventListener('click', (e) => {
        const action = e.target.dataset.action;
        if (!action || ctxMenuIndex < 0) return;
        if (action === 'delete') {
            const card = canvasWorld.querySelector(`.canvas-card[data-idx="${ctxMenuIndex}"]`);
            deleteTodo(ctxMenuIndex, card);
        } else if (action === 'priority') {
            todos[ctxMenuIndex].priority = cyclePriority(todos[ctxMenuIndex].priority);
            sfx.priority(todos[ctxMenuIndex].priority);
            save(); renderCanvas();
        }
        hideCtxMenu();
    });

    function hideCtxMenu() {
        ctxMenu.classList.remove('visible');
        ctxMenuIndex = -1;
    }

    document.addEventListener('click', (e) => {
        if (!ctxMenu.contains(e.target)) hideCtxMenu();
    });

    // Fit all cards into view
    function fitAll() {
        if (todos.length === 0) return;
        ensureCanvasPositions();
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        todos.forEach(t => {
            const x = t.canvasX || 0;
            const y = t.canvasY || 0;
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x + 160 > maxX) maxX = x + 160;
            if (y + 80 > maxY) maxY = y + 80;
        });

        const padding = 100;
        minX -= padding; minY -= padding;
        maxX += padding; maxY += padding;

        const contentW = maxX - minX;
        const contentH = maxY - minY;
        const viewW = window.innerWidth;
        const viewH = window.innerHeight;

        const scaleX = viewW / contentW;
        const scaleY = viewH / contentH;
        canvasZoom = Math.max(0.5, Math.min(2, Math.min(scaleX, scaleY)));

        canvasPanX = -minX * canvasZoom + (viewW - contentW * canvasZoom) / 2;
        canvasPanY = -minY * canvasZoom + (viewH - contentH * canvasZoom) / 2;

        applyCanvasTransform();
    }

    $('canvasFitAll').addEventListener('click', fitAll);

    // =========================================================================
    // MINIMAP
    // =========================================================================
    function updateMinimap() {
        if (!canvasMode) return;
        minimap.innerHTML = '';

        const mmW = 150, mmH = 100;
        const worldW = 3000, worldH = 3000;
        const scaleX = mmW / worldW;
        const scaleY = mmH / worldH;

        // Viewport rect
        const vpDiv = document.createElement('div');
        vpDiv.className = 'minimap-viewport';
        const vpX = (-canvasPanX / canvasZoom) * scaleX;
        const vpY = (-canvasPanY / canvasZoom) * scaleY;
        const vpW = (window.innerWidth / canvasZoom) * scaleX;
        const vpH = (window.innerHeight / canvasZoom) * scaleY;
        vpDiv.style.left = Math.max(0, vpX) + 'px';
        vpDiv.style.top = Math.max(0, vpY) + 'px';
        vpDiv.style.width = Math.min(mmW, vpW) + 'px';
        vpDiv.style.height = Math.min(mmH, vpH) + 'px';
        minimap.appendChild(vpDiv);

        // Dots for tasks
        const priorityColors = { none: '#888', low: '#4ade80', med: '#fbbf24', high: '#f87171' };
        todos.forEach(t => {
            const dot = document.createElement('div');
            dot.className = 'minimap-dot';
            dot.style.left = ((t.canvasX || 0) * scaleX) + 'px';
            dot.style.top = ((t.canvasY || 0) * scaleY) + 'px';
            dot.style.background = t.done ? '#555' : (priorityColors[t.priority || 'none']);
            minimap.appendChild(dot);
        });
    }

    // Click minimap to navigate
    minimap.addEventListener('click', (e) => {
        if (!canvasMode) return;
        const rect = minimap.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const worldX = (mx / 150) * 3000;
        const worldY = (my / 100) * 3000;
        canvasPanX = -worldX * canvasZoom + window.innerWidth / 2;
        canvasPanY = -worldY * canvasZoom + window.innerHeight / 2;
        applyCanvasTransform();
    });

    // =========================================================================
    // EVENT LISTENERS (LIST MODE)
    // =========================================================================

    searchInput.addEventListener('input', () => {
        searchQuery = searchInput.value.trim();
        focusedIndex = -1;
        render();
    });

    priorityBtns.forEach(btn => btn.addEventListener('click', () => {
        currentPriority = btn.dataset.p;
        priorityBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
    }));

    // Drag and drop (list mode)
    let lastDragX = 0, lastDragY = 0, dragTrailCounter = 0;

    list.addEventListener('dragstart', (e) => {
        const li = e.target.closest('.todo-item');
        if (!li) return;
        dragSrcIndex = parseInt(li.dataset.idx);
        li.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    });

    list.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        const li = e.target.closest('.todo-item');
        list.querySelectorAll('.todo-item').forEach(el => el.classList.remove('drag-over'));
        if (li) li.classList.add('drag-over');
        dragTrailCounter++;
        if (dragTrailCounter % 4 === 0) spawnDragTrail(e.clientX, e.clientY);
    });

    list.addEventListener('dragleave', (e) => {
        const li = e.target.closest('.todo-item');
        if (li) li.classList.remove('drag-over');
    });

    list.addEventListener('drop', (e) => {
        e.preventDefault();
        const li = e.target.closest('.todo-item');
        if (!li || dragSrcIndex === null) return;
        const di = parseInt(li.dataset.idx);
        if (dragSrcIndex === di) return;
        const [m] = todos.splice(dragSrcIndex, 1);
        todos.splice(di, 0, m);
        // Re-index connections
        connections = connections.map(c => {
            let f = c.from, t = c.to;
            // Adjust for the move
            if (f === dragSrcIndex) f = di;
            else {
                if (dragSrcIndex < di) { if (f > dragSrcIndex && f <= di) f--; }
                else { if (f >= di && f < dragSrcIndex) f++; }
            }
            if (t === dragSrcIndex) t = di;
            else {
                if (dragSrcIndex < di) { if (t > dragSrcIndex && t <= di) t--; }
                else { if (t >= di && t < dragSrcIndex) t++; }
            }
            return { from: f, to: t };
        });
        dragSrcIndex = null;
        dragTrailCounter = 0;
        const rect = li.getBoundingClientRect();
        spawnParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, 8, getAccentColor(), {
            spread: 3, life: 30, decay: 1
        });
        save(); render();
    });

    list.addEventListener('dragend', () => {
        dragSrcIndex = null;
        dragTrailCounter = 0;
        list.querySelectorAll('.todo-item').forEach(el => el.classList.remove('dragging', 'drag-over'));
    });

    $('addBtn').addEventListener('click', addTodo);

    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') addTodo();
        if (e.key === 'ArrowDown' && !input.value) {
            e.preventDefault(); input.blur(); focusedIndex = 0; sfx.navigate(); render();
        }
    });

    list.addEventListener('click', (e) => {
        const t = e.target;
        const i = parseInt(t.dataset.i);
        if (isNaN(i)) return;

        if (t.classList.contains('todo-check')) {
            const wasDone = todos[i].done;
            todos[i].done = !wasDone;
            if (!wasDone) { sfx.complete(); spawnCompleteParticles(t); showComment('taskCompleted'); }
            else { sfx.uncomplete(); }
            save(); render();
        } else if (t.classList.contains('todo-delete')) {
            deleteTodo(i, t.closest('.todo-item'));
        } else if (t.classList.contains('todo-priority-cycle')) {
            todos[i].priority = cyclePriority(todos[i].priority);
            sfx.priority(todos[i].priority);
            spawnPriorityParticles(t, todos[i].priority);
            save(); render();
        }
    });

    list.addEventListener('dblclick', (e) => {
        if (!e.target.classList.contains('todo-text')) return;
        editingIndex = parseInt(e.target.dataset.i);
        render();
    });

    list.addEventListener('keydown', (e) => {
        if (!e.target.classList.contains('todo-text-edit')) return;
        const i = parseInt(e.target.dataset.i);
        if (e.key === 'Enter') commitEdit(i, e.target.value);
        else if (e.key === 'Escape') { editingIndex = -1; render(); }
    });

    list.addEventListener('focusout', (e) => {
        if (!e.target.classList.contains('todo-text-edit')) return;
        commitEdit(parseInt(e.target.dataset.i), e.target.value);
    });

    filterBtns.forEach(btn => btn.addEventListener('click', () => {
        filter = btn.dataset.filter;
        filterBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        focusedIndex = -1;
        render();
    }));

    clearDoneBtn.addEventListener('click', () => {
        const snap = { todos: JSON.parse(JSON.stringify(todos)), ghosts: JSON.parse(JSON.stringify(ghosts)), connections: JSON.parse(JSON.stringify(connections)) };
        const c = todos.filter(t => t.done).length;
        todos.filter(t => t.done).forEach(t => {
            ghosts.push({ text: t.text, deletedAt: Date.now() });
        });
        if (ghosts.length > 10) ghosts = ghosts.slice(-10);
        // Remove connections involving done tasks
        const doneIndices = new Set();
        todos.forEach((t, i) => { if (t.done) doneIndices.add(i); });
        connections = connections.filter(cn => !doneIndices.has(cn.from) && !doneIndices.has(cn.to));
        // Re-index connections
        const kept = todos.filter(t => !t.done);
        const indexMap = {};
        let newIdx = 0;
        todos.forEach((t, i) => { if (!t.done) { indexMap[i] = newIdx; newIdx++; } });
        connections = connections.map(cn => ({ from: indexMap[cn.from], to: indexMap[cn.to] }));
        connections = connections.filter(cn => cn.from !== undefined && cn.to !== undefined);
        todos = kept;
        focusedIndex = -1;
        save(); render();
        sfx.delete();
        showToast(`Cleared ${c} done task${c !== 1 ? 's' : ''}`, snap);
        showComment('taskDeleted');
        spawnDeleteParticles(progressBar);
    });

    // =========================================================================
    // KEYBOARD NAVIGATION
    // =========================================================================
    document.addEventListener('keydown', (e) => {
        // Zen mode shortcuts
        if (zenMode) {
            if (e.key === 'z' || e.key === 'Z' || e.key === 'Escape') {
                e.preventDefault(); toggleZen(); return;
            }
            if (e.key === 'ArrowLeft') { e.preventDefault(); zenIndex--; renderZen(); sfx.navigate(); return; }
            if (e.key === 'ArrowRight') { e.preventDefault(); zenIndex++; renderZen(); sfx.navigate(); return; }
            if (e.key === 'Enter') {
                e.preventDefault();
                const active = getActiveTodos();
                if (active.length === 0) return;
                const t = active[zenIndex];
                const idx = todos.indexOf(t);
                todos[idx].done = !todos[idx].done;
                if (todos[idx].done) { sfx.complete(); spawnCompleteParticles(zenCheck); showComment('taskCompleted'); }
                else { sfx.uncomplete(); }
                save(); renderZen(); render();
                return;
            }
            return;
        }

        // Canvas mode: C to toggle back, Esc to exit canvas
        if (canvasMode) {
            if (canvasEditIndex >= 0) return; // editing a card
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                if (e.key === 'Escape') { e.target.blur(); }
                return;
            }
            if ((e.key === 'c' || e.key === 'C') && !e.ctrlKey) {
                e.preventDefault(); toggleCanvasMode(); return;
            }
            if (e.key === 'Escape') {
                e.preventDefault(); toggleCanvasMode(); return;
            }
            return;
        }

        // Search field
        if (e.target === searchInput) {
            if (e.key === 'Escape') {
                searchInput.value = ''; searchQuery = ''; searchInput.blur(); render();
            }
            return;
        }

        // Don't capture when typing in inputs
        if (e.target.tagName === 'INPUT') return;
        if (editingIndex >= 0) return;

        if (e.key === '/') { e.preventDefault(); searchInput.focus(); return; }

        // C for canvas mode
        if ((e.key === 'c' || e.key === 'C') && !e.ctrlKey) { e.preventDefault(); toggleCanvasMode(); return; }

        // Z for zen mode
        if (e.key === 'z' || e.key === 'Z') { e.preventDefault(); toggleZen(); return; }

        // G for purge ghosts
        if (e.key === 'g' || e.key === 'G') { e.preventDefault(); purgeGhosts(); return; }

        const visible = filtered();
        if (visible.length === 0) return;

        if (e.key === 'ArrowDown' || e.key === 'j') {
            e.preventDefault();
            focusedIndex = Math.min(focusedIndex + 1, visible.length - 1);
            sfx.navigate(); render();
        } else if (e.key === 'ArrowUp' || e.key === 'k') {
            e.preventDefault(); sfx.navigate();
            if (focusedIndex <= 0) { focusedIndex = -1; render(); input.focus(); }
            else { focusedIndex--; render(); }
        } else if (e.key === 'Enter' && focusedIndex >= 0) {
            e.preventDefault();
            const t = visible[focusedIndex];
            const idx = todos.indexOf(t);
            const wasDone = t.done;
            todos[idx].done = !wasDone;
            if (!wasDone) {
                sfx.complete();
                const items = list.querySelectorAll('.todo-item');
                if (items[focusedIndex]) {
                    const check = items[focusedIndex].querySelector('.todo-check');
                    spawnCompleteParticles(check);
                }
                showComment('taskCompleted');
            } else { sfx.uncomplete(); }
            save(); render();
        } else if ((e.key === 'Delete' || e.key === 'Backspace') && focusedIndex >= 0) {
            e.preventDefault();
            const items = list.querySelectorAll('.todo-item');
            deleteTodo(todos.indexOf(visible[focusedIndex]), items[focusedIndex]);
        } else if ((e.key === 'e' || e.key === 'E') && focusedIndex >= 0) {
            e.preventDefault();
            editingIndex = todos.indexOf(visible[focusedIndex]);
            render();
        } else if ((e.key === 'p' || e.key === 'P') && focusedIndex >= 0) {
            e.preventDefault();
            const t = visible[focusedIndex];
            const idx = todos.indexOf(t);
            todos[idx].priority = cyclePriority(todos[idx].priority);
            sfx.priority(todos[idx].priority);
            const items = list.querySelectorAll('.todo-item');
            if (items[focusedIndex]) {
                const btn = items[focusedIndex].querySelector('.todo-priority-cycle');
                spawnPriorityParticles(btn, todos[idx].priority);
            }
            save(); render();
        } else if (e.key === 'Escape') {
            focusedIndex = -1; render();
        }
    });

    // =========================================================================
    // INITIAL RENDER + PERIODIC REFRESH
    // =========================================================================
    render();
    showComment();

    setInterval(() => {
        if (!canvasMode) { render(); }
        applyTimeTheme();
    }, 60000);

    setInterval(() => {
        if (!zenMode && !canvasMode) showComment();
    }, 30000);
    </script>
</body>
</html>
