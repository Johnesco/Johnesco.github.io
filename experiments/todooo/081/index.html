<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>081 — Adrift</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  font-family: 'Georgia', serif;
  background: #000;
  cursor: crosshair;
}

#canvas {
  display: block;
  width: 100%;
  height: 100%;
}

#counter {
  position: absolute;
  top: 20px;
  left: 20px;
  color: rgba(255, 255, 255, 0.7);
  font-size: 14px;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
  pointer-events: none;
  letter-spacing: 0.5px;
}

#input-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.3);
  display: none;
  align-items: center;
  justify-content: center;
}

#scroll-input {
  width: 400px;
  max-width: 90%;
  background: #f4ecd8;
  border: 2px solid #8b7355;
  border-radius: 8px;
  padding: 30px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  position: relative;
}

#scroll-input::before,
#scroll-input::after {
  content: '';
  position: absolute;
  width: 20px;
  height: 100%;
  background: linear-gradient(90deg, #d4c4a8 0%, #f4ecd8 50%, #d4c4a8 100%);
  top: 0;
}

#scroll-input::before {
  left: -15px;
  border-radius: 10px 0 0 10px;
}

#scroll-input::after {
  right: -15px;
  border-radius: 0 10px 10px 0;
}

#task-input {
  width: 100%;
  background: transparent;
  border: none;
  outline: none;
  font-size: 18px;
  font-family: 'Georgia', serif;
  color: #3a2a1a;
  text-align: center;
}

#task-input::placeholder {
  color: #9a8a7a;
}

#tooltip {
  position: absolute;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 14px;
  pointer-events: none;
  display: none;
  max-width: 300px;
  text-align: center;
  z-index: 1000;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="counter"></div>
<div id="input-overlay">
  <div id="scroll-input">
    <input type="text" id="task-input" placeholder="Write your message..." maxlength="120" autofocus>
  </div>
</div>
<div id="tooltip"></div>

<script>
// Storage key
const STORAGE_KEY = 'todooo-081';

// Canvas setup
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width, height;

function resizeCanvas() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Audio setup
let audioCtx;
let masterGain;

function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.3;
    masterGain.connect(audioCtx.destination);

    // Start ambient ocean
    startOceanAmbient();
  }
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

function startOceanAmbient() {
  // Ocean waves - filtered noise with LFO
  const bufferSize = audioCtx.sampleRate * 2;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = Math.random() * 2 - 1;
  }

  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  noise.loop = true;

  const filter = audioCtx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 400;

  const lfo = audioCtx.createOscillator();
  lfo.frequency.value = 0.2;
  const lfoGain = audioCtx.createGain();
  lfoGain.gain.value = 200;
  lfo.connect(lfoGain);
  lfoGain.connect(filter.frequency);

  const waveGain = audioCtx.createGain();
  waveGain.gain.value = 0.15;

  noise.connect(filter);
  filter.connect(waveGain);
  waveGain.connect(masterGain);

  noise.start();
  lfo.start();

  // Wind
  const windNoise = audioCtx.createBufferSource();
  windNoise.buffer = buffer;
  windNoise.loop = true;

  const windFilter = audioCtx.createBiquadFilter();
  windFilter.type = 'highpass';
  windFilter.frequency.value = 800;

  const windGain = audioCtx.createGain();
  windGain.gain.value = 0.05;

  windNoise.connect(windFilter);
  windFilter.connect(windGain);
  windGain.connect(masterGain);

  windNoise.start();
}

function playPlop() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.frequency.setValueAtTime(200, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);

  gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);

  osc.connect(gain);
  gain.connect(masterGain);

  osc.start();
  osc.stop(audioCtx.currentTime + 0.2);
}

function playPop() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.frequency.value = 1200;
  gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

  osc.connect(gain);
  gain.connect(masterGain);

  osc.start();
  osc.stop(audioCtx.currentTime + 0.1);
}

// Time of day calculations
function getTimeOfDay() {
  const now = new Date();
  const hours = now.getHours() + now.getMinutes() / 60;
  return hours;
}

function getSkyColors(hour) {
  // Dawn: 5-7
  // Day: 7-17
  // Sunset: 17-19
  // Night: 19-5

  if (hour >= 5 && hour < 7) {
    const t = (hour - 5) / 2;
    return {
      top: lerpColor('#1a1a2e', '#4a7aaa', t),
      horizon: lerpColor('#d4845a', '#a8c8e8', t),
      isNight: false
    };
  } else if (hour >= 7 && hour < 17) {
    return {
      top: '#4a7aaa',
      horizon: '#a8c8e8',
      isNight: false
    };
  } else if (hour >= 17 && hour < 19) {
    const t = (hour - 17) / 2;
    return {
      top: lerpColor('#4a7aaa', '#1a1a2e', t),
      horizon: lerpColor('#a8c8e8', '#d4845a', t),
      isNight: false
    };
  } else {
    return {
      top: '#1a1a2e',
      horizon: '#2a2a4e',
      isNight: true
    };
  }
}

function getOceanColors(hour) {
  if (hour >= 5 && hour < 7) {
    const t = (hour - 5) / 2;
    return [
      lerpColor('#1a2a3a', '#2a5a7a', t),
      lerpColor('#2a3a5a', '#3a7a9a', t),
      lerpColor('#0a1a2a', '#1a4a6a', t)
    ];
  } else if (hour >= 7 && hour < 17) {
    return ['#2a5a7a', '#3a7a9a', '#1a4a6a'];
  } else if (hour >= 17 && hour < 19) {
    const t = (hour - 17) / 2;
    return [
      lerpColor('#2a5a7a', '#4a3a2a', t),
      lerpColor('#3a7a9a', '#6a5a4a', t),
      lerpColor('#1a4a6a', '#2a2a1a', t)
    ];
  } else {
    return ['#0a1a2a', '#1a2a3a', '#05050a'];
  }
}

function lerpColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1, 3), 16);
  const g1 = parseInt(c1.slice(3, 5), 16);
  const b1 = parseInt(c1.slice(5, 7), 16);

  const r2 = parseInt(c2.slice(1, 3), 16);
  const g2 = parseInt(c2.slice(3, 5), 16);
  const b2 = parseInt(c2.slice(5, 7), 16);

  const r = Math.round(r1 + (r2 - r1) * t);
  const g = Math.round(g1 + (g2 - g1) * t);
  const b = Math.round(b1 + (b2 - b1) * t);

  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// Wave calculations
function getWaveHeight(x, time) {
  const wave1 = Math.sin(x * 0.01 + time * 0.5) * 15;
  const wave2 = Math.sin(x * 0.02 - time * 0.3) * 10;
  const wave3 = Math.sin(x * 0.015 + time * 0.4) * 8;
  return wave1 + wave2 + wave3;
}

// Hash function for consistent randomness
function hashCode(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}

// Task data structure
class Task {
  constructor(text, x = null) {
    this.id = Date.now() + Math.random();
    this.text = text;
    this.completed = false;
    this.deleted = false;
    this.hash = hashCode(text);

    // Position
    this.x = x !== null ? x : Math.random() * width;
    this.targetX = this.x;
    this.driftSpeed = (this.hash % 100) / 200 + 0.2; // 0.2-0.7

    // Visual properties from hash
    this.tint = ['#88aa88', '#8888aa', '#aaaaaa', '#aa9966'][this.hash % 4];
    this.size = 1;
    this.rotation = 0;

    // Animation state
    this.state = 'floating'; // floating, completing, sinking
    this.stateTime = 0;
    this.beachX = 0;
    this.beachY = 0;

    // For sinking
    this.sinkY = 0;
    this.bubbles = [];
  }

  update(dt, time) {
    this.stateTime += dt;

    if (this.state === 'floating') {
      // Drift
      this.x += this.driftSpeed * dt * 10;
      if (this.x > width + 100) this.x = -100;

      // Bob on waves
      const baseY = height * 0.4 + getWaveHeight(this.x, time);
      this.y = baseY;

      // Rotation based on wave
      const waveDx = getWaveHeight(this.x + 10, time) - getWaveHeight(this.x - 10, time);
      this.rotation = waveDx * 0.01;

      // Scale based on y (parallax)
      const distanceFactor = (this.y - height * 0.4) / (height * 0.2);
      this.size = 0.7 + distanceFactor * 0.3;

    } else if (this.state === 'completing') {
      // Ride wave to shore
      const duration = 3;
      const t = Math.min(this.stateTime / duration, 1);
      const eased = 1 - Math.pow(1 - t, 3);

      this.x = this.startX + (this.beachX - this.startX) * eased;
      this.y = this.startY + (this.beachY - this.startY) * eased + Math.sin(t * Math.PI * 4) * 20 * (1 - t);

      this.rotation = Math.sin(t * Math.PI * 8) * 0.3 * (1 - t);

      if (t >= 1) {
        this.completed = true;
        this.state = 'beached';
        playPop();
      }

    } else if (this.state === 'sinking') {
      // Sink down
      this.sinkY += dt * 30;
      this.rotation += dt * 2;
      this.size *= (1 - dt * 0.5);

      // Create bubbles
      if (Math.random() < 0.3) {
        this.bubbles.push({
          x: this.x + (Math.random() - 0.5) * 20,
          y: this.y + this.sinkY,
          vy: -30 - Math.random() * 20,
          life: 1
        });
      }

      // Update bubbles
      this.bubbles = this.bubbles.filter(b => {
        b.y += b.vy * dt;
        b.life -= dt;
        return b.life > 0;
      });

      if (this.sinkY > 200) {
        this.deleted = true;
      }
    }
  }

  startCompletion() {
    this.state = 'completing';
    this.stateTime = 0;
    this.startX = this.x;
    this.startY = this.y;

    // Find beach position
    const beachedCount = tasks.filter(t => t.completed && t.state === 'beached').length;
    this.beachX = 50 + beachedCount * 45;
    this.beachY = height - 80;
  }

  startSinking() {
    this.state = 'sinking';
    this.stateTime = 0;
    this.sinkY = 0;
    this.bubbles = [];
  }
}

// Task storage
let tasks = [];

function saveTasks() {
  const data = tasks
    .filter(t => !t.deleted)
    .map(t => ({
      text: t.text,
      completed: t.completed,
      x: t.x,
      beachX: t.beachX,
      beachY: t.beachY
    }));
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}

function loadTasks() {
  const data = localStorage.getItem(STORAGE_KEY);
  if (data) {
    const parsed = JSON.parse(data);
    tasks = parsed.map(d => {
      const task = new Task(d.text, d.x);
      if (d.completed) {
        task.completed = true;
        task.state = 'beached';
        task.beachX = d.beachX;
        task.beachY = d.beachY;
        task.y = d.beachY;
      }
      return task;
    });
  }
}

loadTasks();

// Input handling
const inputOverlay = document.getElementById('input-overlay');
const taskInput = document.getElementById('task-input');
let inputX = 0;
let inputY = 0;

function showInput(x, y) {
  initAudio();
  inputX = x;
  inputY = y;
  inputOverlay.style.display = 'flex';
  taskInput.value = '';
  taskInput.focus();
}

function hideInput() {
  inputOverlay.style.display = 'none';
}

taskInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && taskInput.value.trim()) {
    const text = taskInput.value.trim();
    const task = new Task(text, inputX);
    tasks.push(task);
    saveTasks();
    hideInput();
    playPlop();
  } else if (e.key === 'Escape') {
    hideInput();
  }
});

inputOverlay.addEventListener('click', (e) => {
  if (e.target === inputOverlay) {
    hideInput();
  }
});

// Interaction
let selectedTask = null;
let lastClickTime = 0;
let lastClickTask = null;

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Check if clicking a bottle
  let clicked = null;
  for (let i = tasks.length - 1; i >= 0; i--) {
    const task = tasks[i];
    if (task.deleted) continue;

    let checkX, checkY;
    if (task.state === 'beached') {
      checkX = task.beachX;
      checkY = task.beachY;
    } else if (task.state === 'floating') {
      checkX = task.x;
      checkY = task.y;
    } else {
      continue;
    }

    const dx = x - checkX;
    const dy = y - checkY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < 25 * task.size) {
      clicked = task;
      break;
    }
  }

  if (clicked) {
    // Double click detection
    const now = Date.now();
    if (clicked === lastClickTask && now - lastClickTime < 400) {
      // Double click - complete task
      if (!clicked.completed && clicked.state === 'floating') {
        clicked.startCompletion();
        saveTasks();
      }
      lastClickTask = null;
    } else {
      // Single click - select
      selectedTask = clicked;
      lastClickTask = clicked;
      lastClickTime = now;
    }
  } else {
    // Click on water - add task
    if (y > height * 0.35 && y < height - 100) {
      showInput(x, y);
    }
    selectedTask = null;
  }
});

canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Check if right-clicking a bottle
  for (let i = tasks.length - 1; i >= 0; i--) {
    const task = tasks[i];
    if (task.deleted || task.completed || task.state !== 'floating') continue;

    const dx = x - task.x;
    const dy = y - task.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < 25 * task.size) {
      task.startSinking();
      saveTasks();
      if (selectedTask === task) selectedTask = null;
      break;
    }
  }
});

// Tooltip
const tooltip = document.getElementById('tooltip');

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  let hoveredTask = null;
  for (let i = tasks.length - 1; i >= 0; i--) {
    const task = tasks[i];
    if (task.deleted) continue;

    let checkX, checkY;
    if (task.state === 'beached') {
      checkX = task.beachX;
      checkY = task.beachY;
    } else if (task.state === 'floating') {
      checkX = task.x;
      checkY = task.y;
    } else {
      continue;
    }

    const dx = x - checkX;
    const dy = y - checkY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < 25 * task.size) {
      hoveredTask = task;
      break;
    }
  }

  if (hoveredTask) {
    tooltip.textContent = hoveredTask.text;
    tooltip.style.display = 'block';
    tooltip.style.left = e.clientX + 'px';
    tooltip.style.top = (e.clientY - 40) + 'px';
  } else {
    tooltip.style.display = 'none';
  }
});

// Drawing
function drawBottle(x, y, rotation, size, tint, glint = false) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);
  ctx.scale(size, size);

  // Shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
  ctx.beginPath();
  ctx.ellipse(0, 25, 12, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Bottle body
  ctx.fillStyle = tint;
  ctx.globalAlpha = 0.3;
  ctx.beginPath();
  ctx.ellipse(0, 0, 12, 18, 0, 0, Math.PI * 2);
  ctx.fill();

  // Bottle outline
  ctx.globalAlpha = 0.6;
  ctx.strokeStyle = tint;
  ctx.lineWidth = 2;
  ctx.stroke();

  // Neck
  ctx.fillStyle = tint;
  ctx.globalAlpha = 0.4;
  ctx.fillRect(-4, -18, 8, 10);
  ctx.strokeRect(-4, -18, 8, 10);

  // Cork
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#8b5a3c';
  ctx.fillRect(-5, -22, 10, 6);
  ctx.strokeStyle = '#6b4a2c';
  ctx.lineWidth = 1;
  ctx.strokeRect(-5, -22, 10, 6);

  // Paper inside
  ctx.globalAlpha = 0.8;
  ctx.fillStyle = '#f4ecd8';
  ctx.fillRect(-6, -5, 12, 10);
  ctx.strokeStyle = '#d4c4a8';
  ctx.lineWidth = 0.5;
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.moveTo(-6, -3 + i * 3);
    ctx.lineTo(6, -3 + i * 3);
    ctx.stroke();
  }

  // Glint
  if (glint) {
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(-6, -8, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}

function drawCloud(x, y, scale) {
  ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
  ctx.beginPath();
  ctx.arc(x, y, 30 * scale, 0, Math.PI * 2);
  ctx.arc(x + 25 * scale, y - 10 * scale, 35 * scale, 0, Math.PI * 2);
  ctx.arc(x + 50 * scale, y, 30 * scale, 0, Math.PI * 2);
  ctx.fill();
}

function drawBird(x, y, wingPhase) {
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
  ctx.lineWidth = 2;
  ctx.lineCap = 'round';

  const wing = Math.sin(wingPhase) * 5;

  ctx.beginPath();
  ctx.moveTo(x - 8, y + wing);
  ctx.lineTo(x, y);
  ctx.lineTo(x + 8, y + wing);
  ctx.stroke();
}

function drawStar(x, y, brightness) {
  ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
  ctx.beginPath();
  ctx.arc(x, y, 1, 0, Math.PI * 2);
  ctx.fill();
}

// Counter
const counter = document.getElementById('counter');

function updateCounter() {
  const adrift = tasks.filter(t => !t.completed && !t.deleted && t.state === 'floating').length;
  const ashore = tasks.filter(t => t.completed && t.state === 'beached').length;
  counter.textContent = `${adrift} bottle${adrift !== 1 ? 's' : ''} adrift · ${ashore} washed ashore`;
}

// Animation loop
let lastTime = performance.now();
let time = 0;

// Cloud positions
const clouds = [
  { x: width * 0.2, y: height * 0.15, scale: 1, speed: 0.05 },
  { x: width * 0.6, y: height * 0.08, scale: 0.8, speed: 0.03 },
  { x: width * 0.85, y: height * 0.2, scale: 1.2, speed: 0.04 }
];

// Bird positions
const birds = [
  { x: width * 0.3, y: height * 0.25, phase: 0, speed: 0.3 },
  { x: width * 0.7, y: height * 0.18, phase: Math.PI, speed: 0.25 }
];

// Stars
const stars = [];
for (let i = 0; i < 100; i++) {
  stars.push({
    x: Math.random() * width,
    y: Math.random() * height * 0.4,
    brightness: Math.random() * 0.5 + 0.3,
    twinkle: Math.random() * Math.PI * 2
  });
}

function animate(currentTime) {
  const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
  lastTime = currentTime;
  time += dt;

  // Clear
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, width, height);

  const hour = getTimeOfDay();
  const skyColors = getSkyColors(hour);
  const oceanColors = getOceanColors(hour);

  // Sky gradient
  const skyGradient = ctx.createLinearGradient(0, 0, 0, height * 0.4);
  skyGradient.addColorStop(0, skyColors.top);
  skyGradient.addColorStop(1, skyColors.horizon);
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, width, height * 0.4);

  // Stars (if night)
  if (skyColors.isNight) {
    stars.forEach(star => {
      const twinkle = Math.sin(time * 2 + star.twinkle) * 0.2 + 0.8;
      drawStar(star.x, star.y, star.brightness * twinkle);
    });
  }

  // Sun or moon
  const sunY = height * 0.15;
  const sunX = width * 0.8;
  if (skyColors.isNight) {
    // Moon
    ctx.fillStyle = 'rgba(240, 240, 255, 0.9)';
    ctx.beginPath();
    ctx.arc(sunX, sunY, 40, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(200, 200, 220, 0.3)';
    ctx.beginPath();
    ctx.arc(sunX - 10, sunY - 5, 35, 0, Math.PI * 2);
    ctx.fill();
  } else {
    // Sun
    ctx.fillStyle = 'rgba(255, 220, 100, 0.8)';
    ctx.beginPath();
    ctx.arc(sunX, sunY, 50, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255, 240, 150, 0.4)';
    ctx.beginPath();
    ctx.arc(sunX, sunY, 70, 0, Math.PI * 2);
    ctx.fill();
  }

  // Clouds
  if (!skyColors.isNight) {
    clouds.forEach(cloud => {
      cloud.x += cloud.speed * dt * 10;
      if (cloud.x > width + 100) cloud.x = -100;
      drawCloud(cloud.x, cloud.y, cloud.scale);
    });
  }

  // Birds
  birds.forEach(bird => {
    bird.x += bird.speed * dt * 10;
    if (bird.x > width + 20) bird.x = -20;
    bird.phase += dt * 5;
    drawBird(bird.x, bird.y, bird.phase);
  });

  // Fog (if night or early morning)
  if (skyColors.isNight || (hour >= 5 && hour < 8)) {
    ctx.fillStyle = 'rgba(200, 200, 220, 0.15)';
    ctx.fillRect(0, height * 0.35, width, height * 0.15);
  }

  // Ocean waves
  for (let layer = 0; layer < 3; layer++) {
    ctx.fillStyle = oceanColors[layer];
    ctx.beginPath();
    ctx.moveTo(0, height);

    for (let x = 0; x <= width; x += 5) {
      const baseY = height * 0.4 + layer * 80;
      const y = baseY + getWaveHeight(x, time - layer * 0.3);
      if (x === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }

    ctx.lineTo(width, height);
    ctx.lineTo(0, height);
    ctx.closePath();
    ctx.fill();

    // Foam/highlights on top wave
    if (layer === 0) {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let x = 0; x <= width; x += 5) {
        const baseY = height * 0.4;
        const y = baseY + getWaveHeight(x, time);
        if (x === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
    }
  }

  // Beach
  ctx.fillStyle = '#d4b890';
  ctx.beginPath();
  ctx.moveTo(0, height - 100);
  ctx.quadraticCurveTo(width / 2, height - 120, width, height - 100);
  ctx.lineTo(width, height);
  ctx.lineTo(0, height);
  ctx.closePath();
  ctx.fill();

  // Foam line
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, height - 100);
  for (let x = 0; x <= width; x += 10) {
    const y = height - 100 + Math.sin(x * 0.05 + time * 2) * 3;
    ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Update and draw tasks
  tasks = tasks.filter(t => !t.deleted);

  // Sort for drawing order
  const floatingTasks = tasks.filter(t => t.state === 'floating' || t.state === 'completing' || t.state === 'sinking');
  floatingTasks.sort((a, b) => a.y - b.y);

  floatingTasks.forEach(task => {
    task.update(dt, time);

    if (task.state === 'sinking') {
      // Draw bubbles
      task.bubbles.forEach(bubble => {
        ctx.fillStyle = `rgba(200, 230, 255, ${bubble.life * 0.5})`;
        ctx.beginPath();
        ctx.arc(bubble.x, bubble.y, 3, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw sinking bottle
      ctx.globalAlpha = Math.max(0, 1 - task.sinkY / 200);
      const glint = Math.sin(time * 5 + task.hash) > 0.9;
      drawBottle(task.x, task.y + task.sinkY, task.rotation, task.size, task.tint, glint);
      ctx.globalAlpha = 1;
    } else {
      const glint = Math.sin(time * 3 + task.hash) > 0.95;
      drawBottle(task.x, task.y, task.rotation, task.size, task.tint, glint);
    }
  });

  // Draw beached bottles
  const beachedTasks = tasks.filter(t => t.state === 'beached');
  beachedTasks.forEach(task => {
    const glowPhase = Math.sin(time * 2 + task.hash) * 0.3 + 0.7;

    // Glow
    ctx.fillStyle = `rgba(255, 230, 150, ${0.2 * glowPhase})`;
    ctx.beginPath();
    ctx.arc(task.beachX, task.beachY, 30, 0, Math.PI * 2);
    ctx.fill();

    drawBottle(task.beachX, task.beachY, 0, 1, task.tint, true);
  });

  // Update counter
  updateCounter();

  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);

// Initialize audio on first interaction
document.addEventListener('click', initAudio, { once: true });
</script>
</body>
</html>
