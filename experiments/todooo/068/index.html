<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campfire - todooo 068</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 200, 150, 0.5);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            line-height: 1.6;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 200, 150, 0.4);
            font-family: 'Courier New', monospace;
            font-size: 11px;
            text-align: center;
            pointer-events: none;
            opacity: 1;
            transition: opacity 2s;
        }

        #instructions.fade {
            opacity: 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info"></div>
    <div id="instructions">
        Move cursor to create wind • Click fire to add logs • Press R to relight
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const info = document.getElementById('info');
        const instructions = document.getElementById('instructions');

        // Storage key
        const STORAGE_KEY = 'todooo-068';

        // Canvas setup
        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Hide instructions after 10 seconds
        setTimeout(() => {
            instructions.classList.add('fade');
        }, 10000);

        // Constants
        const FIRE_X = width / 2;
        const FIRE_Y = height * 0.75;
        const GROUND_Y = height * 0.67;

        // Fire state
        let fireHealth = 1.0; // 1.0 = full, 0 = dead
        let fireState = 'burning'; // burning, coals, dead
        let logsAdded = 0;
        let totalTime = 0;
        let visitCount = 0;
        let lastTime = Date.now();

        // Wind state
        let mouseX = width / 2;
        let mouseY = height / 2;
        let lastMouseX = mouseX;
        let lastMouseY = mouseY;
        let windX = 0;
        let windY = 0;
        let windStrength = 0;

        // Particle arrays
        let flames = [];
        let embers = [];
        let smoke = [];
        let stars = [];
        let shootingStar = null;
        let lastShootingStarTime = Date.now();

        // Audio context
        let audioCtx = null;
        let crackleSources = [];
        let windNoise = null;
        let cricketOscillator = null;
        let lastCrackleTime = 0;
        let lastPopTime = 0;
        let lastOwlTime = Date.now();

        // Load state
        function loadState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const data = JSON.parse(saved);
                    fireHealth = data.fireHealth || 1.0;
                    fireState = data.fireState || 'burning';
                    logsAdded = data.logsAdded || 0;
                    totalTime = data.totalTime || 0;
                    visitCount = data.visitCount || 0;

                    // Check if fire should have degraded since last visit
                    if (data.lastVisit) {
                        const elapsed = (Date.now() - data.lastVisit) / 1000;
                        if (elapsed > 600 && fireState === 'burning') {
                            fireHealth = Math.max(0.3, fireHealth - elapsed / 1200);
                            if (fireHealth < 0.5) fireState = 'coals';
                        }
                    }
                }
                visitCount++;
            } catch (e) {
                console.error('Load error:', e);
            }
        }

        // Save state
        function saveState() {
            try {
                const data = {
                    fireHealth,
                    fireState,
                    logsAdded,
                    totalTime,
                    visitCount,
                    lastVisit: Date.now()
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                console.error('Save error:', e);
            }
        }

        loadState();

        // Particle classes
        class Flame {
            constructor(x, y, intensity = 1.0) {
                this.x = x + (Math.random() - 0.5) * 40;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = -(Math.random() * 2 + 1) * intensity;
                this.life = 1.0;
                this.maxLife = Math.random() * 0.5 + 0.5;
                this.size = Math.random() * 20 + 10;
                this.hue = Math.random() * 60; // 0-60 for orange-yellow range
                this.turbulence = Math.random() * 0.5;
                this.intensity = intensity;
            }

            update(dt, wind) {
                this.x += this.vx + wind.x * 2;
                this.y += this.vy;
                this.vx += (Math.random() - 0.5) * this.turbulence;
                this.vy += (Math.random() - 0.5) * 0.2;
                this.life -= dt * (1 / this.maxLife);

                if (this.life < 0) return false;
                return true;
            }

            draw() {
                const alpha = this.life * 0.8;
                const size = this.size * this.life;

                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size);

                if (this.life > 0.7) {
                    gradient.addColorStop(0, `hsla(60, 100%, 80%, ${alpha})`);
                    gradient.addColorStop(0.3, `hsla(45, 100%, 60%, ${alpha * 0.8})`);
                    gradient.addColorStop(1, `hsla(20, 100%, 50%, 0)`);
                } else {
                    gradient.addColorStop(0, `hsla(45, 100%, 60%, ${alpha})`);
                    gradient.addColorStop(0.4, `hsla(30, 100%, 50%, ${alpha * 0.7})`);
                    gradient.addColorStop(1, `hsla(15, 100%, 40%, 0)`);
                }

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Ember {
            constructor(x, y, intensity = 1.0) {
                this.x = x + (Math.random() - 0.5) * 30;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 1;
                this.vy = -(Math.random() * 3 + 2) * intensity;
                this.life = 1.0;
                this.maxLife = Math.random() * 3 + 2;
                this.size = Math.random() * 3 + 2;
                this.glow = Math.random() * 0.5 + 0.5;
            }

            update(dt, wind) {
                this.x += this.vx + wind.x * 3;
                this.y += this.vy;
                this.vx += wind.x * 0.1;
                this.vy += 0.05; // slight gravity
                this.life -= dt * (1 / this.maxLife);
                this.glow = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;

                if (this.life < 0) return false;
                return true;
            }

            draw() {
                const alpha = this.life * 0.9;
                const size = this.size * (0.5 + this.life * 0.5);

                ctx.shadowBlur = 15 * this.glow;
                ctx.shadowColor = `rgba(255, 120, 0, ${alpha})`;

                ctx.fillStyle = `rgba(255, ${120 + this.glow * 100}, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
            }
        }

        class Smoke {
            constructor(x, y) {
                this.x = x + (Math.random() - 0.5) * 20;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = -(Math.random() * 0.5 + 0.3);
                this.life = 1.0;
                this.maxLife = Math.random() * 5 + 3;
                this.size = Math.random() * 30 + 20;
                this.rotation = Math.random() * Math.PI * 2;
            }

            update(dt, wind) {
                this.x += this.vx + wind.x * 1.5;
                this.y += this.vy;
                this.vx += (Math.random() - 0.5) * 0.1;
                this.size += 0.5;
                this.rotation += 0.01;
                this.life -= dt * (1 / this.maxLife);

                if (this.life < 0) return false;
                return true;
            }

            draw() {
                const alpha = this.life * 0.15;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, `rgba(60, 60, 80, ${alpha})`);
                gradient.addColorStop(1, 'rgba(30, 30, 40, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Star {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * GROUND_Y * 0.8;
                this.size = Math.random() * 1.5 + 0.5;
                this.brightness = Math.random();
                this.twinkleSpeed = Math.random() * 0.02 + 0.01;
                this.twinkleOffset = Math.random() * Math.PI * 2;
            }

            update() {
                this.brightness = 0.3 + Math.sin(Date.now() * this.twinkleSpeed * 0.001 + this.twinkleOffset) * 0.7;
            }

            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness * 0.8})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class ShootingStar {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * GROUND_Y * 0.3;
                this.vx = Math.random() * 8 + 4;
                this.vy = Math.random() * 2 + 1;
                this.life = 1.0;
                this.length = Math.random() * 60 + 40;
            }

            update(dt) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= dt * 2;

                if (this.life < 0 || this.x > width + 100) return false;
                return true;
            }

            draw() {
                const gradient = ctx.createLinearGradient(
                    this.x, this.y,
                    this.x - this.vx * 10, this.y - this.vy * 10
                );
                gradient.addColorStop(0, `rgba(255, 255, 255, ${this.life * 0.9})`);
                gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.vx * 5, this.y - this.vy * 5);
                ctx.stroke();
            }
        }

        // Initialize stars
        for (let i = 0; i < 200; i++) {
            stars.push(new Star());
        }

        // Add Milky Way stars
        for (let i = 0; i < 300; i++) {
            const star = new Star();
            const milkyWayCenter = height * 0.25;
            const milkyWayWidth = 200;
            star.y = milkyWayCenter + (Math.random() - 0.5) * milkyWayWidth;
            star.x = Math.random() * width;
            star.size *= 0.5;
            star.brightness *= 0.4;
            stars.push(star);
        }

        // Mouse movement
        canvas.addEventListener('mousemove', (e) => {
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // Click to add log
        canvas.addEventListener('click', (e) => {
            const dx = e.clientX - FIRE_X;
            const dy = e.clientY - FIRE_Y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 150 && fireState !== 'dead') {
                addLog();
            }
        });

        // Key press
        window.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                if (fireState === 'coals' || fireState === 'dead') {
                    relight();
                }
            }
        });

        function addLog() {
            logsAdded++;
            fireHealth = Math.min(1.0, fireHealth + 0.3);
            fireState = 'burning';

            // Burst of flames and embers
            for (let i = 0; i < 20; i++) {
                flames.push(new Flame(FIRE_X, FIRE_Y - 20, 1.5));
            }
            for (let i = 0; i < 30; i++) {
                embers.push(new Ember(FIRE_X, FIRE_Y - 10, 1.5));
            }

            playPop();
            saveState();
        }

        function relight() {
            fireHealth = 0.4;
            fireState = 'burning';

            for (let i = 0; i < 10; i++) {
                flames.push(new Flame(FIRE_X, FIRE_Y - 10, 0.8));
            }
            for (let i = 0; i < 5; i++) {
                embers.push(new Ember(FIRE_X, FIRE_Y, 0.8));
            }

            playPop();
            saveState();
        }

        // Audio functions
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                // Start cricket ambient
                startCrickets();
                startWindNoise();
            }
        }

        function startCrickets() {
            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            osc.type = 'triangle';
            osc.frequency.value = 4000 + Math.random() * 1000;

            filter.type = 'bandpass';
            filter.frequency.value = 4000;
            filter.Q.value = 10;

            gain.gain.value = 0.01;

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();

            // Modulate frequency for cricket chirp pattern
            setInterval(() => {
                if (Math.random() < 0.3) {
                    osc.frequency.setValueAtTime(4000 + Math.random() * 1000, audioCtx.currentTime);
                }
            }, 200);

            cricketOscillator = osc;
        }

        function startWindNoise() {
            if (!audioCtx) return;

            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            noise.loop = true;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;

            const gain = audioCtx.createGain();
            gain.gain.value = 0;

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            noise.start();
            windNoise = gain;
        }

        function playCrackle() {
            if (!audioCtx) return;

            const now = audioCtx.currentTime;
            const duration = 0.05 + Math.random() * 0.1;

            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / bufferSize * 5);
            }

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 800 + Math.random() * 1200;
            filter.Q.value = 2;

            const gain = audioCtx.createGain();
            gain.gain.value = 0.05 * fireHealth;

            source.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            source.start(now);
            source.stop(now + duration);
        }

        function playPop() {
            if (!audioCtx) return;

            const now = audioCtx.currentTime;
            const duration = 0.15;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(50, now + duration);

            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + duration);

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start(now);
            osc.stop(now + duration);
        }

        function playOwl() {
            if (!audioCtx) return;

            const now = audioCtx.currentTime;

            // Two-note hoot
            for (let i = 0; i < 2; i++) {
                const startTime = now + i * 0.3;
                const duration = 0.25;

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                osc.type = 'sine';
                osc.frequency.value = 400 + i * 50;

                filter.type = 'lowpass';
                filter.frequency.value = 800;

                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(0.02, startTime + 0.05);
                gain.gain.linearRampToValueAtTime(0.02, startTime + 0.15);
                gain.gain.linearRampToValueAtTime(0, startTime + duration);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start(startTime);
                osc.stop(startTime + duration);
            }
        }

        // Update loop
        function update(dt) {
            // Update total time
            totalTime += dt;

            // Fire degradation
            if (fireState === 'burning') {
                fireHealth -= dt / 600; // Burns out over 10 minutes
                if (fireHealth < 0.5) {
                    fireState = 'coals';
                }
                if (fireHealth < 0.1) {
                    fireState = 'dead';
                    fireHealth = 0;
                }
            }

            // Wind calculation
            const dx = mouseX - FIRE_X;
            const dy = mouseY - FIRE_Y;
            const mouseSpeed = Math.sqrt(
                (mouseX - lastMouseX) ** 2 + (mouseY - lastMouseY) ** 2
            );

            windStrength = Math.min(mouseSpeed * 0.1, 5);
            const targetWindX = dx * 0.001 + (mouseX - lastMouseX) * 0.05;
            const targetWindY = dy * 0.001 + (mouseY - lastMouseY) * 0.05;

            windX += (targetWindX - windX) * 0.1;
            windY += (targetWindY - windY) * 0.1;

            const wind = { x: windX, y: windY };

            // Update wind noise volume
            if (windNoise) {
                windNoise.gain.value = Math.min(windStrength * 0.02, 0.05);
            }

            // Generate new particles based on fire state
            if (fireState === 'burning' || fireState === 'coals') {
                const intensity = fireState === 'burning' ? fireHealth : fireHealth * 0.3;

                // Flames
                if (fireState === 'burning' && Math.random() < intensity * 0.5) {
                    flames.push(new Flame(FIRE_X, FIRE_Y - 20, intensity));
                }

                // Embers
                if (Math.random() < intensity * 0.1) {
                    embers.push(new Ember(FIRE_X, FIRE_Y - 10, intensity));
                }

                // Smoke
                if (Math.random() < 0.05) {
                    smoke.push(new Smoke(FIRE_X, FIRE_Y - 40));
                }
            }

            // Update particles
            flames = flames.filter(p => p.update(dt, wind));
            embers = embers.filter(p => p.update(dt, wind));
            smoke = smoke.filter(p => p.update(dt, wind));
            stars.forEach(s => s.update());

            // Shooting star
            if (shootingStar) {
                if (!shootingStar.update(dt)) {
                    shootingStar = null;
                }
            } else if (Date.now() - lastShootingStarTime > 30000 + Math.random() * 30000) {
                shootingStar = new ShootingStar();
                lastShootingStarTime = Date.now();
            }

            // Audio
            const now = Date.now();

            if (fireState === 'burning' && now - lastCrackleTime > 200 + Math.random() * 500) {
                playCrackle();
                lastCrackleTime = now;
            }

            if (fireState === 'burning' && now - lastPopTime > 5000 + Math.random() * 10000) {
                playPop();
                lastPopTime = now;
            }

            if (now - lastOwlTime > 60000 + Math.random() * 30000) {
                playOwl();
                lastOwlTime = now;
            }
        }

        // Draw loop
        function draw() {
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
            skyGradient.addColorStop(0, '#000000');
            skyGradient.addColorStop(0.5, '#0a0a20');
            skyGradient.addColorStop(1, '#1a1a30');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, GROUND_Y);

            // Milky Way
            const milkyWayGradient = ctx.createLinearGradient(0, height * 0.15, 0, height * 0.35);
            milkyWayGradient.addColorStop(0, 'rgba(50, 50, 70, 0)');
            milkyWayGradient.addColorStop(0.5, 'rgba(50, 50, 70, 0.15)');
            milkyWayGradient.addColorStop(1, 'rgba(50, 50, 70, 0)');
            ctx.fillStyle = milkyWayGradient;
            ctx.fillRect(0, height * 0.15, width, height * 0.2);

            // Stars
            stars.forEach(s => s.draw());

            // Shooting star
            if (shootingStar) {
                shootingStar.draw();
            }

            // Ground
            ctx.fillStyle = '#1a1a0a';
            ctx.fillRect(0, GROUND_Y, width, height - GROUND_Y);

            // Tree silhouettes
            drawTrees();

            // Fire glow on ground
            if (fireState !== 'dead') {
                const glowIntensity = fireState === 'burning' ? fireHealth : fireHealth * 0.3;
                const glowGradient = ctx.createRadialGradient(
                    FIRE_X, FIRE_Y,
                    0,
                    FIRE_X, FIRE_Y,
                    300 * glowIntensity
                );
                glowGradient.addColorStop(0, `rgba(255, 120, 0, ${0.3 * glowIntensity})`);
                glowGradient.addColorStop(0.5, `rgba(255, 80, 0, ${0.1 * glowIntensity})`);
                glowGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = glowGradient;
                ctx.fillRect(0, GROUND_Y, width, height - GROUND_Y);
            }

            // Smoke (behind fire)
            smoke.forEach(s => s.draw());

            // Logs
            drawLogs();

            // Rocks
            drawRocks();

            // Flames
            flames.forEach(f => f.draw());

            // Embers
            embers.forEach(e => e.draw());

            // Coals
            if (fireState === 'coals' || fireState === 'dead') {
                drawCoals();
            }
        }

        function drawLogs() {
            ctx.fillStyle = '#2a1a0a';
            ctx.strokeStyle = '#1a0a00';
            ctx.lineWidth = 2;

            // Bottom log
            ctx.save();
            ctx.translate(FIRE_X, FIRE_Y);
            ctx.rotate(-0.2);
            ctx.fillRect(-60, -5, 120, 12);
            ctx.strokeRect(-60, -5, 120, 12);
            ctx.restore();

            // Top log
            ctx.save();
            ctx.translate(FIRE_X, FIRE_Y - 8);
            ctx.rotate(0.2);
            ctx.fillRect(-50, -5, 100, 12);
            ctx.strokeRect(-50, -5, 100, 12);
            ctx.restore();

            // Side log
            ctx.save();
            ctx.translate(FIRE_X - 30, FIRE_Y - 5);
            ctx.rotate(0.6);
            ctx.fillRect(-40, -5, 80, 10);
            ctx.strokeRect(-40, -5, 80, 10);
            ctx.restore();
        }

        function drawRocks() {
            const rocks = [
                { x: FIRE_X - 90, y: FIRE_Y + 10, r: 15 },
                { x: FIRE_X - 70, y: FIRE_Y + 15, r: 12 },
                { x: FIRE_X + 70, y: FIRE_Y + 15, r: 14 },
                { x: FIRE_X + 85, y: FIRE_Y + 8, r: 11 },
                { x: FIRE_X - 10, y: FIRE_Y + 20, r: 10 },
                { x: FIRE_X + 15, y: FIRE_Y + 22, r: 9 }
            ];

            rocks.forEach(rock => {
                ctx.fillStyle = '#3a3a3a';
                ctx.beginPath();
                ctx.ellipse(rock.x, rock.y, rock.r, rock.r * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#2a2a2a';
                ctx.beginPath();
                ctx.ellipse(rock.x - 2, rock.y - 2, rock.r * 0.4, rock.r * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawCoals() {
            const coalCount = fireState === 'coals' ? 12 : 6;
            const glowIntensity = fireHealth * 0.5;

            for (let i = 0; i < coalCount; i++) {
                const angle = (i / coalCount) * Math.PI * 2;
                const dist = 15 + Math.random() * 20;
                const x = FIRE_X + Math.cos(angle) * dist;
                const y = FIRE_Y + Math.sin(angle) * dist * 0.5;
                const size = 5 + Math.random() * 5;

                // Glow
                const glow = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
                glow.addColorStop(0, `rgba(255, 100, 0, ${glowIntensity * (0.3 + Math.sin(Date.now() * 0.002 + i) * 0.2)})`);
                glow.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(x, y, size * 3, 0, Math.PI * 2);
                ctx.fill();

                // Coal
                ctx.fillStyle = `rgb(${80 + glowIntensity * 175}, ${20 + glowIntensity * 60}, 0)`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawTrees() {
            // Left trees
            drawTree(width * 0.1, GROUND_Y, 80, 150);
            drawTree(width * 0.15, GROUND_Y, 60, 120);

            // Right trees
            drawTree(width * 0.85, GROUND_Y, 70, 130);
            drawTree(width * 0.92, GROUND_Y, 90, 160);
        }

        function drawTree(x, y, width, height) {
            ctx.fillStyle = '#0a0a0a';

            // Trunk
            ctx.fillRect(x - width * 0.1, y - height * 0.3, width * 0.2, height * 0.3);

            // Foliage (simple triangle)
            ctx.beginPath();
            ctx.moveTo(x, y - height);
            ctx.lineTo(x - width / 2, y - height * 0.3);
            ctx.lineTo(x + width / 2, y - height * 0.3);
            ctx.closePath();
            ctx.fill();

            // More layers
            ctx.beginPath();
            ctx.moveTo(x, y - height * 0.8);
            ctx.lineTo(x - width * 0.4, y - height * 0.4);
            ctx.lineTo(x + width * 0.4, y - height * 0.4);
            ctx.closePath();
            ctx.fill();
        }

        // Info display
        function updateInfo() {
            const hours = Math.floor(totalTime / 3600);
            const minutes = Math.floor((totalTime % 3600) / 60);

            let stateText = fireState.toUpperCase();
            if (fireState === 'burning') {
                stateText += ` (${Math.round(fireHealth * 100)}%)`;
            }

            info.innerHTML = `
                Fire: ${stateText}<br>
                Logs added: ${logsAdded}<br>
                Time by fire: ${hours}h ${minutes}m<br>
                Visits: ${visitCount}
            `;
        }

        // Main loop
        let lastFrame = Date.now();
        function loop() {
            const now = Date.now();
            const dt = Math.min((now - lastFrame) / 1000, 0.1);
            lastFrame = now;

            update(dt);
            draw();
            updateInfo();

            requestAnimationFrame(loop);
        }

        // Start
        canvas.addEventListener('click', () => {
            initAudio();
        }, { once: true });

        loop();

        // Auto-save every 10 seconds
        setInterval(saveState, 10000);

        // Save on page unload
        window.addEventListener('beforeunload', saveState);
    </script>
</body>
</html>