<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>079 Memory Palace</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, serif;
  overflow: hidden;
  background: #1a1410;
  color: #d8d0c4;
}

#canvas {
  display: block;
  width: 100vw;
  height: 100vh;
  cursor: default;
}

#ui {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.nav-arrow {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 60px;
  height: 60px;
  background: rgba(200, 184, 154, 0.2);
  border: 2px solid rgba(200, 184, 154, 0.4);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
  color: #c8b89a;
  cursor: pointer;
  pointer-events: auto;
  transition: all 0.3s ease;
  backdrop-filter: blur(4px);
}

.nav-arrow:hover {
  background: rgba(200, 184, 154, 0.35);
  border-color: rgba(200, 184, 154, 0.7);
  transform: translateY(-50%) scale(1.1);
}

.nav-arrow.left {
  left: 20px;
}

.nav-arrow.right {
  right: 20px;
}

.nav-arrow.disabled {
  opacity: 0.3;
  pointer-events: none;
}

.room-indicator {
  position: absolute;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 12px;
  pointer-events: auto;
}

.room-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: rgba(200, 184, 154, 0.3);
  border: 1px solid rgba(200, 184, 154, 0.5);
  cursor: pointer;
  transition: all 0.3s ease;
}

.room-dot.active {
  background: rgba(200, 184, 154, 0.8);
  box-shadow: 0 0 12px rgba(200, 184, 154, 0.6);
}

.room-dot:hover:not(.active) {
  background: rgba(200, 184, 154, 0.5);
}

#overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(26, 20, 16, 0.85);
  display: none;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
  backdrop-filter: blur(6px);
}

#overlay.visible {
  display: flex;
}

.overlay-content {
  background: linear-gradient(135deg, #4a3828 0%, #3a2818 100%);
  border: 3px solid #c8b89a;
  border-radius: 8px;
  padding: 40px;
  max-width: 500px;
  width: 90%;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
}

.overlay-content h2 {
  font-size: 28px;
  margin-bottom: 20px;
  text-align: center;
  color: #d8d0c4;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

.overlay-content input {
  width: 100%;
  padding: 15px;
  font-size: 18px;
  font-family: inherit;
  background: rgba(216, 208, 196, 0.95);
  border: 2px solid #c8b89a;
  border-radius: 4px;
  color: #1a1410;
  margin-bottom: 20px;
}

.overlay-content input:focus {
  outline: none;
  border-color: #d8c8a4;
  box-shadow: 0 0 12px rgba(200, 184, 154, 0.4);
}

.overlay-buttons {
  display: flex;
  gap: 15px;
  justify-content: center;
}

.overlay-buttons button {
  padding: 12px 30px;
  font-size: 16px;
  font-family: inherit;
  border: 2px solid #c8b89a;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.overlay-buttons button.primary {
  background: #c8b89a;
  color: #1a1410;
}

.overlay-buttons button.primary:hover {
  background: #d8c8a4;
  box-shadow: 0 4px 12px rgba(200, 184, 154, 0.4);
}

.overlay-buttons button.secondary {
  background: transparent;
  color: #c8b89a;
}

.overlay-buttons button.secondary:hover {
  background: rgba(200, 184, 154, 0.2);
}

.task-detail {
  text-align: center;
}

.task-detail .object-name {
  font-size: 48px;
  margin-bottom: 20px;
}

.task-detail .task-text {
  font-size: 20px;
  line-height: 1.6;
  margin-bottom: 30px;
  color: #e8e0d4;
}

.task-detail .actions {
  display: flex;
  gap: 15px;
  justify-content: center;
}

.task-detail button {
  padding: 12px 24px;
  font-size: 16px;
  font-family: inherit;
  border: 2px solid;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.task-detail button.complete {
  background: #8a7a4a;
  color: #fff;
  border-color: #9a8a5a;
}

.task-detail button.complete:hover {
  background: #9a8a5a;
  box-shadow: 0 4px 12px rgba(138, 122, 74, 0.5);
}

.task-detail button.delete {
  background: #6a4a3a;
  color: #fff;
  border-color: #7a5a4a;
}

.task-detail button.delete:hover {
  background: #7a5a4a;
  box-shadow: 0 4px 12px rgba(106, 74, 58, 0.5);
}

.task-detail button.cancel {
  background: transparent;
  color: #c8b89a;
  border-color: #c8b89a;
}

.task-detail button.cancel:hover {
  background: rgba(200, 184, 154, 0.2);
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="ui">
  <div class="nav-arrow left" id="prevRoom">‚Äπ</div>
  <div class="nav-arrow right" id="nextRoom">‚Ä∫</div>
  <div class="room-indicator" id="roomIndicator"></div>
</div>

<div id="overlay">
  <div class="overlay-content" id="overlayContent"></div>
</div>

<script>
// State
const STORAGE_KEY = 'todooo-079';
const TASKS_PER_ROOM = 5;

let state = {
  tasks: [],
  currentRoom: 0,
  selectedTask: null,
  transition: { active: false, progress: 0, direction: 0 }
};

// Canvas setup
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let w, h, cx, cy;

function resizeCanvas() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
  cx = w / 2;
  cy = h / 2;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Audio context (lazy)
let audioCtx;
function getAudioContext() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
  return audioCtx;
}

// Sound effects
function playFootstep() {
  const ctx = getAudioContext();
  const noise = ctx.createBufferSource();
  const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) {
    data[i] = Math.random() * 2 - 1;
  }
  noise.buffer = buffer;

  const filter = ctx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 300;

  const gain = ctx.createGain();
  gain.gain.setValueAtTime(0.15, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

  noise.connect(filter).connect(gain).connect(ctx.destination);
  noise.start();
  noise.stop(ctx.currentTime + 0.1);
}

function playChime() {
  const ctx = getAudioContext();
  const osc = ctx.createOscillator();
  osc.frequency.value = 880;

  const gain = ctx.createGain();
  gain.gain.setValueAtTime(0.1, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.6);

  osc.connect(gain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.6);
}

function playComplete() {
  const ctx = getAudioContext();
  const osc = ctx.createOscillator();
  osc.frequency.setValueAtTime(440, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 1.2);

  const gain = ctx.createGain();
  gain.gain.setValueAtTime(0.12, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 1.2);

  osc.connect(gain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 1.2);
}

function playShatter() {
  const ctx = getAudioContext();
  const noise = ctx.createBufferSource();
  const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) {
    data[i] = Math.random() * 2 - 1;
  }
  noise.buffer = buffer;

  const filter = ctx.createBiquadFilter();
  filter.type = 'highpass';
  filter.frequency.value = 2000;

  const gain = ctx.createGain();
  gain.gain.setValueAtTime(0.2, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);

  noise.connect(filter).connect(gain).connect(ctx.destination);
  noise.start();
  noise.stop(ctx.currentTime + 0.3);
}

// Hash function for deterministic object selection
function hashString(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}

// Object types
const OBJECT_TYPES = [
  'orb', 'book', 'key', 'crystal', 'skull',
  'clock', 'mirror', 'compass', 'chalice', 'flame',
  'eye', 'feather', 'hourglass', 'crown', 'bell'
];

function getObjectType(taskText) {
  const hash = hashString(taskText);
  return OBJECT_TYPES[hash % OBJECT_TYPES.length];
}

function getObjectColor(taskText) {
  const hash = hashString(taskText);
  const hue = hash % 360;
  return `hsl(${hue}, 60%, 65%)`;
}

// Storage
function saveState() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify({
    tasks: state.tasks
  }));
}

function loadState() {
  const saved = localStorage.getItem(STORAGE_KEY);
  if (saved) {
    try {
      const data = JSON.parse(saved);
      state.tasks = data.tasks || [];
    } catch (e) {
      state.tasks = [];
    }
  }
}

// Room calculations
function getRoomCount() {
  return Math.max(1, Math.ceil(state.tasks.length / TASKS_PER_ROOM));
}

function getTasksInRoom(roomIndex) {
  const start = roomIndex * TASKS_PER_ROOM;
  const end = start + TASKS_PER_ROOM;
  return state.tasks.slice(start, end);
}

function toRoman(num) {
  const lookup = {M:1000,CM:900,D:500,CD:400,C:100,XC:90,L:50,XL:40,X:10,IX:9,V:5,IV:4,I:1};
  let roman = '';
  for (let i in lookup) {
    while (num >= lookup[i]) {
      roman += i;
      num -= lookup[i];
    }
  }
  return roman || 'I';
}

// Particle systems
let particles = [];

function createCompleteParticles(x, y, color) {
  for (let i = 0; i < 40; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 2,
      vy: -Math.random() * 4 - 2,
      life: 1,
      decay: 0.01 + Math.random() * 0.01,
      color,
      size: 3 + Math.random() * 4
    });
  }
}

function createShatterParticles(x, y, color) {
  for (let i = 0; i < 30; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 5 + 2;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      decay: 0.02 + Math.random() * 0.02,
      color,
      size: 2 + Math.random() * 3
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15; // gravity
    p.life -= p.decay;

    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// Drawing functions
function drawRoom(roomIndex, offsetX = 0, alpha = 1) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.translate(offsetX, 0);

  const vp = { x: cx, y: cy * 0.6 }; // vanishing point
  const roomTasks = getTasksInRoom(roomIndex);
  const roomCount = getRoomCount();

  // Room color variation
  const colorOffset = roomIndex * 10;
  const wallColor = `hsl(35, ${30 + colorOffset % 20}%, ${60 + colorOffset % 15}%)`;
  const wainscotColor = `hsl(25, ${25 + colorOffset % 15}%, ${30 + colorOffset % 10}%)`;
  const floorColor = '#d8d0c4';

  // Floor
  drawFloor(vp, floorColor);

  // Ceiling
  drawCeiling(vp);

  // Back wall
  drawBackWall(vp, wallColor, wainscotColor, roomIndex, roomCount);

  // Side walls
  drawSideWalls(vp, wallColor, wainscotColor);

  // Chandelier
  drawChandelier(vp);

  // Dust motes
  drawDustMotes(roomIndex);

  // Objects
  drawObjects(roomIndex, roomTasks, vp);

  ctx.restore();
}

function drawFloor(vp, color) {
  const floorY = h * 0.75;
  const tileCount = 8;

  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(0, floorY);
  ctx.lineTo(0, h);
  ctx.lineTo(w, h);
  ctx.lineTo(w, floorY);
  ctx.lineTo(vp.x, vp.y);
  ctx.closePath();
  ctx.fill();

  // Checkerboard pattern
  for (let row = 0; row < tileCount; row++) {
    for (let col = 0; col < tileCount * 2; col++) {
      if ((row + col) % 2 === 0) continue;

      const t = row / tileCount;
      const s = col / (tileCount * 2) - 0.5;

      const x1 = vp.x + s * w * (1 - t);
      const x2 = vp.x + (s + 1/(tileCount*2)) * w * (1 - t);
      const y1 = vp.y + (floorY - vp.y) * t;
      const y2 = vp.y + (floorY - vp.y) * (t + 1/tileCount);

      const x3 = vp.x + s * w * (1 - (t + 1/tileCount));
      const x4 = vp.x + (s + 1/(tileCount*2)) * w * (1 - (t + 1/tileCount));

      ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y1);
      ctx.lineTo(x4, y2);
      ctx.lineTo(x3, y2);
      ctx.closePath();
      ctx.fill();
    }
  }
}

function drawCeiling(vp) {
  ctx.fillStyle = '#b8a88a';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0, h * 0.25);
  ctx.lineTo(vp.x, vp.y);
  ctx.lineTo(w, h * 0.25);
  ctx.lineTo(w, 0);
  ctx.closePath();
  ctx.fill();
}

function drawBackWall(vp, wallColor, wainscotColor, roomIndex, roomCount) {
  const wallW = w * 0.4;
  const wallH = h * 0.5;
  const wallX = cx - wallW / 2;
  const wallY = vp.y;

  // Main wall
  ctx.fillStyle = wallColor;
  ctx.fillRect(wallX, wallY, wallW, wallH);

  // Wainscoting
  ctx.fillStyle = wainscotColor;
  ctx.fillRect(wallX, wallY + wallH * 0.66, wallW, wallH * 0.34);

  // Doorway or window
  const hasNext = roomIndex < roomCount - 1;
  const doorW = wallW * 0.4;
  const doorH = wallH * 0.7;
  const doorX = cx - doorW / 2;
  const doorY = wallY + wallH * 0.3;

  if (hasNext) {
    // Arched doorway
    ctx.fillStyle = '#1a1410';
    ctx.fillRect(doorX, doorY, doorW, doorH * 0.7);
    ctx.beginPath();
    ctx.arc(doorX + doorW / 2, doorY + doorH * 0.7, doorW / 2, Math.PI, 0);
    ctx.fill();

    // Room number above door
    ctx.fillStyle = '#c8b89a';
    ctx.font = '24px Palatino Linotype';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(toRoman(roomIndex + 2), cx, doorY - 10);
  } else {
    // Window
    ctx.fillStyle = '#4a5870';
    ctx.fillRect(doorX, doorY, doorW, doorH * 0.5);

    // Window panes
    ctx.strokeStyle = '#2a2420';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(cx, doorY);
    ctx.lineTo(cx, doorY + doorH * 0.5);
    ctx.moveTo(doorX, doorY + doorH * 0.25);
    ctx.lineTo(doorX + doorW, doorY + doorH * 0.25);
    ctx.stroke();
  }

  // Empty state message
  if (roomIndex === 0 && state.tasks.length === 0) {
    ctx.fillStyle = 'rgba(74, 56, 40, 0.6)';
    ctx.font = 'italic 20px Palatino Linotype';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Place something here to remember.', cx, wallY + wallH / 2);
  }
}

function drawSideWalls(vp, wallColor, wainscotColor) {
  const floorY = h * 0.75;
  const ceilingY = h * 0.25;

  // Left wall
  ctx.fillStyle = wallColor;
  ctx.beginPath();
  ctx.moveTo(0, ceilingY);
  ctx.lineTo(vp.x, vp.y);
  ctx.lineTo(vp.x, vp.y + (floorY - vp.y) * 0.66);
  ctx.lineTo(0, floorY);
  ctx.closePath();
  ctx.fill();

  // Left wainscoting
  ctx.fillStyle = wainscotColor;
  ctx.beginPath();
  ctx.moveTo(0, floorY);
  ctx.lineTo(vp.x, vp.y + (floorY - vp.y) * 0.66);
  ctx.lineTo(vp.x, vp.y + (floorY - vp.y));
  ctx.lineTo(0, h * 0.75);
  ctx.closePath();
  ctx.fill();

  // Right wall
  ctx.fillStyle = wallColor;
  ctx.beginPath();
  ctx.moveTo(w, ceilingY);
  ctx.lineTo(vp.x, vp.y);
  ctx.lineTo(vp.x, vp.y + (floorY - vp.y) * 0.66);
  ctx.lineTo(w, floorY);
  ctx.closePath();
  ctx.fill();

  // Right wainscoting
  ctx.fillStyle = wainscotColor;
  ctx.beginPath();
  ctx.moveTo(w, floorY);
  ctx.lineTo(vp.x, vp.y + (floorY - vp.y) * 0.66);
  ctx.lineTo(vp.x, vp.y + (floorY - vp.y));
  ctx.lineTo(w, h * 0.75);
  ctx.closePath();
  ctx.fill();
}

function drawChandelier(vp) {
  const x = vp.x;
  const y = h * 0.15;

  // Chain
  ctx.strokeStyle = '#4a3828';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x, 0);
  ctx.lineTo(x, y);
  ctx.stroke();

  // Main circle
  ctx.fillStyle = '#8a7a4a';
  ctx.beginPath();
  ctx.arc(x, y, 15, 0, Math.PI * 2);
  ctx.fill();

  // Candles
  const candles = 6;
  for (let i = 0; i < candles; i++) {
    const angle = (i / candles) * Math.PI * 2;
    const cx = x + Math.cos(angle) * 12;
    const cy = y + Math.sin(angle) * 12;

    ctx.strokeStyle = '#4a3828';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx, cy + 8);
    ctx.stroke();

    // Flame
    ctx.fillStyle = 'rgba(255, 200, 100, 0.7)';
    ctx.beginPath();
    ctx.arc(cx, cy + 8, 3, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawDustMotes(roomIndex) {
  const seed = roomIndex * 1000;
  for (let i = 0; i < 30; i++) {
    const hash = hashString(`dust-${seed}-${i}`);
    const x = (hash % w);
    const y = ((hash >> 8) % h);
    const time = Date.now() / 1000;
    const offset = Math.sin(time + i) * 20;

    ctx.fillStyle = 'rgba(216, 208, 196, 0.3)';
    ctx.beginPath();
    ctx.arc(x + offset, y, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawObjects(roomIndex, tasks, vp) {
  const positions = [
    { x: cx - 200, y: h * 0.65 },
    { x: cx - 100, y: h * 0.65 },
    { x: cx, y: h * 0.65 },
    { x: cx + 100, y: h * 0.65 },
    { x: cx + 200, y: h * 0.65 }
  ];

  tasks.forEach((task, i) => {
    if (i >= positions.length) return;

    const pos = positions[i];
    const objectType = getObjectType(task.text);
    const color = getObjectColor(task.text);
    const isSelected = state.selectedTask === task;
    const glow = isSelected ? 0.6 : 0.3;

    // Shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.beginPath();
    ctx.ellipse(pos.x, pos.y + 60, 30, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // Pedestal
    ctx.fillStyle = task.completed ? '#8a7a4a' : '#6a5a3a';
    ctx.fillRect(pos.x - 25, pos.y, 50, 60);
    ctx.fillStyle = '#5a4a2a';
    ctx.fillRect(pos.x - 28, pos.y + 55, 56, 8);

    if (task.completed) {
      // Golden ring mark
      ctx.strokeStyle = 'rgba(218, 188, 118, 0.8)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y - 30, 25, 0, Math.PI * 2);
      ctx.stroke();
    } else {
      // Glow
      const gradient = ctx.createRadialGradient(pos.x, pos.y - 30, 0, pos.x, pos.y - 30, 60);
      gradient.addColorStop(0, `${color}${Math.floor(glow * 255).toString(16).padStart(2, '0')}`);
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(pos.x - 60, pos.y - 90, 120, 120);

      // Object
      drawObject(pos.x, pos.y - 30, objectType, color);

      // Label
      ctx.fillStyle = '#d8d0c4';
      ctx.font = '11px Palatino Linotype';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const label = task.text.length > 20 ? task.text.slice(0, 20) + '...' : task.text;
      ctx.fillText(label, pos.x, pos.y + 15);
    }
  });

  // Empty pedestals (clickable to add)
  for (let i = tasks.length; i < TASKS_PER_ROOM; i++) {
    if (i >= positions.length) break;
    const pos = positions[i];

    ctx.fillStyle = '#5a4a2a';
    ctx.fillRect(pos.x - 25, pos.y, 50, 60);
    ctx.fillStyle = '#4a3a1a';
    ctx.fillRect(pos.x - 28, pos.y + 55, 56, 8);

    // Plus sign
    ctx.strokeStyle = 'rgba(200, 184, 154, 0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y - 40);
    ctx.lineTo(pos.x, pos.y - 20);
    ctx.moveTo(pos.x - 10, pos.y - 30);
    ctx.lineTo(pos.x + 10, pos.y - 30);
    ctx.stroke();
  }
}

function drawObject(x, y, type, color) {
  ctx.fillStyle = color;
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;

  switch(type) {
    case 'orb':
      const gradient = ctx.createRadialGradient(x - 5, y - 5, 5, x, y, 20);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
      gradient.addColorStop(1, color);
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, 20, 0, Math.PI * 2);
      ctx.fill();
      break;

    case 'book':
      ctx.fillRect(x - 18, y - 12, 36, 24);
      ctx.strokeRect(x - 18, y - 12, 36, 24);
      ctx.beginPath();
      ctx.moveTo(x, y - 12);
      ctx.lineTo(x, y + 12);
      ctx.stroke();
      break;

    case 'key':
      ctx.beginPath();
      ctx.arc(x - 10, y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillRect(x - 2, y - 3, 20, 6);
      ctx.fillRect(x + 12, y - 8, 3, 6);
      ctx.fillRect(x + 16, y - 8, 3, 6);
      break;

    case 'crystal':
      ctx.beginPath();
      ctx.moveTo(x, y - 20);
      ctx.lineTo(x + 12, y + 5);
      ctx.lineTo(x + 6, y + 15);
      ctx.lineTo(x - 6, y + 15);
      ctx.lineTo(x - 12, y + 5);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      break;

    case 'skull':
      ctx.beginPath();
      ctx.arc(x, y - 5, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#1a1410';
      ctx.beginPath();
      ctx.arc(x - 6, y - 8, 4, 0, Math.PI * 2);
      ctx.arc(x + 6, y - 8, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillRect(x - 4, y + 2, 8, 10);
      break;

    case 'clock':
      ctx.beginPath();
      ctx.arc(x, y, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.strokeStyle = '#1a1410';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - 10);
      ctx.moveTo(x, y);
      ctx.lineTo(x + 7, y);
      ctx.stroke();
      break;

    case 'mirror':
      ctx.beginPath();
      ctx.arc(x, y, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(200, 220, 255, 0.4)';
      ctx.beginPath();
      ctx.arc(x, y, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillRect(x - 3, y + 18, 6, 15);
      break;

    case 'compass':
      ctx.beginPath();
      ctx.arc(x, y, 18, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y - 15);
      ctx.lineTo(x - 4, y + 5);
      ctx.lineTo(x, y);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#8a4a4a';
      ctx.beginPath();
      ctx.moveTo(x, y - 15);
      ctx.lineTo(x + 4, y + 5);
      ctx.lineTo(x, y);
      ctx.closePath();
      ctx.fill();
      break;

    case 'chalice':
      ctx.beginPath();
      ctx.moveTo(x - 12, y - 15);
      ctx.lineTo(x - 8, y + 5);
      ctx.lineTo(x + 8, y + 5);
      ctx.lineTo(x + 12, y - 15);
      ctx.closePath();
      ctx.fill();
      ctx.fillRect(x - 2, y + 5, 4, 12);
      ctx.fillRect(x - 8, y + 17, 16, 3);
      break;

    case 'flame':
      ctx.beginPath();
      ctx.moveTo(x, y - 20);
      ctx.bezierCurveTo(x + 10, y - 15, x + 12, y, x, y + 10);
      ctx.bezierCurveTo(x - 12, y, x - 10, y - 15, x, y - 20);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = 'rgba(255, 255, 200, 0.6)';
      ctx.beginPath();
      ctx.moveTo(x, y - 15);
      ctx.bezierCurveTo(x + 6, y - 10, x + 8, y, x, y + 5);
      ctx.bezierCurveTo(x - 8, y, x - 6, y - 10, x, y - 15);
      ctx.closePath();
      ctx.fill();
      break;

    case 'eye':
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(x, y, 22, 14, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fill();
      break;

    case 'feather':
      ctx.beginPath();
      ctx.moveTo(x, y - 20);
      ctx.quadraticCurveTo(x + 5, y - 10, x + 8, y + 15);
      ctx.lineTo(x - 2, y + 15);
      ctx.quadraticCurveTo(x - 5, y - 10, x, y - 20);
      ctx.closePath();
      ctx.fill();
      for (let i = 0; i < 8; i++) {
        const py = y - 15 + i * 4;
        ctx.beginPath();
        ctx.moveTo(x, py);
        ctx.lineTo(x + 6, py + 2);
        ctx.stroke();
      }
      break;

    case 'hourglass':
      ctx.beginPath();
      ctx.moveTo(x - 10, y - 18);
      ctx.lineTo(x + 10, y - 18);
      ctx.lineTo(x + 3, y);
      ctx.lineTo(x + 10, y + 18);
      ctx.lineTo(x - 10, y + 18);
      ctx.lineTo(x - 3, y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#d8c8a4';
      ctx.beginPath();
      ctx.moveTo(x - 8, y + 18);
      ctx.lineTo(x + 8, y + 18);
      ctx.lineTo(x, y + 5);
      ctx.closePath();
      ctx.fill();
      break;

    case 'crown':
      ctx.beginPath();
      ctx.moveTo(x - 18, y + 5);
      ctx.lineTo(x - 12, y - 10);
      ctx.lineTo(x - 6, y + 5);
      ctx.lineTo(x, y - 15);
      ctx.lineTo(x + 6, y + 5);
      ctx.lineTo(x + 12, y - 10);
      ctx.lineTo(x + 18, y + 5);
      ctx.lineTo(x + 15, y + 12);
      ctx.lineTo(x - 15, y + 12);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      break;

    case 'bell':
      ctx.beginPath();
      ctx.moveTo(x - 15, y + 10);
      ctx.lineTo(x - 12, y - 5);
      ctx.quadraticCurveTo(x - 10, y - 12, x, y - 15);
      ctx.quadraticCurveTo(x + 10, y - 12, x + 12, y - 5);
      ctx.lineTo(x + 15, y + 10);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x, y + 14, 3, 0, Math.PI * 2);
      ctx.fill();
      break;
  }
}

// UI
function updateUI() {
  const roomCount = getRoomCount();

  // Navigation arrows
  const prevBtn = document.getElementById('prevRoom');
  const nextBtn = document.getElementById('nextRoom');

  prevBtn.classList.toggle('disabled', state.currentRoom === 0);
  nextBtn.classList.toggle('disabled', state.currentRoom >= roomCount - 1);

  // Room indicator
  const indicator = document.getElementById('roomIndicator');
  indicator.innerHTML = '';
  for (let i = 0; i < roomCount; i++) {
    const dot = document.createElement('div');
    dot.className = 'room-dot';
    if (i === state.currentRoom) dot.classList.add('active');
    dot.addEventListener('click', () => {
      if (i !== state.currentRoom) {
        goToRoom(i);
      }
    });
    indicator.appendChild(dot);
  }
}

function goToRoom(roomIndex) {
  if (state.transition.active) return;

  const roomCount = getRoomCount();
  if (roomIndex < 0 || roomIndex >= roomCount) return;

  playFootstep();
  state.transition.active = true;
  state.transition.progress = 0;
  state.transition.direction = roomIndex > state.currentRoom ? 1 : -1;
  state.transition.fromRoom = state.currentRoom;
  state.transition.toRoom = roomIndex;
}

// Overlay
function showAddTaskOverlay() {
  const overlay = document.getElementById('overlay');
  const content = document.getElementById('overlayContent');

  content.innerHTML = `
    <h2>Remember This</h2>
    <input type="text" id="taskInput" placeholder="What shall you place here?" autofocus>
    <div class="overlay-buttons">
      <button class="primary" id="addTaskBtn">Place</button>
      <button class="secondary" id="cancelBtn">Cancel</button>
    </div>
  `;

  overlay.classList.add('visible');

  const input = document.getElementById('taskInput');
  const addBtn = document.getElementById('addTaskBtn');
  const cancelBtn = document.getElementById('cancelBtn');

  const add = () => {
    const text = input.value.trim();
    if (text) {
      state.tasks.push({
        id: Date.now(),
        text,
        completed: false
      });
      saveState();
      updateUI();
      overlay.classList.remove('visible');
    }
  };

  addBtn.addEventListener('click', add);
  input.addEventListener('keypress', e => {
    if (e.key === 'Enter') add();
  });
  cancelBtn.addEventListener('click', () => {
    overlay.classList.remove('visible');
  });
}

function showTaskDetail(task) {
  const overlay = document.getElementById('overlay');
  const content = document.getElementById('overlayContent');

  const objectType = getObjectType(task.text);
  const emoji = {
    orb: 'üîÆ', book: 'üìñ', key: 'üîë', crystal: 'üíé', skull: 'üíÄ',
    clock: 'üï∞Ô∏è', mirror: 'ü™û', compass: 'üß≠', chalice: 'üèÜ', flame: 'üî•',
    eye: 'üëÅÔ∏è', feather: 'ü™∂', hourglass: '‚è≥', crown: 'üëë', bell: 'üîî'
  };

  content.innerHTML = `
    <div class="task-detail">
      <div class="object-name">${emoji[objectType] || '‚ú®'}</div>
      <div class="task-text">${task.text}</div>
      <div class="actions">
        ${!task.completed ? `<button class="complete" id="completeBtn">Complete</button>` : ''}
        <button class="delete" id="deleteBtn">Remove</button>
        <button class="cancel" id="cancelDetailBtn">Close</button>
      </div>
    </div>
  `;

  overlay.classList.add('visible');

  const completeBtn = document.getElementById('completeBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const cancelBtn = document.getElementById('cancelDetailBtn');

  if (completeBtn) {
    completeBtn.addEventListener('click', () => {
      task.completed = true;
      saveState();
      playComplete();

      // Find task position and create particles
      const roomTasks = getTasksInRoom(state.currentRoom);
      const taskIndex = roomTasks.findIndex(t => t.id === task.id);
      if (taskIndex >= 0) {
        const positions = [
          { x: cx - 200, y: h * 0.65 - 30 },
          { x: cx - 100, y: h * 0.65 - 30 },
          { x: cx, y: h * 0.65 - 30 },
          { x: cx + 100, y: h * 0.65 - 30 },
          { x: cx + 200, y: h * 0.65 - 30 }
        ];
        const pos = positions[taskIndex];
        const color = getObjectColor(task.text);
        createCompleteParticles(pos.x, pos.y, color);
      }

      state.selectedTask = null;
      overlay.classList.remove('visible');
    });
  }

  deleteBtn.addEventListener('click', () => {
    const index = state.tasks.findIndex(t => t.id === task.id);
    if (index >= 0) {
      // Create shatter particles
      const roomTasks = getTasksInRoom(state.currentRoom);
      const taskIndex = roomTasks.findIndex(t => t.id === task.id);
      if (taskIndex >= 0) {
        const positions = [
          { x: cx - 200, y: h * 0.65 - 30 },
          { x: cx - 100, y: h * 0.65 - 30 },
          { x: cx, y: h * 0.65 - 30 },
          { x: cx + 100, y: h * 0.65 - 30 },
          { x: cx + 200, y: h * 0.65 - 30 }
        ];
        const pos = positions[taskIndex];
        const color = getObjectColor(task.text);
        createShatterParticles(pos.x, pos.y, color);
      }

      playShatter();
      state.tasks.splice(index, 1);
      saveState();

      // Adjust current room if needed
      const roomCount = getRoomCount();
      if (state.currentRoom >= roomCount && roomCount > 0) {
        state.currentRoom = roomCount - 1;
      }

      updateUI();
    }
    state.selectedTask = null;
    overlay.classList.remove('visible');
  });

  cancelBtn.addEventListener('click', () => {
    state.selectedTask = null;
    overlay.classList.remove('visible');
  });
}

// Click handling
canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Check for object clicks
  const roomTasks = getTasksInRoom(state.currentRoom);
  const positions = [
    { x: cx - 200, y: h * 0.65, w: 50, h: 60 },
    { x: cx - 100, y: h * 0.65, w: 50, h: 60 },
    { x: cx, y: h * 0.65, w: 50, h: 60 },
    { x: cx + 100, y: h * 0.65, w: 50, h: 60 },
    { x: cx + 200, y: h * 0.65, w: 50, h: 60 }
  ];

  for (let i = 0; i < positions.length; i++) {
    const pos = positions[i];
    if (Math.abs(x - pos.x) < 40 && Math.abs(y - pos.y) < 50) {
      if (i < roomTasks.length) {
        // Click on existing object
        state.selectedTask = roomTasks[i];
        playChime();
        showTaskDetail(roomTasks[i]);
        return;
      } else {
        // Click on empty pedestal
        showAddTaskOverlay();
        return;
      }
    }
  }
});

// Keyboard navigation
document.addEventListener('keydown', e => {
  if (document.getElementById('overlay').classList.contains('visible')) return;

  if (e.key === 'ArrowLeft') {
    if (state.currentRoom > 0) {
      goToRoom(state.currentRoom - 1);
    }
  } else if (e.key === 'ArrowRight') {
    const roomCount = getRoomCount();
    if (state.currentRoom < roomCount - 1) {
      goToRoom(state.currentRoom + 1);
    }
  } else if (e.key === 'Enter') {
    showAddTaskOverlay();
  }
});

// Navigation buttons
document.getElementById('prevRoom').addEventListener('click', () => {
  if (state.currentRoom > 0) {
    goToRoom(state.currentRoom - 1);
  }
});

document.getElementById('nextRoom').addEventListener('click', () => {
  const roomCount = getRoomCount();
  if (state.currentRoom < roomCount - 1) {
    goToRoom(state.currentRoom + 1);
  }
});

// Close overlay on background click
document.getElementById('overlay').addEventListener('click', e => {
  if (e.target.id === 'overlay') {
    state.selectedTask = null;
    e.target.classList.remove('visible');
  }
});

// Animation loop
function animate() {
  ctx.fillStyle = '#1a1410';
  ctx.fillRect(0, 0, w, h);

  if (state.transition.active) {
    // Room transition
    state.transition.progress += 0.06;

    if (state.transition.progress >= 1) {
      state.transition.active = false;
      state.currentRoom = state.transition.toRoom;
      updateUI();
    } else {
      const ease = 1 - Math.pow(1 - state.transition.progress, 3);
      const offset = ease * w * state.transition.direction;

      drawRoom(state.transition.fromRoom, -offset, 1 - ease);
      drawRoom(state.transition.toRoom, w * state.transition.direction - offset, ease);
    }
  } else {
    drawRoom(state.currentRoom);
  }

  updateParticles();
  drawParticles();

  requestAnimationFrame(animate);
}

// Initialize
loadState();
updateUI();
animate();

</script>
</body>
</html>
