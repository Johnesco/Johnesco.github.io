<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Island — 3D</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        canvas { display: block; }
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 10px 15px;
            border-radius: 5px;
            line-height: 1.6;
        }
        #prompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 22px;
            text-align: center;
            background: rgba(0,0,0,0.7);
            padding: 30px 50px;
            border-radius: 10px;
            cursor: pointer;
        }
        #prompt.hidden { display: none; }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.5);
            font-size: 24px;
            pointer-events: none;
        }
        #crosshair.hidden { display: none; }
    </style>
</head>
<body>
    <div id="info"></div>
    <div id="prompt">Click to explore the island</div>
    <div id="crosshair" class="hidden">+</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // ===== PERLIN NOISE =====
        class PerlinNoise {
            constructor(seed) {
                this.perm = new Uint8Array(512);
                const p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) p[i] = i;

                // Seed-based shuffle
                let s = Math.floor(seed * 2147483647) || 1;
                for (let i = 255; i > 0; i--) {
                    s = (s * 16807) % 2147483647;
                    const j = s % (i + 1);
                    const tmp = p[i]; p[i] = p[j]; p[j] = tmp;
                }
                for (let i = 0; i < 512; i++) this.perm[i] = p[i & 255];
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }

            grad(hash, x, y) {
                const h = hash & 3;
                return ((h & 1) ? -x : x) + ((h & 2) ? -y : y);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const a = this.perm[X] + Y;
                const b = this.perm[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[a], x, y), this.grad(this.perm[b], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[a + 1], x, y - 1), this.grad(this.perm[b + 1], x - 1, y - 1))
                );
            }

            octaveNoise(x, y, octaves) {
                let total = 0, amplitude = 1, frequency = 1, maxVal = 0;
                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency) * amplitude;
                    maxVal += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                return total / maxVal;
            }
        }

        // ===== SETUP =====
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        const camera = new THREE.PerspectiveCamera(
            70, window.innerWidth / window.innerHeight, 0.1, 2000
        );
        camera.rotation.order = 'YXZ';

        // ===== LIGHTING =====
        const sun = new THREE.DirectionalLight(0xfff5e0, 1.5);
        sun.position.set(150, 200, 100);
        scene.add(sun);

        const ambient = new THREE.AmbientLight(0x8090a0, 0.6);
        scene.add(ambient);

        // ===== DAY/NIGHT CYCLE =====
        // Colors for sky and light at different times
        function updateDayNight() {
            const now = new Date();
            const h = now.getHours() + now.getMinutes() / 60;

            // Sun angle: noon = directly overhead, midnight = directly below
            const sunAngle = ((h - 6) / 24) * Math.PI * 2;
            const sunY = Math.sin(sunAngle) * 200;
            const sunXZ = Math.cos(sunAngle) * 200;
            sun.position.set(sunXZ, sunY, 50);

            // How high is the sun? (-1 to 1)
            const sunHeight = Math.sin(sunAngle);

            let skyColor, lightColor, lightIntensity, ambientColor, ambientIntensity;

            if (sunHeight > 0.3) {
                // Full day
                skyColor = new THREE.Color(0x87ceeb);
                lightColor = new THREE.Color(0xfff5e0);
                lightIntensity = 1.5;
                ambientColor = new THREE.Color(0x8090a0);
                ambientIntensity = 0.6;
            } else if (sunHeight > 0) {
                // Dawn / dusk — interpolate
                const t = sunHeight / 0.3;
                skyColor = new THREE.Color(0x87ceeb).lerp(new THREE.Color(0xd46030), 1 - t);
                lightColor = new THREE.Color(0xffaa55);
                lightIntensity = 0.5 + t * 1.0;
                ambientColor = new THREE.Color(0x604030).lerp(new THREE.Color(0x8090a0), t);
                ambientIntensity = 0.4 + t * 0.2;
            } else if (sunHeight > -0.3) {
                // Twilight
                const t = (sunHeight + 0.3) / 0.3;
                skyColor = new THREE.Color(0x0a0a2a).lerp(new THREE.Color(0xd46030), t);
                lightColor = new THREE.Color(0x4466aa);
                lightIntensity = 0.1 + t * 0.4;
                ambientColor = new THREE.Color(0x101830).lerp(new THREE.Color(0x604030), t);
                ambientIntensity = 0.2 + t * 0.2;
            } else {
                // Night
                skyColor = new THREE.Color(0x060612);
                lightColor = new THREE.Color(0x3344aa);
                lightIntensity = 0.15;
                ambientColor = new THREE.Color(0x0a0a20);
                ambientIntensity = 0.15;
            }

            scene.background = skyColor;
            sun.color = lightColor;
            sun.intensity = lightIntensity;
            ambient.color = ambientColor;
            ambient.intensity = ambientIntensity;

            // Return time string for HUD
            return now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
        }

        // ===== TERRAIN =====
        const ISLAND_SIZE = 400;
        const SEGMENTS = 200;
        const MAX_HEIGHT = 60;

        const noise = new PerlinNoise(0.7321);

        const terrainGeo = new THREE.PlaneGeometry(ISLAND_SIZE, ISLAND_SIZE, SEGMENTS, SEGMENTS);
        terrainGeo.rotateX(-Math.PI / 2);

        const pos = terrainGeo.attributes.position.array;
        const vertCount = pos.length / 3;
        const colorArray = new Float32Array(vertCount * 3);

        const center = ISLAND_SIZE / 2;

        for (let i = 0; i < vertCount; i++) {
            const ix = i * 3;
            const x = pos[ix];
            const z = pos[ix + 2];

            // Normalized distance from center (0 at center, 1 at edge)
            const dx = x / (ISLAND_SIZE * 0.42);
            const dz = z / (ISLAND_SIZE * 0.42);
            const dist = Math.sqrt(dx * dx + dz * dz);

            // Radial falloff — 1 at center, 0 at edges
            const falloff = Math.max(0, 1 - dist);
            const smoothFalloff = falloff * falloff * (3 - 2 * falloff); // smoothstep

            // Noise-based height
            const n = noise.octaveNoise(x * 0.008, z * 0.008, 5);
            const height = ((n + 1) / 2) * smoothFalloff * MAX_HEIGHT;

            pos[ix + 1] = height;

            // Vertex color by height
            let r, g, b;
            if (height < 0.5) {
                // Underwater (won't be seen much — water covers it)
                r = 0.1; g = 0.25; b = 0.4;
            } else if (height < 3) {
                // Wet sand
                r = 0.77; g = 0.66; b = 0.41;
            } else if (height < 6) {
                // Dry sand
                r = 0.83; g = 0.72; b = 0.56;
            } else if (height < 15) {
                // Light grass
                const t = (height - 6) / 9;
                r = 0.83 - t * 0.48;
                g = 0.72 - t * 0.18;
                b = 0.56 - t * 0.39;
            } else if (height < 30) {
                // Dark grass / forest
                const t = (height - 15) / 15;
                r = 0.35 - t * 0.12;
                g = 0.54 - t * 0.12;
                b = 0.17 - t * 0.02;
            } else if (height < 42) {
                // Rock
                const t = (height - 30) / 12;
                r = 0.23 + t * 0.19;
                g = 0.42 - t * 0.06;
                b = 0.15 + t * 0.25;
            } else if (height < 52) {
                // High rock
                r = 0.42; g = 0.40; b = 0.38;
            } else {
                // Snow
                const t = Math.min(1, (height - 52) / 8);
                r = 0.42 + t * 0.45;
                g = 0.40 + t * 0.47;
                b = 0.38 + t * 0.50;
            }

            colorArray[ix] = r;
            colorArray[ix + 1] = g;
            colorArray[ix + 2] = b;
        }

        terrainGeo.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));
        terrainGeo.computeVertexNormals();

        const terrainMat = new THREE.MeshLambertMaterial({ vertexColors: true });
        const terrainMesh = new THREE.Mesh(terrainGeo, terrainMat);
        scene.add(terrainMesh);

        // ===== WATER =====
        const waterGeo = new THREE.PlaneGeometry(800, 800, 1, 1);
        waterGeo.rotateX(-Math.PI / 2);

        const waterMat = new THREE.MeshPhongMaterial({
            color: 0x1a6a8a,
            transparent: true,
            opacity: 0.75,
            shininess: 80
        });
        const waterMesh = new THREE.Mesh(waterGeo, waterMat);
        waterMesh.position.y = 0.3;
        scene.add(waterMesh);

        // ===== TERRAIN HEIGHT LOOKUP =====
        // Bilinear interpolation of vertex heights
        function getTerrainHeight(wx, wz) {
            const half = ISLAND_SIZE / 2;
            // Clamp to terrain bounds
            const cx = Math.max(-half, Math.min(half, wx));
            const cz = Math.max(-half, Math.min(half, wz));

            // Convert world coords to grid coords
            const gx = ((cx + half) / ISLAND_SIZE) * SEGMENTS;
            const gz = ((cz + half) / ISLAND_SIZE) * SEGMENTS;

            const x0 = Math.floor(gx);
            const z0 = Math.floor(gz);
            const x1 = Math.min(x0 + 1, SEGMENTS);
            const z1 = Math.min(z0 + 1, SEGMENTS);

            const tx = gx - x0;
            const tz = gz - z0;

            // Vertex index to Y height
            const getY = (gxi, gzi) => pos[(gzi * (SEGMENTS + 1) + gxi) * 3 + 1];

            const h00 = getY(x0, z0);
            const h10 = getY(x1, z0);
            const h01 = getY(x0, z1);
            const h11 = getY(x1, z1);

            // Bilinear interpolation
            const h0 = h00 + (h10 - h00) * tx;
            const h1 = h01 + (h11 - h01) * tx;
            return h0 + (h1 - h0) * tz;
        }

        // ===== FIND START POSITION =====
        // Search for a nice beach spot (height 3-8) near the south side
        let startX = 0, startZ = 50;
        let bestDist = Infinity;
        for (let i = 0; i < vertCount; i++) {
            const ix = i * 3;
            const h = pos[ix + 1];
            if (h > 3 && h < 8) {
                const x = pos[ix];
                const z = pos[ix + 2];
                // Prefer south side (positive Z)
                const d = x * x + (z - 50) * (z - 50);
                if (d < bestDist) {
                    bestDist = d;
                    startX = x;
                    startZ = z;
                }
            }
        }

        // Place camera at start position
        const EYE_HEIGHT = 1.7;
        camera.position.set(startX, getTerrainHeight(startX, startZ) + EYE_HEIGHT, startZ);

        // ===== FIRST-PERSON CONTROLS =====
        let yaw = 0;
        let pitch = 0;
        let locked = false;
        const keys = {};

        const MOVE_SPEED = 12;
        const SPRINT_MULT = 2.0;
        const MOUSE_SENS = 0.002;
        const WATER_LEVEL = 1.0; // can't walk below this terrain height

        // Pointer lock
        const promptEl = document.getElementById('prompt');
        const crosshairEl = document.getElementById('crosshair');
        const canvas = renderer.domElement;

        promptEl.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            locked = document.pointerLockElement === canvas;
            promptEl.classList.toggle('hidden', locked);
            crosshairEl.classList.toggle('hidden', !locked);
        });

        // Mouse look
        document.addEventListener('mousemove', (e) => {
            if (!locked) return;
            yaw -= e.movementX * MOUSE_SENS;
            pitch -= e.movementY * MOUSE_SENS;
            pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, pitch));
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // ===== RESIZE =====
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ===== ANIMATE =====
        const clock = new THREE.Clock();
        const infoEl = document.getElementById('info');

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);

            // Apply mouse look to camera
            camera.rotation.set(pitch, yaw, 0);

            // Movement
            if (locked) {
                // Forward and right vectors from yaw (ignore pitch for movement)
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

                const right = new THREE.Vector3(1, 0, 0);
                right.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

                let speed = MOVE_SPEED * delta;
                if (keys['ShiftLeft'] || keys['ShiftRight']) speed *= SPRINT_MULT;

                const prevPos = camera.position.clone();

                if (keys['KeyW'] || keys['ArrowUp']) camera.position.addScaledVector(forward, speed);
                if (keys['KeyS'] || keys['ArrowDown']) camera.position.addScaledVector(forward, -speed);
                if (keys['KeyA'] || keys['ArrowLeft']) camera.position.addScaledVector(right, -speed);
                if (keys['KeyD'] || keys['ArrowRight']) camera.position.addScaledVector(right, speed);

                // Clamp to map
                camera.position.x = Math.max(-195, Math.min(195, camera.position.x));
                camera.position.z = Math.max(-195, Math.min(195, camera.position.z));

                // Terrain following + water collision
                const h = getTerrainHeight(camera.position.x, camera.position.z);
                if (h < WATER_LEVEL) {
                    // Revert — can't walk into water
                    camera.position.copy(prevPos);
                } else {
                    camera.position.y = h + EYE_HEIGHT;
                }
            }

            // Day/night
            const timeStr = updateDayNight();

            // HUD
            const h = getTerrainHeight(camera.position.x, camera.position.z);
            const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            const dirIdx = Math.round((((-yaw % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2)) / (Math.PI / 4)) % 8;
            infoEl.innerHTML =
                `${timeStr} &middot; ${dirs[dirIdx]}<br>` +
                `Height: ${h.toFixed(1)}<br>` +
                `WASD to walk &middot; Shift to run`;

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
