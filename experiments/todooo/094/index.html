<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Island — 3D</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        canvas { display: block; }
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 10px 15px;
            border-radius: 5px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div id="info">Layer 1: Terrain + Water + Sky<br>Camera auto-orbits. Just watch.</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // ===== PERLIN NOISE =====
        class PerlinNoise {
            constructor(seed) {
                this.perm = new Uint8Array(512);
                const p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) p[i] = i;

                // Seed-based shuffle
                let s = Math.floor(seed * 2147483647) || 1;
                for (let i = 255; i > 0; i--) {
                    s = (s * 16807) % 2147483647;
                    const j = s % (i + 1);
                    const tmp = p[i]; p[i] = p[j]; p[j] = tmp;
                }
                for (let i = 0; i < 512; i++) this.perm[i] = p[i & 255];
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }

            grad(hash, x, y) {
                const h = hash & 3;
                return ((h & 1) ? -x : x) + ((h & 2) ? -y : y);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const a = this.perm[X] + Y;
                const b = this.perm[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[a], x, y), this.grad(this.perm[b], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[a + 1], x, y - 1), this.grad(this.perm[b + 1], x - 1, y - 1))
                );
            }

            octaveNoise(x, y, octaves) {
                let total = 0, amplitude = 1, frequency = 1, maxVal = 0;
                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency) * amplitude;
                    maxVal += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                return total / maxVal;
            }
        }

        // ===== SETUP =====
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        const camera = new THREE.PerspectiveCamera(
            60, window.innerWidth / window.innerHeight, 0.1, 2000
        );

        // ===== LIGHTING =====
        const sun = new THREE.DirectionalLight(0xfff5e0, 1.5);
        sun.position.set(150, 200, 100);
        scene.add(sun);

        const ambient = new THREE.AmbientLight(0x8090a0, 0.6);
        scene.add(ambient);

        // ===== TERRAIN =====
        const ISLAND_SIZE = 400;
        const SEGMENTS = 200;
        const MAX_HEIGHT = 60;

        const noise = new PerlinNoise(0.7321);

        const terrainGeo = new THREE.PlaneGeometry(ISLAND_SIZE, ISLAND_SIZE, SEGMENTS, SEGMENTS);
        terrainGeo.rotateX(-Math.PI / 2);

        const pos = terrainGeo.attributes.position.array;
        const vertCount = pos.length / 3;
        const colorArray = new Float32Array(vertCount * 3);

        const center = ISLAND_SIZE / 2;

        for (let i = 0; i < vertCount; i++) {
            const ix = i * 3;
            const x = pos[ix];
            const z = pos[ix + 2];

            // Normalized distance from center (0 at center, 1 at edge)
            const dx = x / (ISLAND_SIZE * 0.42);
            const dz = z / (ISLAND_SIZE * 0.42);
            const dist = Math.sqrt(dx * dx + dz * dz);

            // Radial falloff — 1 at center, 0 at edges
            const falloff = Math.max(0, 1 - dist);
            const smoothFalloff = falloff * falloff * (3 - 2 * falloff); // smoothstep

            // Noise-based height
            const n = noise.octaveNoise(x * 0.008, z * 0.008, 5);
            const height = ((n + 1) / 2) * smoothFalloff * MAX_HEIGHT;

            pos[ix + 1] = height;

            // Vertex color by height
            let r, g, b;
            if (height < 0.5) {
                // Underwater (won't be seen much — water covers it)
                r = 0.1; g = 0.25; b = 0.4;
            } else if (height < 3) {
                // Wet sand
                r = 0.77; g = 0.66; b = 0.41;
            } else if (height < 6) {
                // Dry sand
                r = 0.83; g = 0.72; b = 0.56;
            } else if (height < 15) {
                // Light grass
                const t = (height - 6) / 9;
                r = 0.83 - t * 0.48;
                g = 0.72 - t * 0.18;
                b = 0.56 - t * 0.39;
            } else if (height < 30) {
                // Dark grass / forest
                const t = (height - 15) / 15;
                r = 0.35 - t * 0.12;
                g = 0.54 - t * 0.12;
                b = 0.17 - t * 0.02;
            } else if (height < 42) {
                // Rock
                const t = (height - 30) / 12;
                r = 0.23 + t * 0.19;
                g = 0.42 - t * 0.06;
                b = 0.15 + t * 0.25;
            } else if (height < 52) {
                // High rock
                r = 0.42; g = 0.40; b = 0.38;
            } else {
                // Snow
                const t = Math.min(1, (height - 52) / 8);
                r = 0.42 + t * 0.45;
                g = 0.40 + t * 0.47;
                b = 0.38 + t * 0.50;
            }

            colorArray[ix] = r;
            colorArray[ix + 1] = g;
            colorArray[ix + 2] = b;
        }

        terrainGeo.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));
        terrainGeo.computeVertexNormals();

        const terrainMat = new THREE.MeshLambertMaterial({ vertexColors: true });
        const terrainMesh = new THREE.Mesh(terrainGeo, terrainMat);
        scene.add(terrainMesh);

        // ===== WATER =====
        const waterGeo = new THREE.PlaneGeometry(800, 800, 1, 1);
        waterGeo.rotateX(-Math.PI / 2);

        const waterMat = new THREE.MeshPhongMaterial({
            color: 0x1a6a8a,
            transparent: true,
            opacity: 0.75,
            shininess: 80
        });
        const waterMesh = new THREE.Mesh(waterGeo, waterMat);
        waterMesh.position.y = 0.3;
        scene.add(waterMesh);

        // ===== CAMERA ORBIT =====
        const orbitRadius = 280;
        const orbitHeight = 120;
        const orbitSpeed = 0.15; // radians per second
        const lookAtY = 15;

        // ===== RESIZE =====
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ===== ANIMATE =====
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsed = clock.getElapsedTime();

            // Orbit camera around the island
            camera.position.x = Math.cos(elapsed * orbitSpeed) * orbitRadius;
            camera.position.z = Math.sin(elapsed * orbitSpeed) * orbitRadius;
            camera.position.y = orbitHeight;
            camera.lookAt(0, lookAtY, 0);

            renderer.render(scene, camera);
        }

        animate();

        document.getElementById('info').innerHTML =
            'Layer 1: Terrain + Water + Sky<br>' +
            'Camera auto-orbits the island.<br>' +
            'Seed: 0.7321 &middot; ' + vertCount + ' vertices';
    </script>
</body>
</html>
