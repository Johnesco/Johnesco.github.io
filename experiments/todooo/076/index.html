<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snowglobe - Todooo 076</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Georgia', serif;
  background: #1a1410;
  color: #f5e6d3;
  overflow: hidden;
  width: 100vw;
  height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#canvas {
  display: block;
  cursor: grab;
}

#canvas:active {
  cursor: grabbing;
}

.ui-container {
  position: absolute;
  bottom: 40px;
  width: 500px;
  max-width: 90vw;
  text-align: center;
}

.warmth-indicator {
  font-size: 14px;
  color: #d4a574;
  margin-bottom: 20px;
  font-style: italic;
  text-shadow: 0 0 10px rgba(255, 160, 80, 0.3);
}

.task-list {
  background: rgba(40, 30, 25, 0.8);
  border-radius: 8px;
  padding: 15px;
  max-height: 150px;
  overflow-y: auto;
  margin-bottom: 15px;
  backdrop-filter: blur(10px);
}

.task-item {
  display: flex;
  align-items: center;
  padding: 8px 10px;
  margin: 5px 0;
  background: rgba(60, 45, 35, 0.6);
  border-radius: 5px;
  cursor: pointer;
  transition: all 0.2s;
  border: 1px solid transparent;
}

.task-item:hover {
  background: rgba(80, 60, 45, 0.8);
  border-color: #8a6a3a;
}

.task-item.selected {
  border-color: #d4a574;
  background: rgba(100, 75, 55, 0.8);
}

.task-item.completed {
  opacity: 0.7;
}

.task-checkbox {
  width: 16px;
  height: 16px;
  margin-right: 10px;
  cursor: pointer;
  accent-color: #d4a574;
}

.task-text {
  flex: 1;
  text-align: left;
  font-size: 13px;
  color: #f5e6d3;
}

.task-item.completed .task-text {
  text-decoration: line-through;
  color: #b89968;
}

.task-delete {
  margin-left: 10px;
  color: #a67a5a;
  cursor: pointer;
  font-size: 16px;
  padding: 0 5px;
  transition: color 0.2s;
}

.task-delete:hover {
  color: #d4a574;
}

.add-task-form {
  display: flex;
  gap: 10px;
}

.add-task-input {
  flex: 1;
  padding: 10px 15px;
  background: rgba(60, 45, 35, 0.8);
  border: 1px solid #5a3a1a;
  border-radius: 5px;
  color: #f5e6d3;
  font-size: 14px;
  font-family: 'Georgia', serif;
}

.add-task-input:focus {
  outline: none;
  border-color: #8a6a3a;
  background: rgba(80, 60, 45, 0.9);
}

.add-task-button {
  padding: 10px 20px;
  background: #5a3a1a;
  border: 1px solid #8a6a3a;
  border-radius: 5px;
  color: #f5e6d3;
  cursor: pointer;
  font-family: 'Georgia', serif;
  font-size: 14px;
  transition: all 0.2s;
}

.add-task-button:hover {
  background: #6a4a2a;
  border-color: #a87a4a;
}

.task-list::-webkit-scrollbar {
  width: 8px;
}

.task-list::-webkit-scrollbar-track {
  background: rgba(30, 20, 15, 0.5);
  border-radius: 4px;
}

.task-list::-webkit-scrollbar-thumb {
  background: #5a3a1a;
  border-radius: 4px;
}

.task-list::-webkit-scrollbar-thumb:hover {
  background: #6a4a2a;
}
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="ui-container">
  <div class="warmth-indicator" id="warmth">No lights glowing yet</div>

  <div class="task-list" id="taskList"></div>

  <form class="add-task-form" id="addTaskForm">
    <input
      type="text"
      class="add-task-input"
      id="taskInput"
      placeholder="Add a new wish to your world..."
      autocomplete="off"
    >
    <button type="submit" class="add-task-button">Add</button>
  </form>
</div>

<script>
// ============================================================================
// STATE & STORAGE
// ============================================================================

const STORAGE_KEY = 'todooo-076';

let tasks = [];
let selectedTaskId = null;

function loadTasks() {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
      tasks = JSON.parse(stored);
    }
  } catch (e) {
    console.error('Failed to load tasks:', e);
  }
}

function saveTasks() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
  } catch (e) {
    console.error('Failed to save tasks:', e);
  }
}

function addTask(text) {
  const task = {
    id: Date.now() + Math.random(),
    text: text.trim(),
    completed: false,
    createdAt: Date.now()
  };
  tasks.push(task);
  saveTasks();
  renderTaskList();
  initMusicBox();
}

function deleteTask(id) {
  tasks = tasks.filter(t => t.id !== id);
  if (selectedTaskId === id) selectedTaskId = null;
  saveTasks();
  renderTaskList();
  initMusicBox();
}

function toggleTask(id) {
  const task = tasks.find(t => t.id === id);
  if (task) {
    task.completed = !task.completed;
    saveTasks();
    renderTaskList();
  }
}

function selectTask(id) {
  selectedTaskId = selectedTaskId === id ? null : id;
  renderTaskList();
}

// ============================================================================
// UI RENDERING
// ============================================================================

function renderTaskList() {
  const container = document.getElementById('taskList');
  const warmth = document.getElementById('warmth');

  const completed = tasks.filter(t => t.completed).length;
  if (completed === 0) {
    warmth.textContent = 'No lights glowing yet';
  } else if (completed === 1) {
    warmth.textContent = '1 little light glowing';
  } else {
    warmth.textContent = `${completed} little lights glowing`;
  }

  if (tasks.length === 0) {
    container.innerHTML = '<div style="color: #8a6a5a; font-style: italic; padding: 10px;">Your snowglobe awaits...</div>';
    return;
  }

  container.innerHTML = tasks.map(task => `
    <div class="task-item ${task.completed ? 'completed' : ''} ${selectedTaskId === task.id ? 'selected' : ''}"
         data-id="${task.id}">
      <input type="checkbox"
             class="task-checkbox"
             ${task.completed ? 'checked' : ''}
             data-id="${task.id}">
      <span class="task-text">${escapeHtml(task.text)}</span>
      <span class="task-delete" data-id="${task.id}">Ã—</span>
    </div>
  `).join('');

  // Event listeners
  container.querySelectorAll('.task-item').forEach(el => {
    el.addEventListener('click', (e) => {
      if (!e.target.classList.contains('task-checkbox') &&
          !e.target.classList.contains('task-delete')) {
        selectTask(parseFloat(el.dataset.id));
      }
    });
  });

  container.querySelectorAll('.task-checkbox').forEach(el => {
    el.addEventListener('change', (e) => {
      e.stopPropagation();
      toggleTask(parseFloat(el.dataset.id));
    });
  });

  container.querySelectorAll('.task-delete').forEach(el => {
    el.addEventListener('click', (e) => {
      e.stopPropagation();
      deleteTask(parseFloat(el.dataset.id));
    });
  });
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Form handling
document.getElementById('addTaskForm').addEventListener('submit', (e) => {
  e.preventDefault();
  const input = document.getElementById('taskInput');
  const text = input.value.trim();
  if (text) {
    addTask(text);
    input.value = '';
  }
});

// ============================================================================
// CANVAS SETUP
// ============================================================================

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width, height, centerX, centerY, globeRadius, baseY, baseHeight;

function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;

  centerX = width / 2;
  centerY = height / 2;

  const maxGlobeSize = Math.min(width, height) * 0.7;
  globeRadius = maxGlobeSize / 2;

  baseHeight = globeRadius * 0.3;
  baseY = centerY + globeRadius * 0.8;

  initSnowParticles();
}

window.addEventListener('resize', resize);
resize();

// ============================================================================
// SCENE ELEMENTS (TASKS)
// ============================================================================

function hashString(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}

function getElementType(text) {
  const hash = hashString(text);
  const types = ['house', 'tree', 'lamppost', 'figure', 'church'];
  return types[hash % types.length];
}

function getElementPosition(task, index, total) {
  const hash = hashString(task.text);
  const groundY = centerY + globeRadius * 0.4;

  // Distribute along the ground with some hash-based variance
  const baseX = centerX - globeRadius * 0.6 + (index / Math.max(1, total - 1)) * globeRadius * 1.2;
  const offsetX = ((hash % 100) - 50) * 0.3;

  return {
    x: baseX + offsetX,
    y: groundY,
    type: getElementType(task.text),
    scale: 0.8 + (hash % 40) / 100
  };
}

function drawElement(x, y, type, scale, glowing, selected) {
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(scale, scale);

  // Glow effect for completed tasks
  if (glowing) {
    const gradient = ctx.createRadialGradient(0, -10, 0, 0, -10, 30);
    gradient.addColorStop(0, 'rgba(255, 160, 60, 0.4)');
    gradient.addColorStop(1, 'rgba(255, 100, 20, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(-30, -40, 60, 60);
  }

  // Selection highlight
  if (selected) {
    ctx.strokeStyle = 'rgba(212, 165, 116, 0.8)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, -15, 25, 0, Math.PI * 2);
    ctx.stroke();
  }

  switch (type) {
    case 'house':
      // Walls
      ctx.fillStyle = '#8a6a4a';
      ctx.fillRect(-12, -20, 24, 20);
      // Roof
      ctx.fillStyle = '#6a4a3a';
      ctx.beginPath();
      ctx.moveTo(-15, -20);
      ctx.lineTo(0, -35);
      ctx.lineTo(15, -20);
      ctx.closePath();
      ctx.fill();
      // Window
      ctx.fillStyle = glowing ? '#ffdd88' : '#4a3a2a';
      ctx.fillRect(-5, -12, 10, 8);
      if (glowing) {
        const glow = ctx.createRadialGradient(0, -8, 0, 0, -8, 15);
        glow.addColorStop(0, 'rgba(255, 221, 136, 0.6)');
        glow.addColorStop(1, 'rgba(255, 180, 80, 0)');
        ctx.fillStyle = glow;
        ctx.fillRect(-10, -15, 20, 15);
      }
      break;

    case 'tree':
      // Trunk
      ctx.fillStyle = '#5a3a2a';
      ctx.fillRect(-3, -10, 6, 10);
      // Foliage
      ctx.fillStyle = glowing ? '#4a8a4a' : '#2a5a3a';
      ctx.beginPath();
      ctx.moveTo(0, -35);
      ctx.lineTo(-12, -15);
      ctx.lineTo(12, -15);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(0, -28);
      ctx.lineTo(-10, -12);
      ctx.lineTo(10, -12);
      ctx.closePath();
      ctx.fill();
      break;

    case 'lamppost':
      // Post
      ctx.strokeStyle = '#3a3a3a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -30);
      ctx.stroke();
      // Lamp
      ctx.fillStyle = glowing ? '#ffee99' : '#5a5a5a';
      ctx.beginPath();
      ctx.arc(0, -30, 5, 0, Math.PI * 2);
      ctx.fill();
      if (glowing) {
        const lampGlow = ctx.createRadialGradient(0, -30, 0, 0, -30, 20);
        lampGlow.addColorStop(0, 'rgba(255, 238, 153, 0.8)');
        lampGlow.addColorStop(1, 'rgba(255, 200, 100, 0)');
        ctx.fillStyle = lampGlow;
        ctx.beginPath();
        ctx.arc(0, -30, 20, 0, Math.PI * 2);
        ctx.fill();
      }
      break;

    case 'figure':
      // Head
      ctx.fillStyle = glowing ? '#d4a574' : '#8a6a5a';
      ctx.beginPath();
      ctx.arc(0, -25, 4, 0, Math.PI * 2);
      ctx.fill();
      // Body
      ctx.strokeStyle = glowing ? '#d4a574' : '#8a6a5a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, -21);
      ctx.lineTo(0, -10);
      ctx.stroke();
      // Arms
      ctx.beginPath();
      ctx.moveTo(-6, -15);
      ctx.lineTo(6, -15);
      ctx.stroke();
      // Legs
      ctx.beginPath();
      ctx.moveTo(0, -10);
      ctx.lineTo(-4, 0);
      ctx.moveTo(0, -10);
      ctx.lineTo(4, 0);
      ctx.stroke();
      break;

    case 'church':
      // Building
      ctx.fillStyle = '#a08a7a';
      ctx.fillRect(-10, -30, 20, 30);
      // Steeple
      ctx.fillRect(-5, -45, 10, 15);
      ctx.fillStyle = '#8a7a6a';
      ctx.beginPath();
      ctx.moveTo(-6, -45);
      ctx.lineTo(0, -55);
      ctx.lineTo(6, -45);
      ctx.closePath();
      ctx.fill();
      // Cross
      ctx.strokeStyle = glowing ? '#ffdd88' : '#6a5a4a';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(0, -63);
      ctx.lineTo(0, -55);
      ctx.moveTo(-3, -60);
      ctx.lineTo(3, -60);
      ctx.stroke();
      // Window
      ctx.fillStyle = glowing ? '#ffdd88' : '#5a4a3a';
      ctx.fillRect(-3, -20, 6, 8);
      break;
  }

  ctx.restore();
}

// ============================================================================
// SNOW PARTICLES
// ============================================================================

let snowParticles = [];
let shakeTurbulence = 0;
let globeTilt = { x: 0, y: 0 };

function initSnowParticles() {
  snowParticles = [];
  for (let i = 0; i < 150; i++) {
    const angle = Math.random() * Math.PI * 2;
    const distance = Math.random() * globeRadius * 0.9;
    snowParticles.push({
      x: centerX + Math.cos(angle) * distance,
      y: centerY + Math.sin(angle) * distance,
      vx: 0,
      vy: Math.random() * 0.3 + 0.1,
      size: Math.random() * 2 + 1,
      opacity: Math.random() * 0.5 + 0.5
    });
  }
}

function updateSnowParticles() {
  shakeTurbulence *= 0.96; // Decay

  snowParticles.forEach(p => {
    // Apply turbulence
    if (shakeTurbulence > 0) {
      p.vx += (Math.random() - 0.5) * shakeTurbulence * 0.5;
      p.vy += (Math.random() - 0.5) * shakeTurbulence * 0.5;
    }

    // Gentle settling
    p.vx *= 0.98;
    p.vy = p.vy * 0.98 + 0.02; // Gravity

    // Update position
    p.x += p.vx;
    p.y += p.vy;

    // Constrain to globe
    const dx = p.x - centerX;
    const dy = p.y - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > globeRadius * 0.95) {
      const angle = Math.atan2(dy, dx);
      p.x = centerX + Math.cos(angle) * globeRadius * 0.95;
      p.y = centerY + Math.sin(angle) * globeRadius * 0.95;
      p.vx *= -0.5;
      p.vy *= -0.5;
    }

    // Reset if at bottom
    if (p.y > centerY + globeRadius * 0.45) {
      p.y = centerY - globeRadius * 0.9;
      p.x = centerX + (Math.random() - 0.5) * globeRadius * 1.5;
      p.vy = Math.random() * 0.3 + 0.1;
      p.vx = 0;
    }
  });

  // Tilt decay
  globeTilt.x *= 0.9;
  globeTilt.y *= 0.9;
}

function drawSnowParticles() {
  ctx.save();

  // Clip to globe
  ctx.beginPath();
  ctx.arc(centerX, centerY, globeRadius * 0.95, 0, Math.PI * 2);
  ctx.clip();

  snowParticles.forEach(p => {
    ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });

  ctx.restore();
}

// ============================================================================
// TIME-BASED SKY
// ============================================================================

function getSkyColors() {
  const now = new Date();
  const hours = now.getHours();
  const minutes = now.getMinutes();
  const timeValue = hours + minutes / 60;

  // Night: 21-5
  // Dawn: 5-7
  // Day: 7-17
  // Dusk: 17-21

  if (timeValue >= 21 || timeValue < 5) {
    // Night
    return {
      top: '#0a0e1a',
      bottom: '#1a2840',
      stars: true
    };
  } else if (timeValue >= 5 && timeValue < 7) {
    // Dawn
    const t = (timeValue - 5) / 2;
    return {
      top: interpolateColor('#0a0e1a', '#4a5a8a', t),
      bottom: interpolateColor('#1a2840', '#d48a5a', t),
      stars: t < 0.5
    };
  } else if (timeValue >= 7 && timeValue < 17) {
    // Day
    return {
      top: '#4a5a8a',
      bottom: '#6a8aaa',
      stars: false
    };
  } else {
    // Dusk
    const t = (timeValue - 17) / 4;
    return {
      top: interpolateColor('#4a5a8a', '#0a0e1a', t),
      bottom: interpolateColor('#6a8aaa', '#1a2840', t),
      stars: t > 0.7
    };
  }
}

function interpolateColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1, 3), 16);
  const g1 = parseInt(c1.slice(3, 5), 16);
  const b1 = parseInt(c1.slice(5, 7), 16);

  const r2 = parseInt(c2.slice(1, 3), 16);
  const g2 = parseInt(c2.slice(3, 5), 16);
  const b2 = parseInt(c2.slice(5, 7), 16);

  const r = Math.round(r1 + (r2 - r1) * t);
  const g = Math.round(g1 + (g2 - g1) * t);
  const b = Math.round(b1 + (b2 - b1) * t);

  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// ============================================================================
// RENDERING
// ============================================================================

function drawScene() {
  // Clear
  ctx.fillStyle = '#1a1410';
  ctx.fillRect(0, 0, width, height);

  // Ambient room elements
  drawRoomReflections();

  // Globe base
  drawBase();

  // Globe interior
  ctx.save();
  ctx.translate(globeTilt.x * 2, globeTilt.y * 2);

  // Sky background
  const sky = getSkyColors();
  const skyGradient = ctx.createRadialGradient(centerX, centerY - globeRadius * 0.3, 0, centerX, centerY, globeRadius);
  skyGradient.addColorStop(0, sky.top);
  skyGradient.addColorStop(1, sky.bottom);

  ctx.save();
  ctx.beginPath();
  ctx.arc(centerX, centerY, globeRadius * 0.95, 0, Math.PI * 2);
  ctx.clip();
  ctx.fillStyle = skyGradient;
  ctx.fillRect(centerX - globeRadius, centerY - globeRadius, globeRadius * 2, globeRadius * 2);
  ctx.restore();

  // Stars
  if (sky.stars) {
    drawStars();
  }

  // Ground
  ctx.save();
  ctx.beginPath();
  ctx.arc(centerX, centerY, globeRadius * 0.95, 0, Math.PI * 2);
  ctx.clip();

  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.ellipse(centerX, centerY + globeRadius * 0.4, globeRadius * 0.8, globeRadius * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Soft shadow gradient on ground
  const groundGradient = ctx.createRadialGradient(centerX, centerY + globeRadius * 0.3, 0, centerX, centerY + globeRadius * 0.4, globeRadius * 0.6);
  groundGradient.addColorStop(0, 'rgba(200, 220, 240, 0)');
  groundGradient.addColorStop(1, 'rgba(100, 120, 140, 0.2)');
  ctx.fillStyle = groundGradient;
  ctx.fillRect(centerX - globeRadius, centerY, globeRadius * 2, globeRadius);

  ctx.restore();

  // Scene elements (tasks)
  tasks.forEach((task, index) => {
    const pos = getElementPosition(task, index, tasks.length);
    drawElement(pos.x, pos.y, pos.type, pos.scale, task.completed, task.id === selectedTaskId);
  });

  // Snow
  drawSnowParticles();

  ctx.restore();

  // Globe glass
  drawGlobe();
}

function drawRoomReflections() {
  // Subtle table surface
  const tableGradient = ctx.createLinearGradient(0, height * 0.85, 0, height);
  tableGradient.addColorStop(0, 'rgba(90, 58, 26, 0)');
  tableGradient.addColorStop(1, 'rgba(90, 58, 26, 0.3)');
  ctx.fillStyle = tableGradient;
  ctx.fillRect(0, height * 0.85, width, height * 0.15);

  // Warm light source suggestion (top corner)
  const lightGradient = ctx.createRadialGradient(width * 0.8, height * 0.2, 0, width * 0.8, height * 0.2, height * 0.4);
  lightGradient.addColorStop(0, 'rgba(255, 200, 120, 0.05)');
  lightGradient.addColorStop(1, 'rgba(255, 160, 80, 0)');
  ctx.fillStyle = lightGradient;
  ctx.fillRect(0, 0, width, height);
}

function drawBase() {
  const baseTopY = baseY;
  const baseBottomY = baseY + baseHeight;
  const baseTopWidth = globeRadius * 0.5;
  const baseBottomWidth = globeRadius * 0.7;

  // Wood grain gradient
  const baseGradient = ctx.createLinearGradient(0, baseTopY, 0, baseBottomY);
  baseGradient.addColorStop(0, '#8a6a3a');
  baseGradient.addColorStop(0.5, '#6a4a2a');
  baseGradient.addColorStop(1, '#5a3a1a');

  ctx.fillStyle = baseGradient;
  ctx.beginPath();
  ctx.moveTo(centerX - baseTopWidth, baseTopY);
  ctx.lineTo(centerX + baseTopWidth, baseTopY);
  ctx.lineTo(centerX + baseBottomWidth, baseBottomY);
  ctx.lineTo(centerX - baseBottomWidth, baseBottomY);
  ctx.closePath();
  ctx.fill();

  // Decorative ridge
  ctx.strokeStyle = '#a87a4a';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(centerX - baseTopWidth, baseTopY + 5);
  ctx.lineTo(centerX + baseTopWidth, baseTopY + 5);
  ctx.stroke();

  // Bottom edge
  ctx.fillStyle = '#4a2a1a';
  ctx.fillRect(centerX - baseBottomWidth, baseBottomY, baseBottomWidth * 2, 8);
}

function drawGlobe() {
  // Main glass border
  ctx.strokeStyle = 'rgba(200, 220, 240, 0.3)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(centerX, centerY, globeRadius, 0, Math.PI * 2);
  ctx.stroke();

  // Specular highlight
  const highlightGradient = ctx.createRadialGradient(
    centerX - globeRadius * 0.3,
    centerY - globeRadius * 0.3,
    0,
    centerX - globeRadius * 0.3,
    centerY - globeRadius * 0.3,
    globeRadius * 0.4
  );
  highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
  highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

  ctx.fillStyle = highlightGradient;
  ctx.beginPath();
  ctx.arc(centerX - globeRadius * 0.3, centerY - globeRadius * 0.3, globeRadius * 0.4, 0, Math.PI * 2);
  ctx.fill();

  // Bottom reflection
  const reflectionGradient = ctx.createRadialGradient(
    centerX,
    centerY + globeRadius * 0.6,
    0,
    centerX,
    centerY + globeRadius * 0.6,
    globeRadius * 0.3
  );
  reflectionGradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
  reflectionGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

  ctx.fillStyle = reflectionGradient;
  ctx.beginPath();
  ctx.arc(centerX, centerY + globeRadius * 0.6, globeRadius * 0.3, 0, Math.PI * 2);
  ctx.fill();
}

function drawStars() {
  ctx.save();
  ctx.beginPath();
  ctx.arc(centerX, centerY, globeRadius * 0.95, 0, Math.PI * 2);
  ctx.clip();

  // Fixed star positions based on seed
  const starCount = 30;
  for (let i = 0; i < starCount; i++) {
    const seed = i * 12345;
    const angle = (seed % 360) * Math.PI / 180;
    const distance = (seed % 70) / 100 * globeRadius * 0.7;
    const x = centerX + Math.cos(angle) * distance;
    const y = centerY - globeRadius * 0.5 + Math.sin(angle) * distance * 0.5;

    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + (seed % 40) / 100})`;
    ctx.beginPath();
    ctx.arc(x, y, 1 + (seed % 10) / 10, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}

// ============================================================================
// MOUSE INTERACTION
// ============================================================================

let isDragging = false;
let lastMouseX = 0;
let lastMouseY = 0;
let mouseVelX = 0;
let mouseVelY = 0;

canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
  mouseVelX = 0;
  mouseVelY = 0;
});

canvas.addEventListener('mousemove', (e) => {
  if (isDragging) {
    const dx = e.clientX - lastMouseX;
    const dy = e.clientY - lastMouseY;

    mouseVelX = dx;
    mouseVelY = dy;

    globeTilt.x += dx * 0.1;
    globeTilt.y += dy * 0.1;

    // Clamp tilt
    globeTilt.x = Math.max(-20, Math.min(20, globeTilt.x));
    globeTilt.y = Math.max(-20, Math.min(20, globeTilt.y));

    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  }
});

canvas.addEventListener('mouseup', () => {
  if (isDragging) {
    const speed = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
    if (speed > 15) {
      // Shake!
      shakeTurbulence = Math.min(speed / 10, 5);

      // Randomize snow velocities
      snowParticles.forEach(p => {
        p.vx = (Math.random() - 0.5) * shakeTurbulence * 2;
        p.vy = (Math.random() - 0.5) * shakeTurbulence * 2;
      });

      playShakeSound();
    }
  }
  isDragging = false;
});

canvas.addEventListener('mouseleave', () => {
  isDragging = false;
});

// Touch support
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  isDragging = true;
  lastMouseX = touch.clientX;
  lastMouseY = touch.clientY;
  mouseVelX = 0;
  mouseVelY = 0;
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (isDragging) {
    const touch = e.touches[0];
    const dx = touch.clientX - lastMouseX;
    const dy = touch.clientY - lastMouseY;

    mouseVelX = dx;
    mouseVelY = dy;

    globeTilt.x += dx * 0.1;
    globeTilt.y += dy * 0.1;

    globeTilt.x = Math.max(-20, Math.min(20, globeTilt.x));
    globeTilt.y = Math.max(-20, Math.min(20, globeTilt.y));

    lastMouseX = touch.clientX;
    lastMouseY = touch.clientY;
  }
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (isDragging) {
    const speed = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
    if (speed > 15) {
      shakeTurbulence = Math.min(speed / 10, 5);
      snowParticles.forEach(p => {
        p.vx = (Math.random() - 0.5) * shakeTurbulence * 2;
        p.vy = (Math.random() - 0.5) * shakeTurbulence * 2;
      });
      playShakeSound();
    }
  }
  isDragging = false;
});

// ============================================================================
// AUDIO - MUSIC BOX
// ============================================================================

let audioContext = null;
let musicBoxInterval = null;
let currentNoteIndex = 0;

function initAudioContext() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
}

function initMusicBox() {
  if (musicBoxInterval) {
    clearInterval(musicBoxInterval);
    musicBoxInterval = null;
  }

  if (tasks.length === 0) return;

  // Create a melody from tasks
  const baseNotes = [523.25, 587.33, 659.25, 698.46, 783.99]; // C, D, E, F, G
  const melody = tasks.map((task, i) => {
    const hash = hashString(task.text);
    return baseNotes[hash % baseNotes.length];
  });

  // Play melody slowly
  currentNoteIndex = 0;
  musicBoxInterval = setInterval(() => {
    if (melody.length > 0) {
      playMusicBoxNote(melody[currentNoteIndex]);
      currentNoteIndex = (currentNoteIndex + 1) % melody.length;
    }
  }, 1500);
}

function playMusicBoxNote(frequency) {
  initAudioContext();

  const now = audioContext.currentTime;
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();

  oscillator.type = 'sine';
  oscillator.frequency.value = frequency;

  gainNode.gain.setValueAtTime(0.08, now);
  gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.8);

  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);

  oscillator.start(now);
  oscillator.stop(now + 0.8);
}

function playShakeSound() {
  initAudioContext();

  const now = audioContext.currentTime;
  const noise = audioContext.createBufferSource();
  const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.3, audioContext.sampleRate);
  const data = buffer.getChannelData(0);

  for (let i = 0; i < data.length; i++) {
    data[i] = (Math.random() * 2 - 1) * 0.1;
  }

  noise.buffer = buffer;

  const filter = audioContext.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 800;

  const gainNode = audioContext.createGain();
  gainNode.gain.setValueAtTime(0.15, now);
  gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

  noise.connect(filter);
  filter.connect(gainNode);
  gainNode.connect(audioContext.destination);

  noise.start(now);
  noise.stop(now + 0.3);
}

// Enable audio on first user interaction
document.addEventListener('click', initAudioContext, { once: true });

// ============================================================================
// ANIMATION LOOP
// ============================================================================

function animate() {
  updateSnowParticles();
  drawScene();
  requestAnimationFrame(animate);
}

// ============================================================================
// INITIALIZATION
// ============================================================================

loadTasks();
renderTaskList();
initSnowParticles();
initMusicBox();
animate();

</script>

</body>
</html>
